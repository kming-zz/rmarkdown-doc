--- 
title: "R Markdown: The Definitive Guide"
author: "Yihui Xie, J. J. Allaire, Garrett Grolemund"
date: "`r Sys.Date()`"
documentclass: krantz
bibliography: [book.bib, packages.bib]
biblio-style: apalike
link-citations: yes
colorlinks: yes
graphics: yes
lot: yes
lof: yes
fontsize: 11pt
mainfont: Palatino
monofont: "Source Code Pro"
monofontoptions: "Scale=0.8"
site: bookdown::bookdown_site
description: "The first official book authored by the core R Markdown developers that provides a comprehensive and accurate reference to the R Markdown ecosystem. With R Markdown, you can easily create reproducible data analysis reports, presentations, dashboards, interactive applications, books, dissertations, websites, and journal articles, while enjoying the simplicity of Markdown and the great power of R and other languages."
url: 'https\://bookdown.org/yihui/rmarkdown/'
github-repo: rstudio/rmarkdown-book
cover-image: images/cover.png
---

```{r setup, include=FALSE}
options(
  htmltools.dir.version = FALSE, formatR.indent = 2,
  width = 55, digits = 4, warnPartialMatchAttr = FALSE, warnPartialMatchDollar = FALSE
)

options(bookdown.post.latex = function(x) {
  # only build a skeleton for the online version
  if (Sys.getenv('BOOKDOWN_FULL_PDF', '') == 'false') return(bookdown:::strip_latex_body(
    x, '\nThis PDF is only a skeleton. Please either read the free online HTML version, or purchase a hard-copy of this book.\n'
    ))

  # fix syntax highlighting:
  # \FunctionTok{tufte:}\AttributeTok{:tufte_html: default} ->
  # \FunctionTok{tufte::tufte_html:}\AttributeTok{ default}
  x = gsub('(\\\\FunctionTok\\{[^:]+:)(})(\\\\AttributeTok\\{)(:[^:]+:)', '\\1\\4\\2\\3', x)
  # an ugly hack for Table 16.1 (Pandoc's widths are not good)
  if (length(grep('0.47\\\\columnwidth', x)) == 0) stop('Table 16.1 not found')
  x = gsub('( & \\\\begin\\{minipage\\}\\[[tb]]\\{)0.47(\\\\columnwidth})', '\\10.65\\2', x)
  x = gsub('(^\\\\begin\\{minipage\\}\\[[tb]]\\{)0.47(\\\\columnwidth})', '\\10.33\\2', x)
  if (length(i <- grep('^\\\\begin\\{longtable\\}', x)) == 0) return(x)
  i1 = bookdown:::next_nearest(i, which(x == '\\toprule'))
  i2 = bookdown:::next_nearest(i, which(x == '\\endfirsthead'))
  x[i1 - 1] = paste0(x[i1 - 1], '\n\\begin{tabular}{', gsub('[^lcr]', '', gsub('.*\\[]', '', x[i])), '}')
  x[i] = '\\begin{table}'
  x[x == '\\end{longtable}'] = '\\end{tabular}\n\\end{table}'
  x[x == '\\endhead'] = ''
  x = x[-unlist(mapply(seq, i1, i2, SIMPLIFY = FALSE))]
  x
})

lapply(c('xfun'), function(pkg) {
  if (system.file(package = pkg) == '') install.packages(pkg)
})

if (!xfun::loadable('sigma', new_session = TRUE)) source('https://install-github.me/jjallaire/sigma')
```

# Preface {-}

```{asis, echo=identical(knitr:::pandoc_to(), 'html')}
**Note**: This book has been published by [Chapman & Hall/CRC](https://www.crcpress.com/p/book/9781138359338). The online version of this book is free to read here (thanks to Chapman & Hall/CRC), and licensed under the [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License](http://creativecommons.org/licenses/by-nc-sa/4.0/).

<p style="text-align: center;"><a href="https://www.crcpress.com/p/book/9781138359338"><img src="images/cover.png" alt="The R Markdown book cover" /></a></p>
```

The document format "R Markdown" was first introduced in the **knitr** package [@xie2015; @R-knitr] in early 2012. The idea was to embed code chunks (of R or other languages) in Markdown documents. In fact, **knitr** supported several authoring languages from the beginning in addition to Markdown, including LaTeX, HTML, AsciiDoc, reStructuredText, and Textile. Looking back over the five years, it seems to be fair to say that Markdown has become the most popular document format, which is what we expected. The simplicity of Markdown clearly stands out among these document formats.

However, the original version of Markdown [invented by John Gruber](https://en.wikipedia.org/wiki/Markdown) was often found overly simple and not suitable to write highly technical documents. For example, there was no syntax for tables, footnotes, math expressions, or citations. Fortunately, John MacFarlane created a wonderful package named Pandoc (http://pandoc.org) to convert Markdown documents (and many other types of documents) to a large variety of output formats. More importantly, the Markdown syntax was significantly enriched. Now we can write more types of elements with Markdown while still enjoying its simplicity.

In a nutshell, R Markdown stands on the shoulders of **knitr** and Pandoc. The former executes the computer code embedded in Markdown, and converts R Markdown to Markdown. The latter renders Markdown to the output format you want (such as PDF, HTML, Word, and so on).

```{r fig.align='center', echo=FALSE, include=identical(knitr:::pandoc_to(), 'html'), fig.link='https://github.com/rstudio/rmarkdown', out.width='30%'}
knitr::include_graphics('images/hex-rmarkdown.png', dpi = NA)
```

The **rmarkdown** package [@R-rmarkdown] was first created in early 2014. During the past four years, it has steadily evolved into a relatively complete ecosystem for authoring documents, so it is a good time for us to provide a definitive guide to this ecosystem now. At this point, there are a large number of tasks that you could do with R Markdown:

- Compile a single R Markdown document to a report in different formats, such as PDF, HTML, or Word.

- Create notebooks in which you can directly run code chunks interactively.

- Make slides for presentations (HTML5, LaTeX Beamer, or PowerPoint).

- Produce dashboards with flexible, interactive, and attractive layouts.

- Build interactive applications based on Shiny.

- Write journal articles.

- Author books of multiple chapters.

- Generate websites and blogs.

There is a fundamental assumption underneath R Markdown that users should be aware of: we assume it suffices that only a limited number of features are supported in Markdown. By "features", we mean the types of elements you can create with native Markdown. The limitation is a great feature, not a bug. R Markdown may not be the right format for you if you find these elements not enough for your writing: paragraphs, (section) headers, block quotations, code blocks, (numbered and unnumbered) lists, horizontal rules, tables, inline formatting (emphasis, strikeout, superscripts, subscripts, verbatim, and small caps text), LaTeX math expressions, equations, links, images, footnotes, citations, theorems, proofs, and examples. We believe this list of elements suffice for most technical and non-technical documents. It may not be impossible to support other types of elements in R Markdown, but you may start to lose the simplicity of Markdown if you wish to go that far.

Epictetus once said, "_Wealth consists not in having great possessions, but in having few wants._" The spirit is also reflected in Markdown. If you can control your preoccupation with pursuing typesetting features, you should be much more efficient in writing the content and can become a prolific author. It is entirely possible to succeed with simplicity. Jung Jae-sung was a legendary badminton player with a remarkably simple playing style: he did not look like a talented player and was very short compared to other players, so most of the time you would just see him jump three feet off the ground and smash like thunder over and over again in the back court until he beats his opponents.

Please do not underestimate the customizability of R Markdown because of the simplicity of its syntax. In particular, Pandoc templates can be surprisingly powerful, as long as you understand the underlying technologies such as LaTeX and CSS, and are willing to invest time in the appearance of your output documents (reports, books, presentations, and/or websites). As one example, you may check out the [PDF report](http://files.kff.org/attachment/Report-Employer-Health-Benefits-Annual-Survey-2017) of the [2017 Employer Health Benefits Survey](https://www.kff.org/health-costs/report/2017-employer-health-benefits-survey/). It looks fairly sophisticated, but was actually produced via **bookdown** [@xie2016], which is an R Markdown extension. A custom LaTeX template and a lot of LaTeX tricks were used to generate this report. Not surprisingly, this very book that you are reading right now was also written in R Markdown, and its full source is publicly available in the GitHub repository https://github.com/rstudio/rmarkdown-book.

R Markdown documents are often portable in the sense that they can be compiled to multiple types of output formats. Again, this is mainly due to the simplified syntax of the authoring language, Markdown. The simpler the elements in your document are, the more likely that the document can be converted to different formats. Similarly, if you heavily tailor R Markdown to a specific output format (e.g., LaTeX), you are likely to lose the portability, because not all features in one format work in another format.

Last but not least, your computing results will be more likely to be reproducible if you use R Markdown (or other **knitr**-based source documents), compared to the manual cut-and-paste approach. This is because the results are dynamically generated from computer source code. If anything goes wrong or needs to be updated, you can simply fix or update the source code, compile the document again, and the results will automatically updated. You can enjoy reproducibility and convenience at the same time.

## How to read this book {-}

This book may serve you better as a reference book than a textbook. It contains a large number of technical details, and we do not expect you to read it from beginning to end, since you may easily feel overwhelmed. Instead, think about your background and what you want to do first, and go to the relevant chapters or sections. For example:

- I just want to finish my course homework (Chapter \@ref(basics) should be more than enough for you).

- I know this is an R Markdown book, but I use Python more than R (Go to Section \@ref(python)).

- I want to embed interactive plots in my reports, or want my readers to be able change my model parameters interactively and see results on the fly (Check out Section \@ref(interactive-documents)).

- I know the output format I want to use, and I want to customize its appearance (Check out the documentation of the specific output format in Chapter \@ref(documents) or Chapter \@ref(presentations)). For example, I want to customize the template for my PowerPoint presentation (Go to Section \@ref(ppt-templates)).

- I want to build a business dashboard highlighting some key figures and indicators (Go to Chapter \@ref(dashboards)).

- I heard about `yolo = TRUE` from a friend, and I'm curious what that means in the **xaringan** package (Go to Chapter \@ref(xaringan)).

- I want to build a personal website (Go to Chapter \@ref(websites)), or write a book (Go to Chapter \@ref(books)).

- I want to write a paper and submit to the Journal of Statistical Software (Go to Chapter \@ref(journals)).

- I want to build an interactive tutorial with exercises for my students to learn a topic (Go to Chapter \@ref(learnr)).

- I'm familiar with R Markdown now, and I want to generate personalized reports for all my customers using the same R Markdown template (Try parameterized reports in Chapter \@ref(parameterized-reports)).

- I know some JavaScript, and want to build an interface in R to call an interested JavaScript library from R (Learn how to develop HTML widgets in Chapter \@ref(html-widgets)).

- I want to build future reports with a company branded template that shows our logo and uses our unique color theme (Go to Chapter \@ref(document-templates)).

If you are not familiar with R Markdown, we recommend that you read at least Chapter \@ref(basics) to learn the basics. All the rest of the chapters in this book can be read in any order you desire. They are pretty much orthogonal to each other. However, to become familiar with R Markdown output formats, you may want to thumb through the HTML document format in Section \@ref(html-document), because many other formats share the same options as this format.

## Structure of the book {-}

This book consists of four parts. Part I covers the basics: Chapter \@ref(installation) introduces how to install the relevant packages, and Chapter \@ref(basics) is an overview of R Markdown, including the possible output formats, the Markdown syntax, the R code chunk syntax, and how to use other languages in R Markdown.

Part II is the detailed documentation of built-in output formats in the **rmarkdown** package, including document formats and presentation formats.

Part III lists about ten R Markdown extensions that enable you to build different applications or generate output documents with different styles. Chapter \@ref(dashboards) introduces the basics of building flexible dashboards with the R package **flexdashboard**. Chapter \@ref(tufte-handouts) documents the **tufte** package, which provides a unique document style used by Edward Tufte. Chapter \@ref(xaringan) introduces the **xaringan** package for another highly flexible and customizable HTML5 presentation format based on the JavaScript library remark.js. Chapter \@ref(revealjs) documents the **revealjs** package, which provides yet another appealing HTML5 presentation format based on the JavaScript library reveal.js. Chapter \@ref(community) introduces a few output formats created by the R community, such as the **prettydoc** package, which features lightweight HTML document formats. Chapter \@ref(websites) teaches you how to build websites using either the **blogdown** package or **rmarkdown**'s built-in site generator. Chapter \@ref(pkgdown) explains the basics of the **pkgdown** package, which can be used to quickly build documentation websites for R packages. Chapter \@ref(books) introduces how to write and publish books with the **bookdown** package. Chapter \@ref(journals) is an overview of the **rticles** package for authoring journal articles. Chapter \@ref(learnr) introduces how to build interactive tutorials with exercises and/or quiz questions.

Part IV covers other topics about R Markdown, and some of them are advanced (in particular, Chapter \@ref(html-widgets)). Chapter \@ref(parameterized-reports) introduces how to generate different reports with the same R Markdown source document and different parameters. Chapter \@ref(html-widgets) teaches developers how to build their own HTML widgets for interactive visualization and applications with JavaScript libraries. Chapter \@ref(document-templates) shows how to create custom R Markdown and Pandoc templates so that you can fully customize the appearance and style of your output document. Chapter \@ref(new-formats) explains how to create your own output formats if the existing formats do not meet your need. Chapter \@ref(shiny-documents) shows how to combine the Shiny framework with R Markdown, so that your readers can interact with the reports by changing the values of certain input widgets and seeing updated results immediately.

Note that this book is intended to be a guide instead of the comprehensive documentation of all topics related to R Markdown. Some chapters are only overviews, and you may need to consult the full documentation elsewhere (often freely available online). Such examples include Chapters \@ref(dashboards), \@ref(websites), \@ref(pkgdown), \@ref(books), and \@ref(learnr).

## Software information and conventions {#software-info .unnumbered}

The R session information when compiling this book is shown below:

```{r tidy=FALSE}
xfun::session_info(c(
  'blogdown', 'bookdown', 'knitr', 'rmarkdown', 'htmltools',
  'reticulate', 'rticles', 'flexdashboard', 'learnr', 'shiny',
  'revealjs', 'pkgdown', 'tinytex', 'xaringan', 'tufte'
), dependencies = FALSE)
```

We do not add prompts (`>` and `+`) to R source code in this book, and we comment out the text output with two hashes `##` by default, as you can see from the R session information above. This is for your convenience when you want to copy and run the code (the text output will be ignored since it is commented out). Package names are in bold text (e.g., **rmarkdown**), and inline code and filenames are formatted in a typewriter font (e.g., `knitr::knit('foo.Rmd')`). Function names are followed by parentheses (e.g., `blogdown::serve_site()`). The double-colon operator `::` means accessing an object from a package.

"Rmd" is the filename extension of R Markdown files, and also an abbreviation of R Markdown in this book.

## Acknowledgments {-}

I started writing this book after I came back from the 2018 RStudio Conference in early February, and finished the first draft in early May. This may sound fast for a 300-page book. The main reason I was able to finish it quickly was that I worked full-time on this book for three months. My employer, RStudio, has always respected my personal interests and allowed me to focus on projects that I choose by myself. More importantly, I have been taught several lessons on how to become a professional software engineer since I joined RStudio as a fresh PhD, although [the initial journey turned out to be painful.](https://yihui.name/en/2018/02/career-crisis/) It is a great blessing for me to work in this company.

The other reason for my speed was that JJ and Garrett had already prepared a lot of materials that I could adapt for this book. They had also been offering suggestions as I worked on the manuscript. In addition, [Michael Harper](http://mikeyharper.uk) contributed the initial drafts of Chapters \@ref(books), \@ref(journals), \@ref(parameterized-reports), \@ref(document-templates), and \@ref(new-formats). I would definitely not be able to finish this book so quickly without their help.

The most challenging thing to do when writing a book is to find large blocks of uninterrupted time. This is just so hard. Both others and myself could interrupt me. I do not consider my willpower to be strong: I read random articles, click on the endless links on Wikipedia, look at random Twitter messages, watch people fight on meaningless topics online, reply to emails all the time as if I were able to reach "Inbox Zero", and write random blog posts from time to time. The two most important people in terms of helping keep me on track are Tareef Kawaf (President of RStudio), to whom I report my progress on the weekly basis, and [Xu Qin](https://www.education.pitt.edu/people/XuQin), from whom [I really learned](https://d.cosx.org/d/419325) the importance of making plans on a daily basis (although I still fail to do so sometimes). For interruptions from other people, it is impossible to isolate myself from the outside world, so I'd like to thank those who did not email me or ask me questions in the past few months and used public channels instead [as I suggested](https://yihui.name/en/2017/08/so-gh-email/). I also thank those who did not get mad at me when my responses were extremely slow or even none. I appreciate all your understanding and patience. Besides, several users have started helping me answer GitHub and Stack Overflow questions related to R packages that I maintain, which is even better! These users include [Marcel Schilling](https://yihui.name/en/2018/01/thanks-marcel-schilling/), [Xianying Tan](https://shrektan.com), [Christophe Dervieux](https://github.com/cderv), and [Garrick Aden-Buie](https://www.garrickadenbuie.com), just to name a few. As someone who works from home, apparently I would not even have ten minutes of uninterrupted time if I do not send the little ones to daycare, so I want to thank all teachers at Small Miracle for freeing my daytime.

There have been a large number of contributors to the R Markdown ecosystem. [More than 60 people](https://github.com/rstudio/rmarkdown/graphs/contributors) have contributed to the core package, **rmarkdown**. Several authors have created their own R Markdown extensions, as introduced in Part III of this book. Contributing ideas is no less helpful than contributing code. We have gotten numerous inspirations and ideas from the R community via various channels (GitHub issues, Stack Overflow questions, and private conversations, etc.). As a small example, Jared Lander, author of the book _R for Everyone_, does not meet me often, but every time he chats with me, I will get something valuable to work on. "How about writing books with R Markdown?" he asked me at the 2014 Strata conference in New York. Then we invented **bookdown** in 2016. "I really need fullscreen background images in ioslides. [Look, Yihui, here are my ugly JavaScript hacks,](https://www.jaredlander.com/2017/07/fullscreen-background-images-in-ioslides-presentations/)" he showed me on the shuttle to dinner at the 2017 RStudio Conference. A year later, background images were officially supported in ioslides presentations.

As I mentioned previously, R Markdown is standing on the shoulders of the giant, Pandoc. I'm always amazed by how fast John MacFarlane, the main author of Pandoc, responds to my GitHub issues. It is hard to imagine a person dealing with [5000 GitHub issues](https://github.com/jgm/pandoc) over the years while maintaining the excellent open-source package and driving the Markdown standards forward. We should all be grateful to John and contributors of Pandoc.

As I was working on the draft of this book, I received a lot of helpful reviews from these reviewers: John Gillett (University of Wisconsin), Rose Hartman (UnderstandingData), Amelia McNamara (Smith College), Ariel Muldoon (Oregon State University), Yixuan Qiu (Purdue University), Benjamin Soltoff (University of Chicago),
David Whitney (University of Washington), and Jon Katz (independent data analyst). Tareef Kawaf (RStudio) also volunteered to read the manuscript and provided many helpful comments. [Aaron Simumba](https://asimumba.rbind.io), [Peter Baumgartner](http://peter.baumgartner.name), and [Daijiang Li](https://daijiang.name) volunteered to carefully correct many of my typos. In particular, Aaron has been such a big helper with my writing (not limited to only this book) and [sometimes I have to compete with him](https://github.com/rbind/yihui/commit/d8f39f7aa) in correcting my typos!

There are many colleagues at RStudio whom I want to thank for making it so convenient and even enjoyable to author R Markdown documents, especially the RStudio IDE team including J.J. Allaire, Kevin Ushey, Jonathan McPherson, and many others.

Personally I often feel motivated by members of the R community. My own willpower is weak, but I can gain a lot of power from this amazing community. Overall the community is very encouraging, and sometimes even fun, which makes me enjoy my job. For example, I do not think you can often use the picture of a professor for fun in your software, but the ["desiccated baseR-er"](https://twitter.com/kwbroman/status/922545181634768897) Karl Broman is an exception (see Section \@ref(yolo-true)), as he allowed me to use a mysteriously happy picture of him.

Lastly, I want to thank my editor, John Kimmel, for his continued help with my fourth book. I think I have said enough about him and his team at Chapman & Hall in my previous books. The publishing experience has always been so smooth. I just wonder if it would be possible someday that our meticulous copy-editor, Suzanne Lassandro, would fail to identify more than 30 issues for me to correct in my first draft. Probably not. Let's see.

```{block2, type='flushright', html.tag='p'}
Yihui Xie  
Elkhorn, Nebraska
```

<!--chapter:end:index.Rmd-->

# About the Authors {#author .unnumbered}

This book is primarily put together by me (Yihui Xie), making use of the existing R documentation of the **rmarkdown** package and the **rmarkdown** website, which were mainly contributed by J.J. Allaire and Garrett Grolemund.

## Yihui Xie {-}

Yihui Xie (<https://yihui.name>) is a software engineer at RStudio (<https://www.rstudio.com>). He earned his PhD from the Department of Statistics, Iowa State University. He is interested in interactive statistical graphics and statistical computing. As an active R user, he has authored several R packages, such as **knitr**, **bookdown**, **blogdown**, **xaringan**, **tinytex**, **animation**, **DT**, **tufte**, **formatR**, **fun**, **xfun**, **mime**, **highr**, **servr**, and **Rd2roxygen**, among which the **animation** package won the 2009 John M. Chambers Statistical Software Award (ASA). He also co-authored a few other R packages, including **shiny**, **rmarkdown**, and **leaflet**.

He has authored two books, _Dynamic Documents with knitr_ [@xie2015], and _bookdown: Authoring Books and Technical Documents with R Markdown_ [@xie2016], and co-authored two book, _blogdown: Creating Websites with R Markdown_ [@xie2017], and _R Markdown: The Definitive Guide_ [@xie2018].

In 2006, he founded the Capital of Statistics (<https://cosx.org>), which has grown into a large online community on statistics in China. He initiated the Chinese R conference in 2008, and has been involved in organizing R conferences in China since then. During his PhD training at Iowa State University, he won the Vince Sposito Statistical Computing Award (2011) and the Snedecor Award (2012) in the Department of Statistics.

He occasionally rants on Twitter (https://twitter.com/xieyihui), and most of the time you can find him on GitHub (https://github.com/yihui).

He enjoys spicy food as much as classical Chinese literature.

## J.J. Allaire {-}

J.J. Allaire is the founder of RStudio and the creator of the RStudio IDE. J.J. is an author of several packages in the R Markdown ecosystem including **rmarkdown**, **flexdashboard**, **learnr**, and **radix**. 

## Garrett Grolemund {-}

Garrett Grolemund is the co-author of _R for Data Science_ and author of _Hands-On Programming with R_. He wrote the **lubridate** R package and works for RStudio as an advocate who trains engineers to do data science with R and the Tidyverse. If you use R yourself, you may recognize Garrett from his video courses on Datacamp.com and O'Reilly media, or for his series of popular R cheatsheets distributed by RStudio.

Garrett earned his PhD in Statistics from Rice University in 2012 under the guidance of Hadley Wickham. Before that, he earned a Bachelor's degree in Psychology from Harvard University and briefly attended law school. Garrett has been one of the foremost promoters of Shiny, R Markdown, and the Tidyverse, documenting and explaining each in detail.

<!--chapter:end:00-author.Rmd-->

\mainmatter

# (PART) Get Started {-}

# Installation

We assume you have already installed R (https://www.r-project.org) [@R-base] and the RStudio IDE (https://www.rstudio.com). RStudio is not required but recommended, because it makes it easier for an average user to work with R Markdown. If you do not have RStudio IDE installed, you will have to install Pandoc\index{Pandoc} (http://pandoc.org), otherwise there is no need to install Pandoc separately because RStudio has bundled it. Next you can install the **rmarkdown** package in R:

```{r eval=FALSE, tidy=FALSE}
# Install from CRAN
install.packages('rmarkdown')

# Or if you want to test the development version,
# install from GitHub
if (!requireNamespace("devtools"))
  install.packages('devtools')
devtools::install_github('rstudio/rmarkdown')
```

If you want to generate PDF output, you will need to install LaTeX. For R Markdown users who have not installed LaTeX before, we recommend that you install TinyTeX (https://yihui.name/tinytex/):

```{r eval=FALSE}
install.packages('tinytex')
tinytex::install_tinytex()  # install TinyTeX
```

TinyTeX\index{TinyTeX} is a lightweight, portable, cross-platform, and easy-to-maintain LaTeX distribution. The R companion package **tinytex** [@R-tinytex]\index{tinytex} can help you automatically install missing LaTeX packages when compiling LaTeX or R Markdown documents to PDF, and also ensures a LaTeX document is compiled for the correct number of times to resolve all cross-references. If you do not understand what these two things mean, you should probably follow our recommendation to install TinyTeX, because these details are often not worth your time or attention.

With the **rmarkdown** package, RStudio/Pandoc, and LaTeX, you should be able to compile most R Markdown documents. In some cases, you may need other software packages, and we will mention them when necessary.

<!--chapter:end:01-installation.Rmd-->

# Basics

R Markdown provides an authoring framework for data science. You can use a single R Markdown file to both

- save and execute code, and

- generate high quality reports that can be shared with an audience.

R Markdown was designed for easier reproducibility, since both the computing code and narratives are in the same document, and results are automatically generated from the source code. R Markdown supports dozens of static and dynamic/interactive output formats.

If you prefer a video introduction to R Markdown, we recommend that you check out the website https://rmarkdown.rstudio.com, and watch the videos in the "Get Started" section, which cover the basics of R Markdown.

Below is a minimal R Markdown document, which should be a plain-text file, with the conventional extension `.Rmd`:

```{r include=FALSE}
b = '`r b[1]`'  # an ugly hack; don't look at me
```
```yaml
---
title: "Hello R Markdown"
author: "Awesome Me"
date: "2018-02-14"
output: html_document
---
```
````markdown
This is a paragraph in an R Markdown document.

Below is a code chunk:

`r ''````{r}
fit = lm(dist ~ speed, data = cars)
b   = coef(fit)
plot(cars)
abline(fit)
```

The slope of the regression is `r b[1]`.
````

You can create such a text file with any editor (including but not limited to RStudio). If you use RStudio, you can create a new Rmd file from the menu `File -> New File -> R Markdown`.

There are three basic components of an R Markdown document: the metadata, text, and code. The metadata is written between the pair of three dashes `---`. The syntax for the metadata is YAML (YAML Ain't Markup Language, https://en.wikipedia.org/wiki/YAML),\index{YAML} so sometimes it is also called the YAML metadata or the YAML frontmatter. Before it bites you hard, we want to warn you in advance that indentation matters in YAML, so do not forget to indent the sub-fields of a top field properly. See the [Appendix B.2](https://bookdown.org/yihui/bookdown/r-markdown.html) of @xie2016 for a few simple examples that show the YAML syntax.

The body of a document follows the metadata. The syntax for text (also known as prose or narratives) is Markdown, which is introduced in Section \@ref(markdown-syntax). There are two types of computer code, which are explained in detail in Section \@ref(r-code):

- A code chunk\index{code chunk} starts with three backticks like ```` ```{r} ```` where `r` indicates the language name,^[It is not limited to the R language; see Section \@ref(language-engines) for how to use other languages.] and ends with three backticks. You can write chunk options in the curly braces (e.g., set the figure height to 5 inches: ```` ```{r, fig.height=5} ````).

- An inline R code expression\index{inline R expression} starts with `` `r `` and ends with a backtick `` ` ``.

Figure \@ref(fig:hello-rmd) shows the above example in the RStudio IDE. You can click the `Knit` button to compile the document (to an HTML page). Figure \@ref(fig:hello-rmd-out) shows the output in the RStudio Viewer.

```{r hello-rmd, echo=FALSE, fig.cap='A minimal R Markdown example in RStudio.', out.width='100%'}
knitr::include_graphics('images/hello-rmd.png', dpi = NA)
```

```{r hello-rmd-out, echo=FALSE, fig.cap='The output document of the minimal R Markdown example in RStudio.', out.width='100%'}
knitr::include_graphics('images/hello-rmd-out.png', dpi = NA)
```

Now please take a closer look at the example. Did you notice a problem? The object `b` is the vector of coefficients of length 2 from the linear regression; `b[1]` is actually the intercept, and `b[2]` is the slope! This minimal example shows you why R Markdown is great for reproducible research\index{reproducible research}: it includes the source code right inside the document, which makes it easy to discover and fix problems, as well as update the output document. All you have to do is change `b[1]` to `b[2]`, and click the `Knit` button again. Had you copied a number `-17.579` computed elsewhere into this document, it would be very difficult to realize the problem. In fact, I had used this example a few times by myself in my presentations before I discovered this problem during one of my talks, but I discovered it anyway.

Although the above is a toy example, it could become a horror story if it happens in scientific research that was not done in a reproducible way (e.g., cut-and-paste). Here are two of my personal favorite videos on this topic:

- "A reproducible workflow" by Ignasi Bartomeus and Francisco Rodríguez-Sánchez (https://youtu.be/s3JldKoA0zw). It is a 2-min video that looks artistic but also shows very common and practical problems in data analysis.

    <iframe width="100%" height="400" src="https://www.youtube.com/embed/s3JldKoA0zw?rel=0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>

- "The Importance of Reproducible Research in High-Throughput Biology" by Keith Baggerly (https://youtu.be/7gYIs7uYbMo). You will be impressed by both the content and the style of this lecture. Keith Baggerly and Kevin Coombes were the two notable heroes in revealing [the Duke/Potti scandal](https://en.wikipedia.org/wiki/Anil_Potti), which was described as "one of the biggest medical research frauds ever" by the television program "60 Minutes".

    <iframe width="100%" height="400" src="https://www.youtube.com/embed/7gYIs7uYbMo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>

It is fine for humans to err (in computing), as long as the source code is readily available.

## Example applications {#basics-examples}

Now you have learned the very basic concepts of R Markdown. The idea should be simple enough: interweave narratives with code in a document, knit the document to dynamically generate results from the code, and you will get a report. This idea was not invented by R Markdown, but came from an early programming paradigm called "Literate Programming" [@knuth1984]\index{Literate Programming}.

Due to the simplicity of Markdown and the powerful R language for data analysis, R Markdown has been widely used in many areas. Before we dive into the technical details, we want to show some examples to give you an idea of its possible applications.

### Airbnb's knowledge repository

Airbnb uses R Markdown to document all their analyses in R, so they can combine code and data visualizations in a single report [@bion2018]. Eventually all reports are carefully peer-reviewed and published to a company knowledge repository, so that anyone in the company can easily find analyses relevant to their team. Data scientists are also able to learn as much as they want from previous work or reuse the code written by previous authors, because the full R Markdown source is available in the repository.

### Homework assignments on RPubs

A huge number of homework assignments have been published to the website https://RPubs.com (a free publishing platform provided by RStudio), which shows that R Markdown is easy and convenient enough for students to do their homework assignments (see Figure \@ref(fig:rpubs)). When I was still a student, I did most of my homework assignments using Sweave, which was a much earlier implementation of literate programming based on the S language (later R) and LaTeX. I was aware of the importance of reproducible research but did not enjoy LaTeX, and few of my classmates wanted to use Sweave. Right after I graduated, R Markdown was born, and it has been great to see so many students do their homework in the reproducible manner.

```{r rpubs, echo=FALSE, fig.cap='A screenshot of RPubs.com that contains some homework assginments submitted by students.', out.width='100%'}
knitr::include_graphics('images/rpubs.png', dpi = NA)
```

In a 2016 JSM (Joint Statistical Meetings) talk, I proposed that course instructors could sometimes intentionally insert some wrong values in the source data before providing it to the students for them to analyze the data in the homework, then correct these values the next time, and ask them to do the analysis again. This way, students should be able to realize the problems with the traditional cut-and-paste approach for data analysis (i.e., run the analysis separately and copy the results manually), and the advantage of using R Markdown to automatically generate the report.

### Personalized mail

One thing you should remember about R Markdown is that you can programmatically generate reports, although most of the time you may be just clicking the `Knit` button in RStudio to generate a single report from a single source document. Being able to program reports is a super power of R Markdown.

Mine Çetinkaya-Rundel once wanted to create personalized handouts for her workshop participants. She used a template R Markdown file, and knitted it in a for-loop to generate 20 PDF files for the 20 participants. Each PDF contained both personalized information and common information. You may read the article https://rmarkdown.rstudio.com/articles_mail_merge.html for the technical details.

### 2017 Employer Health Benefits Survey

The [2017 Employer Health Benefits Survey](https://www.kff.org/health-costs/report/2017-employer-health-benefits-survey/) was designed and analyzed by the Kaiser Family Foundation, NORC at the University of Chicago, and Health Research & Educational Trust. The full PDF report was written in R Markdown (with the **bookdown** package). It has a unique appearance, which was made possible by heavy customizations in the LaTeX template. This example shows you that if you really care about typesetting, you are free to apply your knowledge about LaTeX to create highly sophisticated reports from R Markdown.

### Journal articles {#examples-journal}

Chris Hartgerink explained how and why he used R Markdown to write dynamic research documents in the post at https://elifesciences.org/labs/cad57bcf/composing-reproducible-manuscripts-using-r-markdown. He published a paper titled "Too Good to be False: Nonsignificant Results Revisited" with two co-authors [@hartgerink2017]. The manuscript was written in R Markdown, and results were dynamically generated from the code in R Markdown.

When checking the accuracy of P-values in the psychology literature, his colleagues and he found that P-values could be mistyped or miscalculated, which could lead to inaccurate or even wrong conclusions. If the P-values were dynamically generated and inserted instead of being manually copied from statistical programs, the chance for those problems to exist would be much lower.

@lowndes2017 also shows that using R Markdown (and version control) not only enhances reproducibility, but also produces better scientific research in less time.

### Dashboards at eelloo

R Markdown is used at eelloo (https://eelloo.nl) to design and generate research reports. Here is one of their examples (in Dutch): https://eelloo.nl/groepsrapportages-met-infographics/, where you can find gauges, bar charts, pie charts, wordclouds, and other types of graphs dynamically generated and embedded in dashboards.

### Books {#examples-books}

We will introduce the R Markdown extension **bookdown** in Chapter \@ref(books). It is an R package that allows you to write books and long-form reports with multiple Rmd files. After this package was published, a large number of books have emerged. You can find a subset of them at https://bookdown.org. Some of these books have been printed, and some only have free online versions.

There have also been students who wrote their dissertations/theses with **bookdown**, such as Ed Berry: https://eddjberry.netlify.com/post/writing-your-thesis-with-bookdown/. Chester Ismay has even provided an R package **thesisdown** (https://github.com/ismayc/thesisdown) \index{thesisdown} that can render a thesis in various formats. Several other people have customized this package for their own institutions, such as Zhian N. Kamvar's **beaverdown** (https://github.com/zkamvar/beaverdown) and Ben Marwick's **huskydown** (https://github.com/benmarwick/huskydown).

### Websites {#examples-websites}

The **blogdown** package to be introduced in Chapter \@ref(websites) can be used to build general-purpose websites (including blogs and personal websites) based on R Markdown. You may find tons of examples at https://github.com/rbind or by searching on Twitter: https://twitter.com/search?q=blogdown. Here are a few impressive websites that I can quickly think of off the top of my head:

- Rob J Hyndman's personal website: https://robjhyndman.com (a very comprehensive academic website).

- Amber Thomas's personal website: https://amber.rbind.io (a rich project portfolio).

- Emi Tanaka's personal website: https://emitanaka.github.io (in particular, check out the beautiful showcase page).

- "Live Free or Dichotomize" by Nick Strayer and Lucy D'Agostino McGowan: http://livefreeordichotomize.com (the layout is elegant, and the posts are useful and practical).

## Compile an R Markdown document {#compile}

The usual way to compile an R Markdown document is to click the `Knit` button as shown in Figure \@ref(fig:hello-rmd), and the corresponding keyboard shortcut is `Ctrl + Shift + K` (`Cmd + Shift + K` on macOS). Under the hood, RStudio calls the function `rmarkdown::render()` to render the document _in a new R session_. Please note the emphasis here, which often confuses R Markdown users. Rendering an Rmd document in a new R session means that _none of the objects in your current R session (e.g., those you created in your R console) are available to that session_.^[This is not strictly true, but mostly true. You may save objects in your current R session to a file, e.g., `.RData`, and load it in a new R session.] Reproducibility is the main reason that RStudio uses a new R session to render your Rmd documents: in most cases, you may want your documents to continue to work the next time you open R, or in other people's computing environments. See [this StackOverflow answer](https://stackoverflow.com/a/48494678/559676) if you want to know more.

If you must render a document in the current R session, you can also call `rmarkdown::render()` by yourself, and pass the path of the Rmd file to this function. The second argument of this function is the output format, which defaults to the first output format you specify in the YAML metadata (if it is missing, the default is `html_document`). When you have multiple output formats in the metadata, and do not want to use the first one, you can specify the one you want in the second argument, e.g., for an Rmd document `foo.Rmd` with the metadata:

```yaml
output:
  html_document:
    toc: true
  pdf_document:
    keep_tex: true
```

You can render it to PDF via:

```r
rmarkdown::render('foo.Rmd', 'pdf_document')
```

The function call gives you much more freedom (e.g., you can generate a series of reports in a loop), but you should bear reproducibility in mind when you render documents this way. Of course, you can start a new and clean R session by yourself, and call `rmarkdown::render()` in that session. As long as you do not manually interact with that session (e.g., manually creating variables in the R console), your reports should be reproducible.

Another main way to work with Rmd documents is the R Markdown Notebooks, which will be introduced in Section \@ref(notebook). With notebooks, you can run code chunks individually and see results right inside the RStudio editor. This is a convenient way to interact or experiment with code in an Rmd document, because you do not have to compile the whole document. Without using the notebooks, you can still partially execute code chunks, but the execution only occurs in the R console, and the notebook interface presents results of code chunks right beneath the chunks in the editor, which can be a great advantage. Again, for the sake of reproducibility, you will need to compile the whole document eventually in a clean environment.

Lastly, I want to mention an "unofficial" way to compile Rmd documents: the function `xaringan::inf_mr()`, or equivalently, the RStudio addin "Infinite Moon Reader". Obviously, this requires you to install the **xaringan** package [@R-xaringan], which is available on CRAN. The main advantage of this way is LiveReload: a technology that enables you to live preview the output as soon as you save the source document, and you do not need to hit the `Knit` button. The other advantage is that it compiles the Rmd document _in the current R session_, which may or may not be what you desire. Note that this method only works for Rmd documents that output to HTML, including HTML documents and presentations.

A few R Markdown extension packages, such as **bookdown** and **blogdown**, have their own way of compiling documents, and we will introduce them later.

Note that it is also possible to render a series of reports instead of single one from a single R Markdown source document. You can parameterize an R Markdown document, and generate different reports using different parameters. See Chapter \@ref(parameterized-reports) for details.

## Cheat sheets

RStudio has created a large number of cheat sheets, including the one-page R Markdown cheat sheet, which are freely available at https://www.rstudio.com/resources/cheatsheets/. There is also a more detailed R Markdown reference guide. Both documents can be used as quick references after you become more familiar with R Markdown.

## Output formats

There are two types of output formats\index{output formats} in the **rmarkdown** package: documents, and presentations. All available formats are listed below:

`r knitr::combine_words(grep('^[^_]+_(document|presentation)$', ls(asNamespace('rmarkdown')), value = TRUE), sep = '\n', and = '', before = '- \x60', after = '\x60')`

We will document these output formats in detail in Chapters \@ref(documents) and \@ref(presentations). There are more output formats provided in other extension packages (starting from Chapter \@ref(dashboards)). For the output format names in the YAML metadata of an Rmd file, you need to include the package name if a format is from an extension package, e.g.,

```yaml
output: tufte::tufte_html
```

If the format is from the **rmarkdown** package, you do not need the `rmarkdown::` prefix (although it will not hurt).

When there are multiple output formats in a document, there will be a dropdown menu behind the RStudio `Knit` button that lists the output format names (Figure \@ref(fig:format-dropdown)).

```{r format-dropdown, echo=FALSE, fig.cap='The output formats listed in the dropdown menu on the RStudio toolbar.', out.width='50%', fig.align='center'}
knitr::include_graphics('images/format-dropdown.png', dpi = NA)
```

Each output format is often accompanied with several format options. All these options are documented on the R package help pages. For example, you can type `?rmarkdown::html_document` in R to open the help page of the `html_document` format. When you want to use certain options, you have to translate the values from R to YAML,\index{YAML} e.g.,

```r
html_document(toc = TRUE, toc_depth = 2, dev = 'svg')
```

can be written in YAML as:

```yaml
output:
  html_document:
    toc: true
    toc_depth: 2
    dev: 'svg'
```

The translation is often straightforward. Remember that R's `TRUE`, `FALSE`, and `NULL` are `true`, `false`, and `null`, respectively, in YAML. Character strings in YAML often do not require the quotes (e.g., `dev: 'svg'` and `dev: svg` are the same), unless they contain special characters, such as the colon `:`. If you are not sure if a string should be quoted or not, test it with the **yaml** package, e.g.,

```{r test-yaml, tidy=FALSE, comment='', class.output='yaml'}
cat(yaml::as.yaml(list(
  title = 'A Wonderful Day',
  subtitle = 'hygge: a quality of coziness'
)))
```

Note that the subtitle in the above example is quoted because of the colon.

If you have options that need to be the result of an evaluated R expression, you can use `!expr`, which tells the 
**yaml** package that it needs to parse and evaluate that option. Below is an example that uses a random theme for the HTML output:

```yaml
output:
  html_document:
    theme: !expr sample(c("yeti", "united", "lumen"), 1)
```

If a certain option has sub-options (which means the value of this option is a list in R), the sub-options need to be further indented, e.g.,

```yaml
output:
  html_document:
    toc: true
    includes:
      in_header: header.html
      before_body: before.html
```

Some options are passed to **knitr**, such as `dev`, `fig_width`, and `fig_height`. Detailed documentation of these options can be found on the **knitr** documentation page: https://yihui.name/knitr/options/. Note that the actual **knitr** option names can be different. In particular, **knitr** uses `.` in names, but **rmarkdown** uses `_`, e.g., `fig_width` in **rmarkdown** corresponds to `fig.width` in **knitr**. We apologize for the inconsistencies---programmers often strive for consistencies in their own world, yet one standard plus one standard [often equals three standards.](https://xkcd.com/927/) If I were to design the **knitr** package again, I would definitely use `_`.

Some options are passed to Pandoc, such as `toc`, `toc_depth`, and `number_sections`. You should consult the Pandoc documentation when in doubt. R Markdown output format functions often have a `pandoc_args` argument, which should be a character vector of extra arguments to be passed to Pandoc. If you find any Pandoc features that are not represented by the output format arguments, you may use this ultimate argument, e.g.,

```yaml
output:
  pdf_document:
    toc: true
    pandoc_args: ["--wrap=none", "--top-level-division=chapter"]
```

## Markdown syntax

The text in an R Markdown document is written with the Markdown syntax\index{Markdown syntax}. Precisely speaking, it is Pandoc's Markdown. There are many flavors of Markdown invented by different people, and Pandoc's flavor is the most comprehensive one to our knowledge. You can find the full documentation of Pandoc's Markdown at https://pandoc.org/MANUAL.html. We strongly recommend that you read this page at least once to know all the possibilities with Pandoc's Markdown, even if you will not use all of them. This section is adapted from [Section 2.1](https://bookdown.org/yihui/bookdown/markdown-syntax.html) of @xie2016, and only covers a small subset of Pandoc's Markdown syntax.

### Inline formatting

Inline text will be _italic_ if surrounded by underscores or asterisks, e.g., `_text_` or `*text*`. **Bold** text is produced using a pair of double asterisks (`**text**`). A pair of tildes (`~`) turn text to a subscript (e.g., `H~3~PO~4~` renders H~3~PO~4~). A pair of carets (`^`) produce a superscript (e.g., `Cu^2+^` renders Cu^2+^).

To mark text as `inline code`, use a pair of backticks, e.g., `` `code` ``. To include $n$ literal backticks, use at least $n+1$ backticks outside, e.g., you can use four backticks to preserve three backtick inside: ````` ```` ```code``` ```` `````, which is rendered as ```` ```code``` ````.

Hyperlinks are created using the syntax `[text](link)`, e.g., `[RStudio](https://www.rstudio.com)`. The syntax for images is similar: just add an exclamation mark, e.g., `![alt text or image title](path/to/image)`. Footnotes are put inside the square brackets after a caret `^[]`, e.g., `^[This is a footnote.]`.

There are multiple ways to insert citations,\index{citation} and we recommend that you use BibTeX databases, because they work better when the output format is LaTeX/PDF. [Section 2.8](https://bookdown.org/yihui/bookdown/citations.html) of @xie2016 has explained the details. The key idea is that when you have a BibTeX database (a plain-text file with the conventional filename extension `.bib`) that contains entries like:

```bibtex
@Manual{R-base,
  title = {R: A Language and Environment for Statistical
    Computing},
  author = {{R Core Team}},
  organization = {R Foundation for Statistical Computing},
  address = {Vienna, Austria},
  year = {2017},
  url = {https://www.R-project.org/},
}
```

You may add a field named `bibliography` to the YAML metadata, and set its value to the path of the BibTeX file. Then in Markdown, you may use `@R-base` (which generates "@R-base") or `[@R-base]` (which generates "[@R-base]") to reference the BibTeX entry. Pandoc will automatically generated a list of references in the end of the document.

### Block-level elements

Section headers can be written after a number of pound signs, e.g.,

```markdown
# First-level header

## Second-level header

### Third-level header
```

If you do not want a certain heading to be numbered, you can add `{-}` or `{.unnumbered}` after the heading, e.g.,

```markdown
# Preface {-}
```

Unordered list items start with `*`, `-`, or `+`, and you can nest one list within another list by indenting the sub-list, e.g.,

```markdown
- one item
- one item
- one item
    - one more item
    - one more item
    - one more item
```

The output is:

- one item
- one item
- one item
    - one more item
    - one more item
    - one more item

Ordered list items start with numbers (you can also nest lists within lists), e.g.,

```markdown
1. the first item
2. the second item
3. the third item
    - one unordered item
    - one unordered item
```

The output does not look too much different with the Markdown source:

1. the first item
2. the second item
3. the third item
    - one unordered item
    - one unordered item

Blockquotes are written after `>`, e.g.,

```markdown
> "I thoroughly disapprove of duels. If a man should challenge me,
  I would take him kindly and forgivingly by the hand and lead him
  to a quiet place and kill him."
>
> --- Mark Twain
```

The actual output (we customized the style for blockquotes in this book):

> "I thoroughly disapprove of duels. If a man should challenge me,
  I would take him kindly and forgivingly by the hand and lead him
  to a quiet place and kill him."
>
> --- Mark Twain

Plain code blocks can be written after three or more backticks, and you can also indent the blocks by four spaces, e.g.,

````markdown
```
This text is displayed verbatim / preformatted
```

Or indent by four spaces:

    This text is displayed verbatim / preformatted
````

In general, you'd better leave at least one empty line between adjacent but different elements, e.g., a header and a paragraph. This is to avoid ambiguity to the Markdown renderer. For example, does "`#`" indicate a header below?

```markdown
In R, the character
# indicates a comment.
```

And does "`-`" mean a bullet point below?

```markdown
The result of 5
- 3 is 2.
```

Different flavors of Markdown may produce different results if there are no blank lines.

### Math expressions

Inline LaTeX equations\index{LaTeX math} can be written in a pair of dollar signs using the LaTeX syntax, e.g., `$f(k) = {n \choose k} p^{k} (1-p)^{n-k}$` (actual output: $f(k)={n \choose k}p^{k}(1-p)^{n-k}$); math expressions of the display style can be written in a pair of double dollar signs, e.g., `$$f(k) = {n \choose k} p^{k} (1-p)^{n-k}$$`, and the output looks like this:

$$f\left(k\right)=\binom{n}{k}p^k\left(1-p\right)^{n-k}$$

You can also use math environments inside `$ $` or `$$ $$`, e.g.,

```latex
$$\begin{array}{ccc}
x_{11} & x_{12} & x_{13}\\
x_{21} & x_{22} & x_{23}
\end{array}$$
```

$$\begin{array}{ccc}
x_{11} & x_{12} & x_{13}\\
x_{21} & x_{22} & x_{23}
\end{array}$$

```latex
$$X = \begin{bmatrix}1 & x_{1}\\
1 & x_{2}\\
1 & x_{3}
\end{bmatrix}$$
```

$$X = \begin{bmatrix}1 & x_{1}\\
1 & x_{2}\\
1 & x_{3}
\end{bmatrix}$$

```latex
$$\Theta = \begin{pmatrix}\alpha & \beta\\
\gamma & \delta
\end{pmatrix}$$
```

$$\Theta = \begin{pmatrix}\alpha & \beta\\
\gamma & \delta
\end{pmatrix}$$

```latex
$$\begin{vmatrix}a & b\\
c & d
\end{vmatrix}=ad-bc$$
```

$$\begin{vmatrix}a & b\\
c & d
\end{vmatrix}=ad-bc$$

## R code chunks and inline R code {#r-code}

You can insert an R code chunk\index{code chunk} either using the RStudio toolbar (the `Insert` button) or the keyboard shortcut `Ctrl + Alt + I` (`Cmd + Option + I` on macOS).

There are a lot of things you can do in a code chunk: you can produce text output, tables, or graphics. You have fine control over all these output via chunk options, which can be provided inside the curly braces (between ```` ```{r```` and `}`). For example, you can choose hide text output via the chunk option `results = 'hide'`, or set the figure height to 4 inches via `fig.height = 4`. Chunk options are separated by commas, e.g.,

````markdown
`r ''````{r, chunk-label, results='hide', fig.height=4}
````

The value of a chunk option can be an arbitrary R expression, which makes chunk options extremely flexible. For example, the chunk option `eval` controls whether to evaluate (execute) a code chunk, and you may conditionally evaluate a chunk via a variable defined previously, e.g.,

````markdown
`r ''````{r}
# execute code if the date is later than a specified day
do_it = Sys.Date() > '2018-02-14'
```

`r ''````{r, eval=do_it}
x = rnorm(100)
```
````

There are a large number of chunk options\index{chunk options} in **knitr** documented at https://yihui.name/knitr/options. We list a subset of them below:

- `eval`: Whether to evaluate a code chunk.

- `echo`: Whether to echo the source code in the output document (someone may not prefer reading your smart source code but only results).

- `results`: When set to `'hide'`, text output will be hidden; when set to `'asis'`, text output is written "as-is", e.g., you can write out raw Markdown text from R code (like `cat('**Markdown** is cool.\n')`). By default, text output will be wrapped in verbatim elements (typically plain code blocks).

- `collapse`: Whether to merge text output and source code into a single code block in the output. This is mostly cosmetic: `collapse = TRUE` makes the output more compact, since the R source code and its text output are displayed in a single output block. The default `collapse = FALSE` means R expressions and their text output are separated into different blocks.

- `warning`, `message`, and `error`: Whether to show warnings, messages, and errors in the output document. Note that if you set `error = FALSE`, `rmarkdown::render()` will halt on error in a code chunk, and the error will be displayed in the R console. Similarly, when `warning = FALSE` or `message = FALSE`, these messages will be shown in the R console.

- `include`: Whether to include anything from a code chunk in the output document. When `include = FALSE`, this whole code chunk is excluded in the output, but note that it will still be evaluated if `eval = TRUE`. When you are trying to set `echo = FALSE`, `results = 'hide'`, `warning = FALSE`, and `message = FALSE`, chances are you simply mean a single option `include = FALSE` instead of suppressing different types of text output individually.

- `cache`: Whether to enable caching. If caching is enabled, the same code chunk will not be evaluated the next time the document is compiled (if the code chunk was not modified), which can save you time. However, I want to honestly remind you of the two hard problems in computer science (via Phil Karlton): naming things, and cache invalidation. Caching can be handy but also tricky sometimes.

- `fig.width` and `fig.height`: The (graphical device) size of R plots in inches. R plots in code chunks are first recorded via a graphical device in **knitr**, and then written out to files. You can also specify the two options together in a single chunk option `fig.dim`, e.g., `fig.dim = c(6, 4)` means `fig.width = 6` and `fig.height = 4`.

- `out.width` and `out.height`: The output size of R plots in the output document. These options may scale images. You can use percentages, e.g., `out.width = '80%'` means 80% of the page width.

- `fig.align`: The alignment of plots. It can be `'left'`, `'center'`, or `'right'`.

- `dev`: The graphical device to record R plots. Typically it is `'pdf'` for LaTeX output, and `'png'` for HTML output, but you can certainly use other devices, such as `'svg'` or `'jpeg'`.

- `fig.cap`: The figure caption.

- `child`: You can include a child document in the main document. This option takes a path to an external file.

Chunk options in **knitr** can be surprisingly powerful. For example, you can create animations from a series of plots in a code chunk. I will not explain how here because [it requires an external software package](https://blogdown-demo.rbind.io/2018/01/31/gif-animations/), but encourage you to read the documentation carefully to discover the possibilities. You may also read @xie2015, which is a comprehensive guide to the **knitr** package, but unfortunately biased towards LaTeX users for historical reasons (which was one of the reasons why I wanted to write this R Markdown book).

There is an optional chunk option that does not take any value, which is the chunk label. It should be the first option in the chunk header. Chunk labels are mainly used in filenames of plots and cache. If the label of a chunk is missing, a default one of the form `unnamed-chunk-i` will be generated, where `i` is incremental. I strongly recommend that you only use alphanumeric characters (`a-z`, `A-Z` and `0-9`) and dashes (`-`) in labels, because they are not special characters and will surely work for all output formats. Other characters, spaces and underscores in particular, may cause trouble in certain packages, such as **bookdown**.

If a certain option needs to be frequently set to a value in multiple code chunks, you can consider setting it globally in the first code chunk of your document, e.g.,

````markdown
`r ''````{r, setup, include=FALSE}
knitr::opts_chunk$set(fig.width = 8, collapse = TRUE)
```
````

Besides code chunks, you can also insert values of R objects inline in text.\index{inline R expression} For example:

````markdown
`r ''````{r}
x = 5  # radius of a circle
```

For a circle with the radius `r '\x60r x\x60'`,
its area is `r '\x60r pi * x^2\x60'`.
````

### Figures

By default, figures\index{figures} produced by R code will be placed immediately after the code chunk they were generated from. For example:

````markdown
`r ''````{r}
plot(cars, pch = 18)
```
````

You can provide a figure caption using `fig.cap` in the chunk options. If the document output format supports the option `fig_caption: true` (e.g., the output format `rmarkdown::html_document`), the R plots will be placed into figure environments. In the case of PDF output, such figures will be automatically numbered. If you also want to number figures in other formats (such as HTML), please see the **bookdown** package in Chapter \@ref(books) (in particular, see Section \@ref(a-single-document)).

PDF documents are generated through the LaTeX files generated from R Markdown. A highly surprising fact to LaTeX beginners is that figures float by default: even if you generate a plot in a code chunk on the first page, the whole figure environment may float to the next page. This is just how LaTeX works by default. It has a tendency to float figures to the top or bottom of pages. Although it can be annoying and distracting, we recommend that you refrain from playing the "Whac-A-Mole" game in the beginning of your writing, i.e., desparately trying to position figures "correctly" while they seem to be always dodging you. You may wish to fine-tune the positions once the content is complete using the `fig.pos` chunk option (e.g., `fig.pos = 'h')`. See https://www.overleaf.com/learn/latex/Positioning_images_and_tables for possible values of `fig.pos` and more general tips about this behavior in LaTeX. In short, this can be a difficult problem for PDF output.

To place multiple figures side-by-side from the same code chunk, you can use the `fig.show='hold'` option along with the `out.width` option. Figure \@ref(fig:hold-position) shows an example with two plots, each with a width of `50%`.

```{r hold-position, fig.cap='Two plots side-by-side.', fig.show='hold', out.width='50%', fig.width=5, fig.height=4}
par(mar = c(4, 4, .2, .1))
plot(cars, pch = 19)
plot(pressure, pch = 17)
```

If you want to include a graphic that is not generated from R code, you may use the `knitr::include_graphics()` function, which gives you more control over the attributes of the image than the Markdown syntax of `![alt text or image title](path/to/image)` (e.g., you can specify the image width via `out.width`). Figure \@ref(fig:include-graphics) provides an example of this.

````markdown
`r ''````{r, out.width='25%', fig.align='center', fig.cap='...'}
knitr::include_graphics('images/hex-rmarkdown.png')
```
````
```{r include-graphics, echo=FALSE, fig.cap='The R Markdown hex logo.', out.width='25%', fig.align='center'}
knitr::include_graphics('images/hex-rmarkdown.png')
```

### Tables

The easiest way to include tables\index{tables} is by using `knitr::kable()`, which can create tables for HTML, PDF and Word outputs.^[You may also consider the **pander** package. There are several other packages for producing tables, including **xtable**, **Hmisc**, and **stargazer**, but these are generally less compatible with multiple output formats.] Table captions can be included by passing `caption` to the function, e.g.,

````markdown
`r ''````{r tables-mtcars}
knitr::kable(iris[1:5, ], caption = 'A caption')
```
````

Tables in non-LaTeX output formats will always be placed after the code block. For LaTeX/PDF output formats, tables have the same issue as figures: they may float. If you want to avoid this behavior, you will need to use the LaTeX package [longtable](https://www.ctan.org/pkg/longtable), which can break tables across multiple pages. This can be achieved by adding `\usepackage{longtable}` to your LaTeX preamble, and passing `longtable = TRUE` to `kable()`.

If you are looking for more advanced control of the styling of tables, you are recommended to use the [**kableExtra**](https://cran.r-project.org/package=kableExtra) package, which provides functions to customize the appearance of PDF and HTML tables. Formatting tables can be a very complicated task, especially when certain cells span more than one column or row. It is even more complicated when you have to consider different output formats. For example, it is difficult to make a complex table work for both PDF and HTML output. We know it is disappointing, but sometimes you may have to consider alternative ways of presenting data, such as using graphics.

We explain in Section \@ref(bookdown-markdown) how the **bookdown** package extends the functionality of **rmarkdown** to allow for figures and tables to be easily cross-referenced within your text.

## Other language engines {#language-engines}

A less well-known fact about R Markdown is that many other languages are also supported, such as Python, Julia, C++, and SQL. The support comes from the **knitr** package, which has provided a large number of _language engines_. Language engines are essentially functions registered in the object `knitr::knit_engine`. You can list the names of all available engines via:

```{r all-engines}
names(knitr::knit_engines$get())
```

Most engines have been documented in Chapter 11 of @xie2015. The engines from `theorem` to `solution` are only available when you use the **bookdown** package, and the rest are shipped with the **knitr** package. To use a different language engine, you can change the language name in the chunk header from `r` to the engine name, e.g.,

````markdown
`r ''````{python}
x = 'hello, python world!'
print(x.split(' '))
```
````

For engines that rely on external interpreters such as `python`, `perl`, and `ruby`, the default interpreters are obtained from `Sys.which()`, i.e., using the interpreter found via the environment variable `PATH` of the system. If you want to use an alternative interpreter, you may specify its path in the chunk option `engine.path`. For example, you may want to use Python 3 instead of the default Python 2, and we assume Python 3 is at `/usr/bin/python3` (may not be true for your system):

````markdown
`r ''````{python, engine.path = '/usr/bin/python3'}
import sys
print(sys.version)
```
````

You can also change the engine interpreters globally for multiple engines, e.g.,

```{r engine-path, eval=FALSE, tidy=FALSE}
knitr::opts_chunk$set(engine.path = list(
  python = '~/anaconda/bin/python',
  ruby = '/usr/local/bin/ruby'
))
```

Note that you can use a named list to specify the paths for different engines.

Most engines will execute each code chunk in a separate new session (via a `system()` call in R), which means objects created in memory in a previous code chunk will not be directly available to latter code chunks. For example, if you create a variable in a `bash` code chunk, you will not be able to use it in the next `bash` code chunk. Currently the only exceptions are `r`, `python`, and `julia`. Only these engines execute code in the same session throughout the document. To clarify, all `r` code chunks are executed in the same R session, all `python` code chunks are executed in the same Python session, and so on, but _the R session and the Python session are independent_.^[This is not strictly true, since the Python session is actually launched from R. What I mean here is that you should not expect to use R variables and Python variables interchangeably without explicitly importing/exporting variables between the two sessions.]

I will introduce some specific features and examples for a subset of language engines in **knitr** below. Note that most chunk options should work for both R and other languages, such as `eval` and `echo`, so these options will not be mentioned again.

### Python

The `python` engine is based on the **reticulate** package [@R-reticulate], which makes it possible to execute all Python\index{Python} code chunks in the same Python session. If you actually want to execute a certain code chunk in a new Python session, you may use the chunk option `python.reticulate = FALSE`. If you are using a **knitr** version lower than 1.18, you should update your R packages.

Below is a relatively simple example that shows how you can create/modify variables, and draw graphics in Python code chunks. Values can be passed to or retrieved from the Python session. To pass a value to Python, assign to `py$name`, where `name` is the variable name you want to use in the Python session; to retrieve a value from Python, also use `py$name`.

````markdown
`r xfun::file_string('examples/python.Rmd')`
````

You may learn more about the **reticulate** package from https://rstudio.github.io/reticulate/.

### Shell scripts

You can also write Shell scripts\index{Shell script} in R Markdown, if your system can run them (the executable `bash` or `sh` should exist). Usually this is not a problem for Linux or macOS users. It is not impossible for Windows users to run Shell scripts, but you will have to install additional software (such as [Cygwin](https://www.cygwin.com) or the Linux Subsystem).

````markdown
`r ''````{bash}
echo "Hello Bash!"
cat flights1.csv flights2.csv flights3.csv > flights.csv
```
````

Shell scripts are executed via the `system2()` function in R. Basically **knitr** passes a code chunk to the command `bash -c` to run it.

### SQL

The `sql` engine uses the [**DBI**](https://cran.rstudio.com/package=DBI) package to execute SQL\index{SQL} queries, print their results, and optionally assign the results to a data frame.

To use the `sql` engine, you first need to establish a DBI connection to a database (typically via the `DBI::dbConnect()` function). You can make use of this connection in a `sql` chunk via the `connection` option. For example:

````markdown
`r ''````{r}
library(DBI)
db = dbConnect(RSQLite::SQLite(), dbname = "sql.sqlite")
```

`r ''````{sql, connection=db}
SELECT * FROM trials
```
````

By default, `SELECT` queries will display the first 10 records of their results within the document. The number of records displayed is controlled by the `max.print` option, which is in turn derived from the global **knitr** option `sql.max.print` (e.g., `knitr::opts_knit$set(sql.max.print = 10)`; N.B. it is `opts_knit` instead of `opts_chunk`). For example, the following code chunk displays the first 20 records:

````markdown
`r ''````{sql, connection=db, max.print = 20}
SELECT * FROM trials
```
````

You can specify no limit on the records to be displayed via `max.print = -1` or `max.print = NA`.

By default, the `sql` engine includes a caption that indicates the total number of records displayed. You can override this caption using the `tab.cap` chunk option. For example:

````markdown
`r ''````{sql, connection=db, tab.cap = "My Caption"}
SELECT * FROM trials
```
````

You can specify that you want no caption all via `tab.cap = NA`.

If you want to assign the results of the SQL query to an R object as a data frame, you can do this using the `output.var` option, e.g.,

````markdown
`r ''````{sql, connection=db, output.var="trials"}
SELECT * FROM trials
```
````

When the results of a SQL query are assigned to a data frame, no records will be printed within the document (if desired, you can manually print the data frame in a subsequent R chunk).

If you need to bind the values of R variables into SQL queries, you can do so by prefacing R variable references with a `?`. For example:

````markdown
`r ''````{r}
subjects = 10
```

`r ''````{sql, connection=db, output.var="trials"}
SELECT * FROM trials WHERE subjects >= ?subjects
```
````

If you have many SQL chunks, it may be helpful to set a default for the `connection` chunk option in the setup chunk, so that it is not necessary to specify the connection on each individual chunk. You can do this as follows:

````markdown
`r ''````{r setup}
library(DBI)
db = dbConnect(RSQLite::SQLite(), dbname = "sql.sqlite")
knitr::opts_chunk$set(connection = "db")
```
````

Note that the `connection` option should be a string naming the connection object (not the object itself). Once set, you can execute SQL chunks without specifying an explicit connection:

````markdown
`r ''````{sql}
SELECT * FROM trials
```
````

### Rcpp

The `Rcpp` engine enables compilation of C++\index{C++} into R functions via the **Rcpp** `sourceCpp()` function. For example:

````markdown
`r ''````{Rcpp}
#include <Rcpp.h>
using namespace Rcpp;

// [[Rcpp::export]]
NumericVector timesTwo(NumericVector x) {
  return x * 2;
}
```
````

Executing this chunk will compile the code and make the C++ function `timesTwo()` available to R.

You can cache the compilation of C++ code chunks using standard **knitr** caching, i.e., add the `cache = TRUE` option to the chunk:

````markdown
`r ''````{Rcpp, cache=TRUE}
#include <Rcpp.h>
using namespace Rcpp;

// [[Rcpp::export]]
NumericVector timesTwo(NumericVector x) {
  return x * 2;
}
```
````

In some cases, it is desirable to combine all of the `Rcpp` code chunks in a document into a single compilation unit. This is especially useful when you want to intersperse narrative between pieces of C++ code (e.g., for a tutorial or user guide). It also reduces total compilation time for the document (since there is only a single invocation of the C++ compiler rather than multiple).

To combine all Rcpp chunks into a single compilation unit, you use the `ref.label` chunk option along with the `knitr::all_rcpp_labels()` function to collect all of the `Rcpp` chunks in the document. Here is a simple example:

````markdown
All C++ code chunks will be combined to the chunk below:

`r ''````{Rcpp, ref.label=knitr::all_rcpp_labels(), include=FALSE}
```

First we include the header `Rcpp.h`:

`r ''````{Rcpp, eval=FALSE}
#include <Rcpp.h>
```

Then we define a function:

`r ''````{Rcpp, eval=FALSE}
// [[Rcpp::export]]
int timesTwo(int x) {
  return x * 2;
}
```
````

The two `Rcpp` chunks that include code will be collected and compiled together in the first `Rcpp` chunk via the `ref.label` chunk option. Note that we set the `eval = FALSE` option on the `Rcpp` chunks with code in them to prevent them from being compiled again.

### Stan

The `stan` engine enables embedding of the [Stan probabilistic programming language](http://mc-stan.org)\index{Stan} within R Markdown documents.

The Stan model within the code chunk is compiled into a `stanmodel` object, and is assigned to a variable with the name given by the `output.var` option. For example:

````markdown
`r ''````{stan, output.var="ex1"}
parameters {
  real y[2];
}
model {
  y[1] ~ normal(0, 1);
  y[2] ~ double_exponential(0, 2);
}
```

`r ''````{r}
library(rstan)
fit = sampling(ex1)
print(fit)
```
````

### JavaScript and CSS

If you are using an R Markdown format that targets HTML output (e.g., `html_document` and `ioslides_presentation`, etc.), you can include JavaScript\index{JavaScript} to be executed within the HTML page using the JavaScript engine named `js`.

For example, the following chunk uses jQuery (which is included in most R Markdown HTML formats) to change the color of the document title to red:

````markdown
`r ''````{js, echo=FALSE}
$('.title').css('color', 'red')
```
````

Similarly, you can embed CSS\index{CSS} rules in the output document. For example, the following code chunk turns text within the document body red:

````markdown
`r ''````{css, echo=FALSE}
body {
  color: red;
}
```
````

Without the chunk option `echo = FALSE`, the JavaScript/CSS code will be displayed verbatim in the output document, which is probably not what you want.

### Julia

The [Julia](https://julialang.org) language \index{Julia} is supported through the **JuliaCall** package [@R-JuliaCall]. Similar to the `python` engine, the `julia` engine runs all Julia code chunks in the same Julia session. Below is a minimal example:

````markdown
`r ''````{julia}
a = sqrt(2);  # the semicolon inhibits printing
```
````

### C and Fortran

For code chunks that use C\index{C language} or Fortran\index{Fortran}, **knitr** uses `R CMD SHLIB` to compile the code, and load the shared object (a `*.so` file on Unix or `*.dll` on Windows). Then you can use `.C()` / `.Fortran()` to call the C / Fortran functions, e.g.,

````markdown
`r ''````{c, test-c, results='hide'}
void square(double *x) {
  *x = *x * *x;
}
```

Test the `square()` function:

`r ''````{r}
.C('square', 9)
.C('square', 123)
```
````

You can find more examples on different language engines in the GitHub repository https://github.com/yihui/knitr-examples (look for filenames that contain the word "engine").

## Interactive documents

R Markdown documents can also generate interactive content. There are two types of interactive R Markdown documents: you can use the HTML Widgets framework, or the Shiny framework (or both). They will be described in more detail in Chapter \@ref(html-widgets) and Chapter \@ref(shiny-documents), respectively.

### HTML widgets {#intro-widgets}

The HTML Widgets\index{HTML widgets} framework is implemented in the R package **htmlwidgets** [@R-htmlwidgets], interfacing JavaScript libraries that create interactive applications, such as interactive graphics and tables. Several widget packages have been developed based on this framework, such as **DT** [@R-DT], **leaflet** [@R-leaflet], and **dygraphs** [@R-dygraphs]. Visit https://www.htmlwidgets.org to know more about widget packages as well as how to develop a widget package by yourself.

Figure \@ref(fig:leaflet) shows an interactive map created via the **leaflet** package, and the source document is below:

````markdown
`r xfun::file_string('examples/htmlwidgets.Rmd')`
````

```{r leaflet, echo=FALSE, fig.cap='An R Markdown document with a leaflet map widget.', out.width='100%'}
knitr::include_graphics('images/leaflet.png', dpi = NA)
```

Although HTML widgets are based on JavaScript, the syntax to create them in R is often pure R syntax.

If you include an HTML widget in a non-HTML output format, such as a PDF, **knitr** will try to embed a screenshot of the widget if you have installed the R package **webshot** [@R-webshot] and the PhantomJS package (via `webshot::install_phantomjs()`).

### Shiny documents {#intro-shiny}

The **shiny** package [@R-shiny] builds interactive web apps powered by R. To call Shiny\index{Shiny} code from an R Markdown document, add  `runtime: shiny` to the YAML metadata, like in this document:

````markdown
`r xfun::file_string('examples/shiny.Rmd')`
````

Figure \@ref(fig:shiny) shows the output, where you can see a dropdown menu that allows you to choose the number of bins in the histogram.

```{r shiny, echo=FALSE, fig.cap='An R Markdown document with a Shiny widget.', out.width='100%'}
knitr::include_graphics('images/shiny.png', dpi = NA)
```

You may use Shiny to run any R code that you like in response to user actions. Since web browsers cannot execute R code, Shiny interactions occur on the server side and rely on a live R session. By comparison, HTML widgets do not require a live R session to support them, because the interactivity comes from the client side (via JavaScript in the web browser).

You can learn more about Shiny at https://shiny.rstudio.com.

HTML widgets and Shiny elements rely on HTML and JavaScript. They will work in any R Markdown format that is viewed in a web browser, such as HTML documents, dashboards, and HTML5 presentations.

<!--chapter:end:02-basics.Rmd-->

# (PART) Output Formats {-}

# Documents

The very original version of Markdown was invented mainly to write HTML content more easily. For example, you can write a bullet with `- text` instead of the verbose HTML code `<ul><li>text</li></ul>`, or a quote with `> text` instead of `<blockquote>text</blockquote>`.

The syntax of Markdown has been greatly extended by Pandoc. What is more, Pandoc makes it possible to convert a Markdown document to a large variety of output formats. In this chapter, we will introduce the features of various document output formats. In the next two chapters, we will document the presentation formats and other R Markdown extensions, respectively.

## HTML document

As we just mentioned before, Markdown was originally designed for HTML output, so it may not be surprising that the HTML format\index{HTML format} has the richest features among all output formats. We recommend that you read this full section before you learn other output formats, because other formats have several features in common with the HTML document format, and we will not repeat these features in the corresponding sections.

To create an HTML document from R Markdown, you specify the `html_document` output format in the YAML metadata of your document:

```yaml
---
title: Habits
author: John Doe
date: March 22, 2005
output: html_document
---
```

### Table of contents

You can add a table of contents (TOC) using the `toc` option and specify the depth of headers that it applies to using the `toc_depth` option. For example:

```yaml
---
title: "Habits"
output:
  html_document:
    toc: true
    toc_depth: 2
---
```

If the table of contents depth is not explicitly specified, it defaults to 3 (meaning that all level 1, 2, and 3 headers will be included in the table of contents).

#### Floating TOC

You can specify the `toc_float` option to float the table of contents to the left of the main document content. The floating table of contents will always be visible even when the document is scrolled. For example:

```yaml
---
title: "Habits"
output:
  html_document:
    toc: true
    toc_float: true
---
```

You may optionally specify a list of options for the `toc_float` parameter which control its behavior. These options include:

- `collapsed` (defaults to `TRUE`) controls whether the TOC appears with only the top-level (e.g., H2) headers. If collapsed initially, the TOC is automatically expanded inline when necessary.

- `smooth_scroll` (defaults to `TRUE`) controls whether page scrolls are animated when TOC items are navigated to via mouse clicks.

For example:

```yaml
---
title: "Habits"
output:
  html_document:
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: false
---
```

### Section numbering

You can add section numbering to headers using the `number_sections` option:

```yaml
---
title: "Habits"
output:
  html_document:
    toc: true
    number_sections: true
---
```

Note that if you do choose to use the `number_sections` option, you will likely also want to use `#` (H1) headers in your document as `##` (H2) headers will include a decimal point, because without H1 headers, you H2 headers will be numbered with `0.1`, `0.2`, and so on.

### Tabbed sections

You can organize content using tabs by applying the `.tabset` class attribute to headers within a document. This will cause all sub-headers of the header with the `.tabset` attribute to appear within tabs rather than as standalone sections. For example:

```markdown
## Quarterly Results {.tabset}

### By Product

(tab content)

### By Region

(tab content)
```

You can also specify two additional attributes to control the appearance and behavior of the tabs. The `.tabset-fade` attribute causes the tabs to fade in and out when switching between tabs. The `.tabset-pills` attribute causes the visual appearance of the tabs to be "pill" (see Figure \@ref(fig:tabset)) rather than traditional tabs. For example:

```markdown
## Quarterly Results {.tabset .tabset-fade .tabset-pills}
```

```{r tabset, echo=FALSE, fig.cap='Traditional tabs and pill tabs on an HTML page.', out.width='50%', fig.align='center'}
knitr::include_graphics('images/tabset.png', dpi = NA)
```

### Appearance and style

There are several options that control the appearance of HTML documents:

- `theme` specifies the Bootstrap theme to use for the page (themes are drawn from the [Bootswatch](https://bootswatch.com/3/) theme library). Valid themes include `r knitr::combine_words(rmarkdown:::themes())`. Pass `null` for no theme (in this case you can use the `css` parameter to add your own styles).

- `highlight` specifies the syntax highlighting style. Supported styles include `r knitr::combine_words(rmarkdown:::html_highlighters(), before='\x60')`. Pass `null` to prevent syntax highlighting.

- `smart` indicates whether to produce typographically correct output, converting straight quotes to curly quotes, `---` to em-dashes, `--` to en-dashes, and `...` to ellipses. Note that `smart` is enabled by default.

For example:

```yaml
---
title: "Habits"
output:
  html_document:
    theme: united
    highlight: tango
---
```

#### Custom CSS

You can add your own CSS\index{CSS} to an HTML document using the `css` option:

```yaml
---
title: "Habits"
output:
  html_document:
    css: styles.css
---
```

If you want to provide all of the styles for the document from your own CSS you set the `theme` (and potentially `highlight`) to `null`:

```yaml
---
title: "Habits"
output:
  html_document:
    theme: null
    highlight: null
    css: styles.css
---
```

You can also target specific sections of documents with custom CSS by adding ids or classes to section headers within your document. For example the following section header:

```markdown
## Next Steps {#nextsteps .emphasized}
```

Would enable you to apply CSS to all of its content using either of the following CSS selectors:

```css
#nextsteps {
   color: blue;
}

.emphasized {
   font-size: 1.2em;
}
```

### Figure options

There are a number of options that affect the output of figures within HTML documents:

- `fig_width` and  `fig_height` can be used to control the default figure width and height (7x5 is used by default).

- `fig_retina` specifies the scaling to perform for retina displays (defaults to 2, which currently works for all widely used retina displays). Set to `null` to prevent retina scaling.

- `fig_caption` controls whether figures are rendered with captions.

- `dev` controls the graphics device used to render figures (defaults to `png`).

For example:

```yaml
---
title: "Habits"
output:
  html_document:
    fig_width: 7
    fig_height: 6
    fig_caption: true
---
```

### Data frame printing

You can enhance the default display of data frames via the `df_print` option. Valid values are shown in Table \@ref(tab:df-print).

Table: (\#tab:df-print) The possible values of the `df_print` option for the `html_document` format.

| Option  | Description  |
|------------|-------------------------------------------|
| default  | Call the `print.data.frame` generic method |
| kable  | Use the `knitr::kable` function |
| tibble  | Use the `tibble::print.tbl_df` function |
| paged  |  Use `rmarkdown::paged_table` to create a pageable table |
| A custom function | Use the function to create the table |

#### Paged printing

When the `df_print` option is set to `paged`, tables are printed as HTML tables with support for pagination over rows and columns. For instance (see Figure \@ref(fig:paged)):

````markdown
---
title: "Motor Trend Car Road Tests"
output:
  html_document:
    df_print: paged
---

`r ''````{r}
mtcars
```
````

```{r paged, echo=FALSE, fig.cap='A paged table in the HTML output document.', out.width='100%'}
knitr::include_graphics('images/paged.png', dpi = NA)
```

Table \@ref(tab:paged) shows the available options for paged tables.

Table: (\#tab:paged) The options for paged HTML tables.

| Option          | Description                                           |
|-----------------|-------------------------------------------------------|
| max.print       | The number of rows to print.                          |
| rows.print      | The number of rows to display.                        |
| cols.print      | The number of columns to display.                     |
| cols.min.print  | The minimum number of columns to display.             |
| pages.print     | The number of pages to display under page navigation. |
| paged.print     | When set to `FALSE` turns off paged tables.           |
| rownames.print  | When set to `FALSE` turns off row names.              |

These options are specified in each chunk like below:

````markdown
`r ''````{r cols.print=3, rows.print=3}
mtcars
```
````

#### Custom function {#custom-fun-dfprint}

The `df_print` option can also take an arbitrary function to create the table in the output document. This function must output in the correct format according to the output used.

For example, 

```r
rmarkdown::html_document(df_print = knitr::kable)
```

is the equivalent to using the method `"kable"`

```r
rmarkdown::html_document(df_print = "kable")
```

To use a custom function in `df_print` within the YAML header, the tag `!expr` must be used so the R expression after it will be evaluated. See the `eval.expr` argument on the help page `?yaml::yaml.load` for details.

````markdown
---
title: "Motor Trend Car Road Tests"
output:
  html_document:
    df_print: !expr pander::pander 
---

`r ''````{r}
mtcars
```
````

### Code folding

When the **knitr** chunk option `echo = TRUE` is specified (the default behavior), the R source code within chunks is included within the rendered document. In some cases, it may be appropriate to exclude code entirely (`echo = FALSE`) but in other cases you might want the code to be available but not visible by default.

The `code_folding: hide` option enables you to include R code but have it hidden by default. Users can then choose to show hidden R code chunks either individually or document wide. For example:

````markdown
---
title: "Habits"
output:
  html_document:
    code_folding: hide
---
````

You can specify `code_folding: show` to still show all R code by default but then allow users to hide the code if they wish.

### MathJax equations

By default, [MathJax](https://www.mathjax.org)\index{MathJax} scripts are included in HTML documents for rendering LaTeX and MathML equations. You can use the `mathjax` option to control how MathJax is included:

- Specify `"default"` to use an HTTPS URL from a CDN host (currently provided by RStudio).

- Specify `"local"` to use a local version of MathJax (which is copied into the output directory). Note that when using `"local"` you also need to set the `self_contained` option to `false`.

- Specify an alternate URL to load MathJax from another location.

- Specify `null` to exclude MathJax entirely.

For example, to use a local copy of MathJax:

```yaml
---
title: "Habits"
output:
  html_document:
    mathjax: local
    self_contained: false
---
```

To use a self-hosted copy of MathJax:

```yaml
---
title: "Habits"
output:
  html_document:
    mathjax: "http://example.com/MathJax.js"
---
```

To exclude MathJax entirely:

```yaml
---
title: "Habits"
output:
  html_document:
    mathjax: null
---
```

### Document dependencies

By default, R Markdown produces standalone HTML files with no external dependencies, using `data:` URIs to incorporate the contents of linked scripts, stylesheets, images, and videos. This means you can share or publish the file just like you share Office documents or PDFs. If you would rather keep dependencies in external files, you can specify `self_contained: false`. For example:

```yaml
---
title: "Habits"
output:
  html_document:
    self_contained: false
---
```

Note that even for self-contained documents, MathJax is still loaded externally (this is necessary because of its big size). If you want to serve MathJax locally, you should specify `mathjax: local` and `self_contained: false`.

One common reason to keep dependencies external is for serving R Markdown documents from a website (external dependencies can be cached separately by browsers, leading to faster page load times). In the case of serving multiple R Markdown documents you may also want to consolidate dependent library files (e.g. Bootstrap, and MathJax, etc.) into a single directory shared by multiple documents. You can use the `lib_dir` option to do this. For example:

```yaml
---
title: "Habits"
output:
  html_document:
    self_contained: false
    lib_dir: libs
---
```

### Advanced customization

#### Keeping Markdown

When **knitr** processes an R Markdown input file, it creates a Markdown (`*.md`) file that is subsequently transformed into HTML by Pandoc. If you want to keep a copy of the Markdown file after rendering, you can do so using the `keep_md` option:

```yaml
---
title: "Habits"
output:
  html_document:
    keep_md: true
---
```

#### Includes

You can do more advanced customization of output by including additional HTML content or by replacing the core Pandoc template entirely. To include content in the document header or before/after the document body, you use the `includes` option as follows:

```markdown
---
title: "Habits"
output:
  html_document:
    includes:
      in_header: header.html
      before_body: doc_prefix.html
      after_body: doc_suffix.html
---
```

#### Custom templates

You can also replace the underlying Pandoc template\index{Pandoc template} using the `template` option:

```yaml
---
title: "Habits"
output:
  html_document:
    template: quarterly_report.html
---
```

Consult the documentation on [Pandoc templates](http://pandoc.org/MANUAL.html#templates) for additional details on templates. You can also study the [default HTML template `default.html5`](https://github.com/jgm/pandoc-templates/) as an example.

#### Markdown extensions {#markdown-extensions}

By default, R Markdown is defined as all Pandoc Markdown extensions with the following tweaks for backward compatibility with the old **markdown** package [@R-markdown]:

```
+autolink_bare_uris
+tex_math_single_backslash
```

You can enable or disable Markdown extensions using the `md_extensions` option (you preface an option with `-` to disable and `+` to enable it). For example:

```yaml
---
title: "Habits"
output:
  html_document:
    md_extensions: -autolink_bare_uris+hard_line_breaks
---
```

The above would disable the `autolink_bare_uris` extension, and enable the `hard_line_breaks` extension.

For more on available markdown extensions see the [Pandoc Markdown specification](http://pandoc.org/MANUAL.html#pandocs-markdown).

#### Pandoc arguments {#pandoc-arguments}

If there are Pandoc features that you want to use but lack equivalents in the YAML options described above, you can still use them by passing custom `pandoc_args`. For example:

```yaml
---
title: "Habits"
output:
  html_document:
    pandoc_args: [
      "--title-prefix", "Foo",
      "--id-prefix", "Bar"
    ]
---
```

Documentation on all available pandoc arguments can be found in the [Pandoc User Guide](http://pandoc.org/MANUAL.html#options).

### Shared options {#shared-options}

If you want to specify a set of default options to be shared by multiple documents within a directory, you can include a file named `_output.yml` within the directory. Note that no YAML delimiters (`---`) or the enclosing `output` field are used in this file. For example:

```yaml
html_document:
  self_contained: false
  theme: united
  highlight: textmate
```

It should not be written as:

```yaml
---
output:
  html_document:
    self_contained: false
    theme: united
    highlight: textmate
---
```

All documents located in the same directory as `_output.yml` will inherit its options. Options defined explicitly within documents will override those specified in the shared options file.

### HTML fragments

If want to create an HTML fragment rather than a full HTML document you can use the `html_fragment` format. For example:

```yaml
---
output: html_fragment
---
```

Note that HTML fragments are not complete HTML documents. They do not contain the standard header content that HTML documents do (they only contain content in the `<body>` tags of normal HTML documents). They are intended for inclusion within other web pages or content management systems (like blogs). As such, they do not support features like themes or code highlighting (it is expected that the environment they are ultimately published within handles these things).

## Notebook

An R Notebook is an R Markdown document with chunks that can be executed independently and interactively, with output visible immediately beneath the input. See Figure \@ref(fig:notebook-demo) for an example.

```{r notebook-demo, echo=FALSE, fig.cap='An R Notebook example.', out.width='100%'}
knitr::include_graphics('images/notebook-demo.png', dpi = NA)
```

R Notebooks are an implementation of [Literate Programming](https://en.wikipedia.org/wiki/Literate_programming) that allows for direct interaction with R while producing a reproducible document with publication-quality output.

Any R Markdown document can be used as a notebook, and all R Notebooks can be rendered to other R Markdown document types. A notebook can therefore be thought of as a special execution mode for R Markdown documents. The immediacy of notebook mode makes it a good choice while authoring the R Markdown document and iterating on code. When you are ready to publish the document, you can share the notebook directly, or render it to a publication format with the `Knit` button.

### Using Notebooks

#### Creating a Notebook

You can create a new notebook in RStudio with the menu command `File -> New File -> R Notebook`, or by using the `html_notebook` output type in your document's YAML metadata.

```yaml
---
title: "My Notebook"
output: html_notebook
---
```

By default, RStudio enables inline output (Notebook mode) on all R Markdown documents, so you can interact with any R Markdown document as though it were a notebook. If you have a document with which you prefer to use the traditional console method of interaction, you can disable notebook mode by clicking the gear button in the editor toolbar, and choosing `Chunk Output in Console` (Figure \@ref(fig:notebook-console)).

```{r notebook-console, echo=FALSE, fig.cap='Send the R code chunk output to the console.', out.width='80%', fig.align='center'}
knitr::include_graphics('images/notebook-console.png', dpi = NA)
```

If you prefer to use the console by default for *all* your R Markdown documents (restoring the behavior in previous versions of RStudio), you can make `Chunk Output in Console` the default: `Tools -> Options -> R Markdown -> Show output inline for all R Markdown documents`.

#### Inserting chunks

Notebook chunks can be inserted quickly using the keyboard shortcut `Ctrl + Alt + I` (macOS: `Cmd + Option + I`), or via the `Insert` menu in the editor toolbar.

Because all of a chunk's output appears beneath the chunk (not alongside the statement which emitted the output, as it does in the rendered R Markdown output), it is often helpful to split chunks that produce multiple outputs into two or more chunks which each produce only one output. To do this, select the code to split into a new chunk (Figure \@ref(fig:notebook-split-before)), and use the same keyboard shortcut for inserting a new code chunk (Figure \@ref(fig:notebook-split-after)).

```{r notebook-split-before, echo=FALSE, fig.cap='Select the code to split into a new chunk.', out.width='90%', fig.align='center'}
knitr::include_graphics('images/notebook-split-before.png', dpi = NA)
```

```{r notebook-split-after, echo=FALSE, fig.cap='Insert a new chunk from the code selected before.', out.width='90%', fig.align='center'}
knitr::include_graphics('images/notebook-split-after.png', dpi = NA)
```

#### Executing code

Code in the notebook is executed with the same gestures you would use to execute code in an R Markdown document:

1. Use the green triangle button on the toolbar of a code chunk that has the tooltip "Run Current Chunk", or `Ctrl + Shift + Enter` (macOS: `Cmd + Shift + Enter`) to run the current chunk.

1. Press `Ctrl + Enter` (macOS: `Cmd + Enter`) to run just the current statement. Running a single statement is much like running an entire chunk consisting only of that statement.

1. There are other ways to run a batch of chunks if you click the menu `Run` on the editor toolbar, such as `Run All`, `Run All Chunks Above`, and `Run All Chunks Below`.

The primary difference is that when executing chunks in an R Markdown document, all the code is sent to the console at once, but in a notebook, only one line at a time is sent. This allows execution to stop if a line raises an error.

There is also a `Restart R and Run All Chunks` item in the `Run` menu on the editor toolbar, which gives you a fresh R session prior to running all the chunks. This is similar to the `Knit` button, which launches a separate R session to compile the document.

When you execute code in a notebook, an indicator will appear in the gutter to show you execution progress (Figure \@ref(fig:notebook-longrunning)). Lines of code that have been sent to R are marked with dark green; lines that have not yet been sent to R are marked with light green. If at least one chunk is waiting to be executed, you will see a progress meter appear in the editor's status bar, indicating the number of chunks remaining to be executed. You can click on this meter at any time to jump to the currently executing chunk. When a chunk is waiting to execute, the `Run` button in its toolbar will change to a "queued" icon. If you do not want the chunk to run, you can click on the icon to remove it from the execution queue.

```{r notebook-longrunning, echo=FALSE, fig.cap='The indicator in the gutter to show the execution progress of a code chunk in the notebook.', out.width='100%'}
knitr::include_graphics('images/notebook-longrunning.png', dpi = NA)
```

In general, when you execute code in a notebook chunk, it will do exactly the same thing as it would if that same code were typed into the console. There are however a few differences:

- **Output**: The most obvious difference is that most forms of output produced from a notebook chunk are shown in the chunk output rather than, for example, the RStudio Viewer or the Plots pane. Console output (including warnings and messages) appears both at the console *and* in the chunk output.

- **Working directory**: The current working directory inside a notebook chunk is always the directory containing the notebook `.Rmd` file. This makes it easier to use relative paths inside notebook chunks, and also matches the behavior when knitting, making it easier to write code that works identically both interactively and in a standalone render.

    You'll get a warning if you try to change the working directory inside a notebook chunk, and the directory will revert back to the notebook's directory once the chunk is finished executing. You can suppress this warning by using the `warnings = FALSE` chunk option.

    If it is necessary to execute notebook chunks in a different directory, you can change the working directory for **all** your chunks by using the **knitr** `root.dir` option. For instance, to execute all notebook chunks in the grandparent folder of the notebook:

    ```r
    knitr::opts_knit$set(root.dir = normalizePath(".."))
    ```

    This option is only effective when used inside the setup chunk. Also note that, as in **knitr**, the `root.dir` chunk option applies only to chunks; relative paths in Markdown are still relative to the notebook's parent folder.

- **Warnings**: Inside a notebook chunk, warnings are always displayed immediately rather than being held until the end, as in `options(warn = 1)`.

- **Plots**: Plots emitted from a chunk are rendered to match the width of the editor at the time the chunk was executed. The height of the plot is determined by the [golden ratio](https://en.wikipedia.org/wiki/Golden_ratio). The plot's display list is saved, too, and the plot is re-rendered to match the editor's width when the editor is resized.

    You can use the `fig.width`, `fig.height`, and `fig.asp` chunk options to manually specify the size of rendered plots in the notebook; you can also use `knitr::opts_chunk$set(fig.width = ..., fig.height = ...)` in the setup chunk to to set a default rendered size. Note, however, specifying a chunk size manually suppresses the generation of the display list, so plots with manually specified sizes will be resized using simple image scaling when the notebook editor is resized.

To execute an inline R expression in the notebook, put your cursor inside the chunk and press `Ctrl + Enter` (macOS: `Cmd + Enter`). As in the execution of ordinary chunks, the content of the expression will be sent to the R console for evaluation. The results will appear in a small pop-up window next to the code (Figure \@ref(fig:notebook-inline-output)).

```{r notebook-inline-output, echo=FALSE, fig.cap='Output from an inline R expression in the notebook.', out.width='40%', fig.align='center'}
knitr::include_graphics('images/notebook-inline-output.png', dpi = NA)
```

In notebooks, inline R expressions can only produce text (not figures or other kinds of output). It is also important that inline R expressions executes quickly and do not have side-effects, as they are executed whenever you save the notebook.

Notebooks are typically self-contained. However, in some situations, it is preferable to re-use code from an R script as a notebook chunk, as in **knitr**'s [code externalization](https://yihui.name/knitr/demo/externalization/). This can be done by using `knitr::read_chunk()` in your notebook's setup chunk, along with a special `## ---- chunkname` annotation in the R file from which you intend to read code. Here is a minimal example with two files:

**example.Rmd**

````markdown
`r ''````{r setup}
knitr::read_chunk("example.R")
```

```{r chunk}
```
````

**example.R**

```r
## ---- chunk
1 + 1
```

When you execute the empty chunk in the notebook `example.Rmd`, code from the external file `example.R` will be inserted, and the results displayed inline, as though the chunk contained that code (Figure \@ref(fig:notebook-external-code)).

```{r notebook-external-code, echo=FALSE, fig.cap='Execute a code chunk read from an external R script.', out.width='70%', fig.align='center'}
knitr::include_graphics('images/notebook-external-code.png', dpi = NA)
```

#### Chunk output

When code is executed in the notebook, its output appears beneath the code chunk that produced it. You can clear an individual chunk's output by clicking the `X` button in the upper right corner of the output, or collapse it by clicking the chevron.

It is also possible to clear or collapse all of the output in the document at once using the `Collapse All Output` and `Clear All Output` menu items available on the gear menu in the editor toolbar (Figure \@ref(fig:notebook-console)).

If you want to fully reset the state of the notebook, the item `Restart R and Clear Output` on the `Run` menu on the editor toolbar will do the job.

Ordinary R Markdown documents are "knitted", but notebooks are "previewed". While the notebook preview looks similar to a rendered R Markdown document, the notebook preview _does not execute any of your R code chunks_. It simply shows you a rendered copy of the Markdown output of your document along with the most recent chunk output. This preview is generated automatically whenever you save the notebook (whether you are viewing it in RStudio or not); see the section beneath on the `*.nb.html` file for details.

When `html_notebook` is the topmost (default) format in your YAML metadata, you will see a `Preview` button in the editor toolbar. Clicking it will show you the notebook preview (Figure \@ref(fig:notebook-preview)).

```{r notebook-preview, echo=FALSE, fig.cap='Preview a notebook.', out.width='100%'}
knitr::include_graphics('images/notebook-preview.png', dpi = NA)
```

If you have configured R Markdown previewing to use the Viewer pane (as illustrated in Figure \@ref(fig:notebook-preview)), the preview will be automatically updated whenever you save your notebook.

When an error occurs while a notebook chunk is executing (Figure \@ref(fig:notebook-error)):

```{r notebook-error, echo=FALSE, fig.cap='Errors in a notebook.', out.width='90%', fig.align='center'}
knitr::include_graphics('images/notebook-error.png', dpi = NA)
```

1. Execution will stop; the remaining lines of that chunk (and any chunks that have not yet been run) will not be executed.

1. The editor will scroll to the error.

1. The line of code that caused the error will have a red indicator in the editor's gutter.

If you want your notebook to keep running after an error, you can suppress the first two behaviors by specifying `error = TRUE` in the chunk options.

In most cases, it should not be necessary to have the console open while using the notebook, as you can see all of the console output in the notebook itself. To preserve vertical space, the console will be automatically collapsed when you open a notebook or run a chunk in the notebook.

If you prefer not to have the console hidden when chunks are executed, uncheck the option from the menu `Tools -> Global Options -> R Markdown -> Hide console automatically when executing notebook chunks`.

### Saving and sharing

#### Notebook file

When a notebook `*.Rmd` file is saved, a `*.nb.html` file is created alongside it. This file is a self-contained HTML file which contains both a rendered copy of the notebook with all current chunk outputs (suitable for display on a website) and a copy of the `*.Rmd` file itself.

You can view the `*.nb.html` file in any ordinary web browser. It can also be opened in RStudio; when you open there (e.g., using `File -> Open File`), RStudio will do the following:

1. Extract the bundled `*.Rmd` file, and place it alongside the `*.nb.html` file.

2. Open the `*.Rmd` file in a new RStudio editor tab.

3. Extract the chunk outputs from the `*.nb.html` file, and place them appropriately in the editor.

Note that the `*.nb.html` file is only created for R Markdown documents that are notebooks (i.e., at least one of their output formats is `html_notebook`). It is possible to have an R Markdown document that includes inline chunk output beneath code chunks, but does not produce an `*.nb.html` file, when `html_notebook` is not specified as an output format for the R Markdown document.

#### Output storage

The document's chunk outputs are also stored in an internal RStudio folder beneath the project's `.Rproj.user` folder. If you work with a notebook but do not have a project open, the outputs are stored in the RStudio state folder in your home directory (the location of this folder varies between the [desktop](https://support.rstudio.com/hc/en-us/articles/200534577) and the [server](https://support.rstudio.com/hc/en-us/articles/218730228)).

#### Version control

One of the major advantages of R Notebooks compared to other notebook systems is that they are plain-text files and therefore work well with version control. We recommend checking in both the `*.Rmd` and `*.nb.html` files into version control, so that both your source code and output are available to collaborators. However, you can choose to include only the `*.Rmd` file (with a `.gitignore` that excludes `*.nb.html`) if you want each collaborator to work with their own private copies of the output.

### Notebook format

While RStudio provides a set of integrated tools for authoring R Notebooks, the notebook file format itself is decoupled from RStudio. The **rmarkdown** package provides several functions that can be used to read and write R Notebooks outside of RStudio.

In this section, we describe the internals of the notebook format. It is primarily intended for front-end applications using or embedding R, or other users who are interested in reading and writing documents using the R Notebook format. We recommend that beginners skip this section when reading this book or using notebooks for the first time.

R Notebooks are HTML documents with data written and encoded in such a way that:

1. The source Rmd document can be recovered, and

2. Chunk outputs can be recovered.

To generate an R Notebook, you can use `rmarkdown::render()` and specify the `html_notebook` output format in your document's YAML metadata. Documents rendered in this form will be generated with the `.nb.html` file extension, to indicate that they are HTML notebooks.

To ensure chunk outputs can be recovered, the elements of the R Markdown document are enclosed with HTML comments, providing more information on the output. For example, chunk output might be serialized in the form:

```html
<!-- rnb-chunk-begin -->
<!-- rnb-output-begin -->
<pre><code>Hello, World!</code></pre>
<!-- rnb-output-end -->
<!-- rnb-chunk-end -->
```

Because R Notebooks are just HTML documents, they can be opened and viewed in any web browser; in addition, hosting environments can be configured to recover and open the source Rmd document, and also recover and display chunk outputs as appropriate.

#### Generating R Notebooks with custom output

It is possible to render an HTML notebook with custom chunk outputs inserted in lieu of the result that would be generated by evaluating the associated R code. This can be useful for front-end editors that show the output of chunk execution inline, or for conversion programs from other notebook formats where output is already available from the source format. To facilitate this, one can provide a custom "output source" to `rmarkdown::render()`. Let's investigate with a simple example:

```{r comment='', class.output='markdown'}
rmd_stub = "examples/r-notebook-stub.Rmd"
cat(readLines(rmd_stub), sep = "\n")
```

Let's try to render this document with a custom output source, so that we can inject custom output for the single chunk within the document. The output source function will accept:

- `code`: The code within the current chunk.

- `context`: An environment containing active chunk options and other chunk information.

- `...`: Optional arguments reserved for future expansion.

In particular, the `context` elements `label` and `chunk.index` can be used to help identify which chunk is currently being rendered.

```{r tidy=FALSE}
output_source = function(code, context, ...) {
  logo = file.path(R.home("doc"), "html", "logo.jpg")
  if (context$label == "chunk-one") list(
    rmarkdown::html_notebook_output_code("# R Code"),
    paste("Custom output for chunk:", context$chunk.index),
    rmarkdown::html_notebook_output_code("# R Logo"),
    rmarkdown::html_notebook_output_img(logo)
  )
}
```

We can pass our `output_source` along as part of the `output_options` list to `rmarkdown::render()`.

```{r tidy=FALSE}
output_file = rmarkdown::render(
  rmd_stub,
  output_options = list(output_source = output_source),
  quiet = TRUE
)
```

We have now generated an R Notebook. Open [this document](https://rmarkdown.rstudio.com/notebook/r-notebook-stub.nb.html) in a web browser, and it will show that the `output_source` function has effectively side-stepped evaluation of code within that chunk, and instead returned the injected result.

#### Implementing output sources

In general, you can provide regular R output in your output source function, but **rmarkdown** also provides a number of endpoints for insertion of custom HTML content. These are documented within `?html_notebook_output`.

Using these functions ensures that you produce an R Notebook that can be opened in R frontends (e.g., RStudio).

#### Parsing R Notebooks

The `rmarkdown::parse_html_notebook()` function provides an interface for recovering and parsing an HTML notebook.

```{r comment=''}
parsed = rmarkdown::parse_html_notebook(output_file)
str(parsed, width = 60, strict.width = 'wrap')
```

This interface can be used to recover the original Rmd source, and also (with some more effort from the front-end) the ability to recover chunk outputs from the document itself.

```{r, include=FALSE}
rm(parsed)
```

## PDF document

To create a PDF document from R Markdown, you specify the `pdf_document` output format in the YAML metadata:

```yaml
---
title: "Habits"
author: John Doe
date: March 22, 2005
output: pdf_document
---
```

Within R Markdown documents that generate PDF output, you can use raw LaTeX\index{LaTeX}, and even define LaTeX macros. See Pandoc's documentation on the [raw_tex extension](http://pandoc.org/MANUAL.html#extension-raw_tex) for details.

Note that PDF output (including Beamer slides) requires an installation of LaTeX (see Chapter \@ref(installation)).

### Table of contents

You can add a table of contents using the `toc` option and specify the depth of headers that it applies to using the `toc_depth` option. For example:

```yaml
---
title: "Habits"
output:
  pdf_document:
    toc: true
    toc_depth: 2
---
```

If the TOC depth is not explicitly specified, it defaults to 2 (meaning that all level 1 and 2 headers will be included in the TOC), while it defaults to 3 in `html_document`.

You can add section numbering to headers using the `number_sections` option:

```yaml
---
title: "Habits"
output:
  pdf_document:
    toc: true
    number_sections: true
---
```

If you are familiar with LaTeX, `number_sections: true` means `\section{}`, and `number_sections: false` means `\section*{}` for sections in LaTeX (it also applies to other levels of "sections" such as `\chapter{}`, and `\subsection{}`).

### Figure options

There are a number of options that affect the output of figures within PDF documents:

- `fig_width` and `fig_height` can be used to control the default figure width and height (6.5x4.5 is used by default).

- `fig_crop` controls whether the `pdfcrop` utility, if available in your system, is automatically applied to PDF figures (this is `true` by default).

    - If you are using [TinyTeX](https://yihui.name/tinytex/) as your LaTeX distribution, we recommend that you run `tinytex::tlmgr_install("pdfcrop")` to install the LaTeX package `pdfcrop`. You also have to make sure the system package [`ghostscript`](https://www.ghostscript.com) is available in your system for `pdfcrop` to work. For macOS users who have installed Homebrew, `ghostscript` can be installed via `brew install ghostscript`.

    - If your graphics device is `postscript`, we recommend that you disable this feature (see more info in the **knitr** issue [#1365](https://github.com/yihui/knitr/issues/1365)).

- `fig_caption` controls whether figures are rendered with captions (this is `true` by default).

- `dev` controls the graphics device used to render figures (defaults to `pdf`).

For example:

```yaml
---
title: "Habits"
output:
  pdf_document:
    fig_width: 7
    fig_height: 6
    fig_caption: true
---
```

### Data frame printing

You can enhance the default display of data frames via the `df_print` option. Valid values are presented in Table \@ref(tab:df-print-pdf).

Table: (\#tab:df-print-pdf) The possible values of the `df_print` option for the `pdf_document` format.

| Option  | Description  |
|------------|-------------------------------------------|
| default  | Call the `print.data.frame` generic method |
| kable  | Use the `knitr::kable()` function |
| tibble  | Use the `tibble::print.tbl_df()` function |
| A custom function | Use the function to create the table. See \@ref(custom-fun-dfprint) |

For example:

```yaml
---
title: "Habits"
output:
  pdf_document:
    df_print: kable
---
```

### Syntax highlighting

The `highlight` option specifies the syntax highlighting style. Its usage in `pdf_document` is the same as `html_document` (Section \@ref(appearance-and-style)). For example:

```yaml
---
title: "Habits"
output:
  pdf_document:
    highlight: tango
---
```

### LaTeX options

Many aspects of the LaTeX template used to create PDF documents can be customized using _top-level_ YAML metadata (note that these options do not appear underneath the `output` section, but rather appear at the top level along with `title`, `author`, and so on). For example:

```yaml
---
title: "Crop Analysis Q3 2013"
output: pdf_document
fontsize: 11pt
geometry: margin=1in
---
```

A few available metadata variables are displayed in Table \@ref(tab:latex-vars) (consult the Pandoc manual for [the full list](https://pandoc.org/MANUAL.html#variables-for-latex)):

Table: (\#tab:latex-vars) Available top-level YAML metadata variables for LaTeX output.

Variable|Description
------------------------|--------------------------------------------------------------------
lang|Document language code
fontsize|Font size (e.g., `10pt`, `11pt`, or `12pt`)
documentclass|LaTeX document class (e.g., `article`)
classoption|Options for documentclass (e.g., `oneside`)
geometry|Options for geometry class (e.g., `margin=1in`)
mainfont, sansfont, monofont, mathfont|Document fonts (works only with `xelatex` and `lualatex`)
linkcolor, urlcolor, citecolor|Color for internal, external, and citation links

### LaTeX packages for citations

By default, citations\index{citation} are processed through `pandoc-citeproc`, which works for all output formats. For PDF output, sometimes it is better to use LaTeX packages to process citations, such as `natbib` or `biblatex`. To use one of these packages, just set the option `citation_package` to be `natbib` or `biblatex`, e.g.

```yaml
---
output:
  pdf_document:
    citation_package: natbib
---
```

### Advanced customization

#### LaTeX engine

By default, PDF documents are rendered using `pdflatex`. You can specify an alternate engine using the `latex_engine` option. Available engines are `pdflatex`, `xelatex`, and `lualatex`. For example:

```yaml
---
title: "Habits"
output:
  pdf_document:
    latex_engine: xelatex
---
```

The main reasons you may want to use `xelatex` or `lualatex` are: (1) They support Unicode better; (2) It is easier to make use of system fonts. See some posts on Stack Overflow for more detailed explanations, e.g., https://tex.stackexchange.com/q/3393/9128 and https://tex.stackexchange.com/q/36/9128.

#### Keeping intermediate TeX

R Markdown documents are converted to PDF by first converting to a TeX file and then calling the LaTeX engine to convert to PDF. By default, this TeX file is removed, however if you want to keep it (e.g., for an article submission), you can specify the `keep_tex` option. For example:

```yaml
---
title: "Habits"
output:
  pdf_document:
    keep_tex: true
---
```

#### Includes

You can do more advanced customization of PDF output by including additional LaTeX directives and/or content or by replacing the core Pandoc template entirely. To include content in the document header or before/after the document body, you use the `includes` option as follows:

```yaml
---
title: "Habits"
output:
  pdf_document:
    includes:
      in_header: preamble.tex
      before_body: doc-prefix.tex
      after_body: doc-suffix.tex
---
```

#### Custom templates

You can also replace the underlying Pandoc template using the `template` option:

```yaml
---
title: "Habits"
output:
  pdf_document:
    template: quarterly-report.tex
---
```

Consult the documentation on [Pandoc templates](https://pandoc.org/README.html#templates) for additional details on templates. You can also study the [default LaTeX template](https://github.com/jgm/pandoc-templates/blob/master/default.latex) as an example.

### Other features

Similar to HTML documents, you can enable or disable certain Markdown extensions for generating PDF documents. See Section \@ref(markdown-extensions) for details. You can also pass more custom Pandoc arguments through the `pandoc_args` option (Section \@ref(pandoc-arguments)), and define shared options in `_output.yml` (Section \@ref(shared-options)).

## Word document

To create a Word\index{Word} document from R Markdown, you specify the `word_document` output format in the YAML metadata of your document:

```yaml
---
title: "Habits"
author: John Doe
date: March 22, 2005
output: word_document
---
```

The most notable feature of Word documents is the Word template, which is also known as the "style reference document". You can specify a document to be used as a style reference in producing a `*.docx` file (a Word document). This will allow you to customize things such as margins and other formatting characteristics. For best results, the reference document should be a modified version of a `.docx` file produced using **rmarkdown** or Pandoc. The path of such a document can be passed to the `reference_docx` argument of the `word_document` format. Pass `"default"` to use the default styles. For example:

```yaml
---
title: "Habits"
output:
  word_document:
    reference_docx: my-styles.docx
---
```

For more on how to create and use a reference document, you may watch this short video: https://vimeo.com/110804387, or read this detailed article: https://rmarkdown.rstudio.com/articles_docx.html.

### Other features

Refer to Section \@ref(html-document) for the documentation of most features of Word documents, including figure options (Section \@ref(figure-options)), data frame printing (Section \@ref(data-frame-printing)), syntax highlighting (Section \@ref(appearance-and-style)), keeping Markdown (Section \@ref(keeping-markdown)), Markdown extensions (Section \@ref(markdown-extensions)), Pandoc arguments (Section \@ref(pandoc-arguments)), and shared options (Section \@ref(shared-options)).

## OpenDocument Text document

To create an OpenDocument Text (ODT) document from R Markdown, you specify the `odt_document` output format in the YAML metadata of your document:

```yaml
---
title: "Habits"
author: John Doe
date: March 22, 2005
output: odt_document
---
```

Similar to `word_document,` you can also provide a style reference document to `odt_document` throught the `reference_odt` option. For best results, the reference ODT document should be a modified version of an ODT file produced using **rmarkdown** or Pandoc. For example:

```yaml
---
title: "Habits"
output:
  odt_document:
    reference_odt: my-styles.odt
---
```

### Other features

Refer to Section \@ref(html-document) for the documentation of most features of ODT documents, including figure options (Section \@ref(figure-options)), keeping Markdown (Section \@ref(keeping-markdown)), header and before/after body inclusions (Section \@ref(includes)), custom templates (Section \@ref(custom-templates)), Markdown extensions (Section \@ref(markdown-extensions)), Pandoc arguments (Section \@ref(pandoc-arguments)), and shared options (Section \@ref(shared-options)).

## Rich Text Format document

To create a Rich Text Format (RTF) document from R Markdown, you specify the `rtf_document` output format in the YAML metadata of your document:

```yaml
---
title: "Habits"
author: John Doe
date: March 22, 2005
output: rtf_document
---
```

If you know the RTF format really well, you can actually embed raw RTF content in R Markdown. For example, you may create a table in RTF using other software packages, and insert it to your final RTF output document. An RTF document is essentially a plain-text document, so you can read it into R using functions like `readLines()`. Now suppose you have an RTF table in the file `table.rtf`. To embed it in R Markdown, you read it and pass to `knitr::raw_output()`, e.g.,

````markdown
`r ''````{r, echo=FALSE}
knitr::raw_output(readLines('table.rtf'))
```
````

### Other features

Refer to Section \@ref(html-document) for the documentation of most features of RTF documents, including table of contents (Section \@ref(table-of-contents)), figure options (Section \@ref(figure-options)), keeping Markdown (Section \@ref(keeping-markdown)), Markdown extensions (Section \@ref(markdown-extensions)), Pandoc arguments (Section \@ref(pandoc-arguments)), and shared options (Section \@ref(shared-options)).

## Markdown document

In some cases, you might want to produce plain Markdown output from R Markdown (e.g., to create a document for a system that accepts Markdown input like [Stack Overflow](https://stackoverflow.com/editing-help)).

To create a Markdown document from R Markdown, you specify the `md_document` output format in the front-matter of your document:

```yaml
---
title: "Habits"
author: John Doe
date: March 22, 2005
output: md_document
---
```

### Markdown variants

By default, the `md_document` format produces "strict" Markdown (i.e., conforming to the original Markdown specification with no extensions). You can generate a different flavor of Markdown using the `variant` option. For example:

```yaml
---
output:
  md_document:
    variant: markdown_github
---
```

Valid values are:

* `markdown` (Full Pandoc Markdown)
* `markdown_strict` (Original Markdown specification; the default)
* `markdown_github` (GitHub Flavored Markdown)
* `markdown_mmd` (MultiMarkdown)
* `markdown_phpextra` (PHP Markdown extra)

You can also compose custom Markdown variants. For example:

```yaml
---
output:
  md_document:
    variant: markdown_strict+backtick_code_blocks+autolink_bare_uris
---
```

See Pandoc's Manual for all of the Markdown extensions and their names to be used in composing custom variants.

#### Publishing formats

Many popular publishing systems now accept Markdown as input. Table \@ref(tab:markdown-variant) shows the correct Markdown variants to use for some popular systems.

Table: (\#tab:markdown-variant) Markdown variants for some popular publishing systems.

System|Markdown Variant
--------|-----------
GitHub Wikis|`markdown_github`
Drupal|`markdown_phpextra`
WordPress.com|`markdown_phpextra+backtick_code_blocks`
StackOverflow|`markdown_strict+autolink_bare_uris`

In many cases, you can simply copy and paste the Markdown generated by `rmarkdown::render()` into the editing interface of the system you are targeting. Note, however, that if you have embedded plots or other images, you will need to upload them separately and fix up their URLs to point to the uploaded location. If you intend to build websites based on R Markdown, we recommend that you use the more straightforward solutions such as **blogdown** [@xie2017; @R-blogdown] as introduced in Section \@ref(websites) instead of manually copying the Markdown content.

### Other features

Refer to Section \@ref(html-document) for the documentation of other features of Markdown documents, including table of contents (Section \@ref(table-of-contents)), figure options (Section \@ref(figure-options)), header and before/after body inclusions (Section \@ref(includes)), Pandoc arguments (Section \@ref(pandoc-arguments)), and shared options (Section \@ref(shared-options)).

## R package vignette

The `html_vignette` format provides a lightweight alternative to `html_document` suitable for inclusion in packages to be released to CRAN. It reduces the size of a basic vignette\index{R package vignette} from 600Kb to around 10Kb. The format differs from a conventional HTML document as follows:

- Never uses retina figures
- Has a smaller default figure size
- Uses a custom lightweight CSS stylesheet

To use `html_vignette`, you specify it as the output format and add some additional vignette related settings via the `\Vignette*{}` macros:

```yaml
---
title: "Your Vignette Title"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{Your Vignette Title}
  %\VignetteEncoding{UTF-8}
---
```

Note that you should change the `title` field and the `\VignetteIndexEntry{}` to match the title of your vignette.

Most options for `html_document` (Section \@ref(html-document)) also work for `html_vignette`, except `fig_retina` and `theme`, which have been set to `null` internally in this format.

The `html_vignette` template includes a basic CSS theme. To override this theme, you can specify your own CSS in the document metadata as follows:

```yaml
output:
  rmarkdown::html_vignette:
    css: mystyles.css
```

The default figure size is 3x3. Because the figure width is small, usually you will be able to put two images side-by-side if you set the chunk option `fig.show='hold'`, e.g.,

````markdown
`r ''````{r, fig.show='hold'}
plot(1:10)
plot(10:1)
```
````

If you want larger figure sizes you can change the `fig_width` and `fig_height` in the document output options or alternatively override the default options on a per-chunk basis.

<!--chapter:end:03-documents.Rmd-->

# Presentations

For documents, the basic units are often sections. For presentations, the basic units are slides. A section in the Markdown source document often indicates a new slide in the presentation formats. In this chapter, we introduce the built-in presentation formats in the **rmarkdown** package.

## ioslides presentation

To create an ioslides presentation\index{ioslides} from R Markdown, you specify the `ioslides_presentation` output format in the YAML metadata of your document. You can create a slide show broken up into sections by using the `#` and `##` heading tags (you can also create a new slide without a header using a horizontal rule (`---`). For example here is a simple slide show (see Figure \@ref(fig:ioslides) for two sample slides):

````markdown
---
title: "Habits"
author: John Doe
date: March 22, 2005
output: ioslides_presentation
---

# In the morning

## Getting up

- Turn off alarm
- Get out of bed

## Breakfast

- Eat eggs
- Drink coffee

# In the evening

## Dinner

- Eat spaghetti
- Drink wine

---

`r ''````{r, cars, fig.cap="A scatterplot.", echo=FALSE}
plot(cars)
```

## Going to sleep

- Get in bed
- Count sheep
````

```{r ioslides, echo=FALSE, fig.cap='Two sample slides in an ioslides presentation.', out.width='49%', fig.show='hold'}
knitr::include_graphics(c('images/ioslides-1.png', 'images/ioslides-2.png'), dpi = NA)
```

You can add a subtitle to a slide or section by including text after the pipe (`|`) character. For example:

```markdown
## Getting up | What I like to do first thing
```

### Display modes

The following single character keyboard shortcuts enable alternate display modes:

- `'f'`: enable fullscreen mode

- `'w'`: toggle widescreen mode

- `'o'`: enable overview mode

- `'h'`: enable code highlight mode

- `'p'`: show presenter notes

Pressing `Esc` exits all of these modes. See the sections below on *Code Highlighting* and *Presenter Mode* for additional detail on those modes.

### Incremental bullets

You can render bullets incrementally by adding the `incremental` option:

```yaml
---
output:
  ioslides_presentation:
    incremental: true
---
```

If you want to render bullets incrementally for some slides but not others you can (ab)use this syntax for blockquotes:

```markdown
> - Eat eggs
> - Drink coffee
```

### Visual appearance

#### Presentation size

You can display the presentation using a wider form factor using the `widescreen` option. You can specify that smaller text be used with the `smaller` option. For example:

```yaml
---
output:
  ioslides_presentation:
    widescreen: true
    smaller: true
---
```

You can also enable the `smaller` option on a slide-by-slide basis by adding the `.smaller` attribute to the slide header:

```markdown
## Getting up {.smaller}
```

#### Transition speed

You can customize the speed of slide transitions using `transition` option. This can be `"default"`, `"slower"`, `"faster"`, or a numeric value with a number of seconds (e.g., `0.5`) . For example:

```yaml
---
output:
  ioslides_presentation:
    transition: slower
---
```

#### Build slides

Slides can also have a `.build` attribute that indicate that their content should be displayed incrementally. For example:

```markdown
## Getting up {.build}
```

Slide attributes can be combined if you need to specify more than one. For example:

```markdown
## Getting up {.smaller .build}
```

#### Background images

You can specify a background image for a slide using the attribute `data-background`, and use other attributes including `data-background-size`, `data-background-position`, and `data-background-repeat` to tweak the style of the image. You need to be familiar with CSS to fully understand these four attributes, and they correspond to [the CSS properties](https://www.w3schools.com/cssref/css3_pr_background.asp) `background`, `background-size`, `background-position`, and `background-repeat`, respectively. For example:

```markdown
## Getting up {data-background=foo.png data-background-size=cover}
```

#### Custom CSS {#custom-css-ioslides}

You can add your own CSS\index{CSS} to an ioslides presentation using the `css` option:

```markdown
---
output:
  ioslides_presentation:
    css: styles.css
---
```

You can also target specific slides or classes of slides with custom CSS by adding IDs or classes to the slides headers within your document. For example the following slide header:

```markdown
## Future Steps {#future-steps .emphasized}
```

Would enable you to apply CSS to all of its content using either of the following CSS selectors:

```css
#future-steps {
  color: blue;
}

.emphasized {
  font-size: 1.2em;
}
```

### Code highlighting

It is possible to select subsets of code for additional emphasis by adding a special "highlight" comment around the code. For example:

```r
### <b>
x <- 10
y <- x * 2
### </b>
```

The highlighted region will be displayed with a bold font. When you want to help the audience focus exclusively on the highlighted region press the `h` key and the rest of the code will fade away.

### Adding a logo

You can add a logo to the presentation using the `logo` option (by default, the logo will be displayed in a 85x85 pixel square). For example:

```yaml
---
output:
  ioslides_presentation:
    logo: logo.png
---
```

The logo graphic will be rescaled to 85x85 (if necessary) and added to the title slide. A smaller icon version of the logo will be included in the bottom-left footer of each slide.

The logo on the title page and the rectangular element containing it can be customised with CSS. For example:

```css
.gdbar img {
  width: 300px !important;
  height: 150px !important;
  margin: 8px 8px;
}

.gdbar {
  width: 400px !important;
  height: 170px !important;
}
```

These selectors are to be placed in the CSS text file.

Similarly, the logo in the footer of each slide can be resized to any desired size. For example:

```css
slides > slide:not(.nobackground):before {
  width: 150px;
  height: 75px;
  background-size: 150px 75px;
}
```

This will make the footer logo 150 by 75 pixels in size.

### Tables

The ioslides template has an attractive default style for tables so you should not hesitate to add tables for presenting more complex sets of information. Pandoc Markdown supports several syntaxes for defining tables, which are described in the Pandoc Manual.

### Advanced layout

You can center content on a slide by adding the `.flexbox` and `.vcenter` attributes to the slide title. For example:

```markdown
## Dinner {.flexbox .vcenter}
```

You can horizontally center content by enclosing it in a `div` tag with class `centered`. For example:

```html
<div class="centered">
This text is centered.
</div>
```

You can do a two-column layout using the `columns-2` class. For example:

```html
<div class="columns-2">
  ![](image.png)

  - Bullet 1
  - Bullet 2
  - Bullet 3
</div>
```

Note that content will flow across the columns so if you want to have an image on one side and text on the other you should make sure that the image has sufficient height to force the text to the other side of the
slide.

### Text color

You can color content using base color classes `red`, `blue`, `green`, `yellow`, and `gray` (or variations of them, e.g., `red2`, `red3`, `blue2`, `blue3`, etc.). For example:

```html
<div class="red2">
This text is red
</div>
```

### Presenter mode

A separate presenter window can also be opened (ideal for when you are presenting on one screen but have another screen that is private to you). The window stays in sync with the main presentation window and also shows presenter notes and a thumbnail of the next slide. To enable presenter mode add `?presentme=true` to the URL of the presentation. For example:

```markdown
my-presentation.html?presentme=true
```

The presenter mode window will open and will always re-open with the presentation until it is disabled with:

```markdown
my-presentation.html?presentme=false
```

To add presenter notes to a slide, you include it within a "notes" `div`. For example:

```html
<div class="notes">
This is my *note*.

- It can contain markdown
- like this list
</div>
```

### Printing and PDF output

You can print an ioslides presentation from within browsers that have good support for print CSS (as of this writing, Google Chrome has the best support). Printing maintains most of the visual styles of the HTML version of the presentation.

To create a PDF version of a presentation, you can use the menu `Print to PDF` from Google Chrome. Alternatively, you can use the function `pagedown::chrome_print()` from the **pagedown** package [@R-pagedown], which calls Chrome to print an Rmd or HTML file to PDF.

### Custom templates

You can replace the underlying Pandoc template using the `template` option:

```yaml
---
title: "Habits"
output:
  ioslides_presentation:
    template: quarterly-report.html
---
```

However, please note that the level of customization that can be achieved is limited compared to the templates of other output formats, because the slides are generated by custom formatting written in Lua, and as such the template used must include the string `RENDERED_SLIDES` as can be found in the default template file with the path [`rmarkdown:::rmarkdown_system_file("rmd/ioslides/default.html")`](https://github.com/rstudio/rmarkdown/blob/master/inst/rmd/ioslides/default.html).

### Other features

Refer to Section \@ref(html-document) for the documentation of other features of ioslides presentations, including figure options (Section \@ref(figure-options)), MathJax equations (Section \@ref(mathjax-equations)), data frame printing (Section \@ref(data-frame-printing)), Markdown extensions (Section \@ref(markdown-extensions)), keeping Markdown (Section \@ref(keeping-markdown)), document dependencies (Section \@ref(document-dependencies)), header and before/after body inclusions (Section \@ref(includes)), Pandoc arguments (Section \@ref(pandoc-arguments)), and shared options (Section \@ref(shared-options)).

## Slidy presentation

To create a [Slidy](https://www.w3.org/Talks/Tools/Slidy2/) presentation from R Markdown, you specify the `slidy_presentation`\index{Slidy presentation} output format in the YAML metadata of your document. You can create a slide show broken up into sections by using the `##` heading tag (you can also create a new slide without a header using a horizontal rule (`---`). For example, here is a simple slide show (see Figure \@ref(fig:slidy) for two sample slides):

````markdown
---
title: "Habits"
author: John Doe
date: March 22, 2005
output: slidy_presentation
---

# In the morning

## Getting up

- Turn off alarm
- Get out of bed

## Breakfast

- Eat eggs
- Drink coffee

# In the evening

## Dinner

- Eat spaghetti
- Drink wine

---

`r ''````{r, cars, fig.cap="A scatterplot.", echo=FALSE}
plot(cars)
```

## Going to sleep

- Get in bed
- Count sheep
````

```{r slidy, echo=FALSE, fig.cap='Two sample slides in a Slidy presentation.', out.width='49%', fig.show='hold'}
knitr::include_graphics(c('images/slidy-1.png', 'images/slidy-2.png'), dpi = NA)
```

### Display modes

The following single character keyboard shortcuts enable alternate display modes:

- `'C'`: Show table of contents (the right sub-figure in Figure \@ref(fig:slidy) has shown the table of contents).
- `'F'`: Toggles the display of the footer.
- `'A'`: Toggles display of current vs all slides (useful for printing handouts).
- `'S'`: Make fonts smaller.
- `'B'`: Make fonts larger .

### Text size

You can use the `font_adjustment` option to increase or decrease the default font size (e.g., `-1` or `+1`) for the entire presentation. For example:

```yaml
---
output:
  slidy_presentation:
    font_adjustment: -1
---
```

If you want to decrease the text size on an individual slide you can use the `.smaller` slide attribute. For example:

```markdown
## Getting up {.smaller}
```

If you want to increase the text size on an individual slide you can use the `.bigger` slide attribute. For example:

```markdown
## Getting up {.bigger}
```

You can also manually adjust the font size during the presentation using the `'S'` (smaller) and `'B'` (bigger) keys.

### Footer elements

You can add a countdown timer to the footer of your slides using the `duration` option (duration is specified in minutes). For example:

```yaml
---
output:
  slidy_presentation:
    duration: 45
---
```

You can also add custom footer text (e.g., organization name and/or copyright) using the `footer` option. For example:

```yaml
---
output:
  slidy_presentation:
    footer: "Copyright (c) 2014, RStudio"
---
```

### Other features

Refer to Section \@ref(html-document) for the documentation of other features of Slidy presentations, including figure options (Section \@ref(figure-options)), appearance and style (Section \@ref(appearance-and-style)), MathJax equations (Section \@ref(mathjax-equations)), data frame printing (Section \@ref(data-frame-printing)), Markdown extensions (Section \@ref(markdown-extensions)), keeping Markdown (Section \@ref(keeping-markdown)), document dependencies (Section \@ref(document-dependencies)), header and before/after body inclusions (Section \@ref(includes)), custom templates (Section \@ref(custom-templates)), Pandoc arguments (Section \@ref(pandoc-arguments)), and shared options (Section \@ref(shared-options)).

Slidy presentations have several features in common with ioslides presentations in Section \@ref(ioslides-presentation). For incremental bullets, see Section \@ref(incremental-bullets). For custom CSS, see Section \@ref(custom-css-ioslides). For printing Slidy slides to PDF, see Section \@ref(printing-and-pdf-output).

## Beamer presentation

To create a Beamer\index{LaTeX Beamer} presentation from R Markdown, you specify the `beamer_presentation` output format in the YAML metadata of your document. You can create a slide show broken up into sections by using the `#` and `##` heading tags (you can also create a new slide without a header using a horizontal rule (`---`). For example, here is a simple slide show (see Figure \@ref(fig:beamer) for two sample slides):

````markdown
---
title: "Habits"
author: John Doe
date: March 22, 2005
output: beamer_presentation
---

# In the morning

## Getting up

- Turn off alarm
- Get out of bed

## Breakfast

- Eat eggs
- Drink coffee

# In the evening

## Dinner

- Eat spaghetti
- Drink wine

---

`r ''````{r, cars, fig.cap="A scatterplot.", echo=FALSE}
plot(cars)
```

## Going to sleep

- Get in bed
- Count sheep
````

```{r beamer, echo=FALSE, fig.cap='Two sample slides in a Beamer presentation.', out.width='49%', fig.show='hold'}
knitr::include_graphics(c('images/beamer-1.png', 'images/beamer-2.png'), dpi = NA)
```

Within R Markdown documents that generate PDF output, you can use raw LaTeX and even define LaTeX macros. See Pandoc's manual for details.

### Themes

You can specify Beamer themes using the `theme`, `colortheme`, and `fonttheme` options. For example:

```yaml
---
output:
  beamer_presentation:
    theme: "AnnArbor"
    colortheme: "dolphin"
    fonttheme: "structurebold"
---
```

Figure \@ref(fig:beamer-theme) shows two sample slides of the `AnnArbor` theme in the above example. You can find a list of possible themes and color themes at https://hartwork.org/beamer-theme-matrix/.

```{r beamer-theme, echo=FALSE, fig.cap='Two sample slides with the AnnArbor theme in Beamer.', out.width='49%', fig.show='hold'}
knitr::include_graphics(c('images/beamer-theme-1.png', 'images/beamer-theme-2.png'), dpi = NA)
```

### Slide level

The `slide_level` option defines the heading level that defines individual slides. By default, this is the highest header level in the hierarchy that is followed immediately by content, and not another header, somewhere in the document. This default can be overridden by specifying an explicit `slide_level`:

```yaml
---
output:
  beamer_presentation:
    slide_level: 2
---
```

### Other features

Refer to Section \@ref(html-document) for the documentation of other features of Beamer presentations, including table of contents (Section \@ref(table-of-contents)), figure options (Section \@ref(figure-options)), appearance and style (Section \@ref(appearance-and-style)), data frame printing (Section \@ref(data-frame-printing)), Markdown extensions (Section \@ref(markdown-extensions)), header and before/after body inclusions (Section \@ref(includes)), custom templates (Section \@ref(custom-templates)), Pandoc arguments (Section \@ref(pandoc-arguments)), and shared options (Section \@ref(shared-options)).

Beamer presentations have a few features in common with ioslides presentations in Section \@ref(ioslides-presentation) and PDF documents in Section \@ref(pdf-document). For incremental bullets, see Section \@ref(incremental-bullets). For how to keep the intermediate LaTeX output file, see Section \@ref(keeping-intermediate-tex).

## PowerPoint presentation

To create a PowerPoint\index{PowerPoint} presentation from R Markdown, you specify the `powerpoint_presentation` output format in the YAML metadata of your document. Please note that this output format is only available in **rmarkdown** >= v1.9, and requires at least Pandoc v2.0.5. You can check the versions of your **rmarkdown** package and Pandoc with `packageVersion('rmarkdown')` and `rmarkdown::pandoc_version()` in R, respectively. The RStudio version 1.1.x ships Pandoc 1.19.2.1, which is not sufficient to generate PowerPoint presentations. You need to either install Pandoc 2.x by yourself if you use RStudio 1.1.x, or install [a preview version of RStudio](https://www.rstudio.com/products/rstudio/download/preview/) (>= 1.2.633), which has bundled Pandoc 2.x.

Below is a quick example (see Figure \@ref(fig:powerpoint) for a sample slide):

````markdown
---
title: "Habits"
author: John Doe
date: March 22, 2005
output: powerpoint_presentation
---

# In the morning

## Getting up

- Turn off alarm
- Get out of bed

## Breakfast

- Eat eggs
- Drink coffee

# In the evening

## Dinner

- Eat spaghetti
- Drink wine

---

`r ''````{r, cars, fig.cap="A scatterplot.", echo=FALSE}
plot(cars)
```

## Going to sleep

- Get in bed
- Count sheep
````

```{r powerpoint, echo=FALSE, fig.cap='A sample slide in a PowerPoint presentation.', out.width='100%'}
knitr::include_graphics(c('images/powerpoint.png'), dpi = NA)
```

The default slide level (i.e., the heading level that defines individual slides) is determined in the same way as in Beamer slides (Section \@ref(slide-level)), and you can specify an explicit level via the `slide_level` option under `powerpoint_presentation`. You can also start a new slide without a header using a horizontal rule `---`.

You can generate most elements supported by Pandoc's Markdown (Section \@ref(markdown-syntax)) in PowerPoint output, such as bold/italic text, footnotes, bullets, LaTeX math expressions, images, and tables, etc.

Please note that images and tables will always be placed on new slides. The only elements that can coexist with an image or table on a slide are the slide header and image/table caption. When you have a text paragraph and an image on the same slide, the image will be moved to a new slide automatically. Images will be scaled automatically to fit the slide, and if the automatic size does not work well, you may manually control the image sizes: for static images included via the Markdown syntax `![]()`, you may use the `width` and/or `height` attributes in a pair of curly braces after the image, e.g., `![caption](foo.png){width=40%}`; for images generated dynamically from R code chunks, you can use the chunk options `fig.width` and `fig.height` to control the sizes.

Please read the section "Producing slide shows with Pandoc" in Pandoc's manual for more information on slide shows, such as the multi-column layout:

```markdown
:::::: {.columns}
::: {.column}
Content of the left column.
:::

::: {.column}
Content of the right column.
:::
::::::
```

### Custom templates {#ppt-templates}

Like Word documents (Section \@ref(word-document)), you can customize the appearance of PowerPoint presentations by passing a custom reference document via the `reference_doc` option, e.g.,

```yaml
---
title: "Habits"
output:
  powerpoint_presentation:
    reference_doc: my-styles.pptx
---
```

Note that the `reference_doc` option requires a version of **rmarkdown** higher than 1.9:

```{r eval=FALSE}
if (packageVersion('rmarkdown') <= '1.9') {
  install.packages('rmarkdown')  # update rmarkdown from CRAN
}
```

Basically any template included in a recent version of Microsoft PowerPoint should work. You can create a new `*.pptx` file from the PowerPoint menu `File -> New` with your desired template, save the new file, and use it as the reference document (template) through the `reference_doc` option. Pandoc will read the styles in the template and apply them to the PowerPoint presentation to be created from R Markdown.

### Other features

Refer to Section \@ref(html-document) for the documentation of other features of PowerPoint presentations, including table of contents (Section \@ref(table-of-contents)), figure options (Section \@ref(figure-options)), data frame printing (Section \@ref(data-frame-printing)), keeping Markdown (Section \@ref(keeping-markdown)), Markdown extensions (Section \@ref(markdown-extensions)), Pandoc arguments (Section \@ref(pandoc-arguments)), and shared options (Section \@ref(shared-options)). As of Pandoc 2.2.1, incremental slides in PowerPoint are not supported yet.

<!--chapter:end:04-presentations.Rmd-->

# (PART) Extensions {-}

# Dashboards

R Markdown is customizable and extensible. In Chapters \@ref(documents) and \@ref(presentations), we have introduced basic document and presentation formats in the **rmarkdown** package, and explained how to customize them. From this chapter on, we will show several more existing extension packages that bring different styles, layouts, and applications to the R Markdown ecosystem. In this chapter, we introduce dashboards\index{dashboard} based on the **flexdashboard** package [@R-flexdashboard].

Dashboards are particularly common in business-style reports. They can be used to highlight brief and key summaries of a report. The layout of a dashboard is often grid-based, with components arranged in boxes of various sizes.

With the **flexdashboard** package, you can

- Use R Markdown to publish a group of related data visualizations as a dashboard.

- Embed a wide variety of components including HTML widgets, R graphics, tabular data, gauges, value boxes, and text annotations.

- Specify row or column-based layouts (components are intelligently re-sized to fill the browser and adapted for display on mobile devices).

- Create story boards for presenting sequences of visualizations and related commentary.

- Optionally use Shiny to drive visualizations dynamically.

To author a dashboard, you create an R Markdown document with the `flexdashboard::flex_dashboard` output format. You can also create a document from within RStudio using the `File -> New File -> R Markdown` dialog, and choosing a "Flex Dashboard" template.

If you are not using RStudio, you can create a new `flexdashboard` R Markdown file from the R console:

```r
rmarkdown::draft(
  "dashboard.Rmd", template = "flex_dashboard",
  package = "flexdashboard"
)
```

The full documentation of **flexdashboard** is at https://rmarkdown.rstudio.com/flexdashboard/. We will only cover some basic features and usage in this chapter. Dashboards have many features in common with HTML documents (Section \@ref(html-document)), such as figure options (Section \@ref(figure-options)), appearance and style (Section \@ref(appearance-and-style)), MathJax equations (Section \@ref(mathjax-equations)), header and before/after body inclusions (Section \@ref(includes)), and Pandoc arguments (Section \@ref(pandoc-arguments)), and so on. We also recommend that you take a look at the R help page `?flexdashboard::flex_dashboard` to learn about more features and options.

## Layout

The overall rule about the dashboard layout is that a first-level section generates a page, a second-level section generates a column (or a row), and a third-level section generates a box (that contains one or more dashboard components). Below is a quick example:

````markdown
`r xfun::file_string('examples/dashboard/01-start.Rmd')`
````

Note that a series of dashes under a line of text is the alternative Markdown syntax for the second-level section header, i.e.,

```markdown
Column 1
--------------------------------------------------
```

is equivalent to

```markdown
## Column 1
```

We used a series of dashes just to make the second-level sections stand out in the source document. By default, the second-level sections generate columns on a dashboard, and the third level sections will be stacked vertically inside columns. You do not have to have columns on a dashboard: when all you have are the third-level sections in the source document, they will be stacked vertically as one column in the output.

The text of the second-level headers will not be displayed in the output. The second-level headers are for the sole purpose of layout, so the actual content of the headers does not matter at all. By contrast, the first-level and third-level headers will be displayed as titles.

Figure \@ref(fig:dashboard-start) shows the output of the above example, in which you can see two columns, with the first column containing "Chart A", and the second column containing "Chart B" and "Chart C". We did not really include any R code in the code chunks, so all boxes are empty. In these code chunks, you may write arbitrary R code that generates R plots, HTML widgets, and various other components to be introduced in Section \@ref(dashboard-components).

```{r dashboard-start, echo=FALSE, fig.cap='A quick example of the dashboard layout.', out.width='100%'}
knitr::include_graphics('images/dashboard-start.png', dpi = NA)
```

### Row-based layouts

You may change the column-oriented layout to the row-oriented layout through the `orientation` option, e.g.,

```yaml
output:
  flexdashboard::flex_dashboard:
    orientation: rows
```

That means the second-level sections will be rows, and the third-level sections will be arranged as columns within rows.

### Attributes on sections

The second-level section headers may have attributes on them, e.g., you can set the width of a column to 350:

```markdown
A narrow column {data-width=350}
--------------------------------
```

For the row-oriented layout, you can set the `data-height` attribute for rows. The `{.tabset}` attribute can be applied on a column so that the third-level sections will be arranged in tabs, e.g.,

```markdown
Two tabs {.tabset}
------------------

### Tab A

### Tab B
```

### Multiple pages

When you have multiple first-level sections in the document, they will be displayed as separate pages on the dashboard. Below is an example, and Figure \@ref(fig:dashboard-pages) shows the output. Note that a series of equal signs is the alternative Markdown syntax for the first-level section headers (you can use a single pound sign `#`, too).

````markdown
`r xfun::file_string('examples/dashboard/02-pages.Rmd')`
````

Page titles are displayed as a navigation menu at the top of the dashboard. In this example, we applied icons to page titles through the `data-icon` attribute. You can find other available icons from https://fontawesome.com.

```{r dashboard-pages, echo=FALSE, fig.cap='Multiple pages on a dashboard.', out.width='100%'}
knitr::include_graphics('images/dashboard-pages.png', dpi = NA)
```

### Story boards

Besides the column and row-based layouts, you may present a series of visualizations and related commentary through the "storyboard" layout. To enable this layout, you use the option `storyboard`. Below is an example, and Figure \@ref(fig:dashboard-story) shows the output, in which you can see left/right navigation buttons at the top to help you go through all visualizations and associated commentaries one by one.

````markdown
`r xfun::file_string('examples/dashboard/03-storyboard.Rmd')`
````

```{r dashboard-story, echo=FALSE, fig.cap='An example story board.', out.width='100%'}
knitr::include_graphics('images/dashboard-story.png', dpi = NA)
```

## Components {#dashboard-components}

A wide variety of components can be included in a dashboard layout, including:

1. Interactive JavaScript data visualizations based on HTML widgets.

1. R graphical output including base, lattice, and grid graphics.

1. Tabular data (with optional sorting, filtering, and paging).

1. Value boxes for highlighting important summary data.

1. Gauges for displaying values on a meter within a specified range.

1. Text annotations of various kinds.

1. A navigation bar to provide more links related to the dashboard.

The first three components work in most R Markdown documents regardless of output formats. Only the latter four are specific to dashboards, and we briefly introduce them in this section.

### Value boxes

Sometimes you want to include one or more simple values within a dashboard. You can use the `valueBox()` function in the **flexdashboard** package to display single values along with a title and an optional icon. For example, here are three side-by-side sections, each displaying a single value (see Figure \@ref(fig:dashboard-valueboxes) for the output):

````markdown
`r xfun::file_string('examples/dashboard/04-valueboxes.Rmd')`
````

```{r dashboard-valueboxes, echo=FALSE, fig.cap='Three value boxes side by side on a dashboard.', out.width='100%'}
knitr::include_graphics('images/dashboard-valueboxes.png', dpi = NA)
```

The `valueBox()` function is called to emit a value and specify an icon.

The third code chunk ("Spam per Day") makes the background color of the value box dynamic using the `color` parameter. Available colors include `"primary"`, `"info"`, `"success"`, `"warning"`, and `"danger"` (the default is `"primary"`). You can also specify any valid CSS color (e.g., `"#ffffff"`, `"rgb(100, 100, 100)"`, etc.).

### Gauges

Gauges display values on a meter within a specified range. For example, here is a set of three gauges (see Figure \@ref(fig:dashboard-gauges) for the output):

````markdown
`r xfun::file_string('examples/dashboard/05-gauges.Rmd')`
````

```{r dashboard-gauges, echo=FALSE, fig.cap='Three gauges side by side on a dashboard.', out.width='100%'}
knitr::include_graphics('images/dashboard-gauges.png', dpi = NA)
```

There are a few things to note about this example:

1. The `gauge()` function is used to output a gauge. It has three required arguments: `value`, `min`, and `max` (these can be any numeric values).

1. You can specify an optional `symbol` to be displayed alongside the value (in the example "`%`" is used to denote a percentage).

1. You can specify a set of custom color "sectors" using the `gaugeSectors()` function. By default, the current theme's "success" color (typically green) is used for the gauge color. The `sectors` option enables you to specify a set of three value ranges (`success`, `warning`, and `danger`), which cause the gauge's color to change based on its value.

### Text annotations

If you need to include additional narrative or explanation within your dashboard, you can do so in the following ways:

1. You can include content at the top of the page before dashboard sections are introduced.

1. You can define dashboard sections that do not include a chart but rather include arbitrary content (text, images, and equations, etc.).

For example, the following dashboard includes some content at the top and a dashboard section that contains only text (see Figure \@ref(fig:dashboard-text) for the output):

````markdown
`r xfun::file_string('examples/dashboard/06-text.Rmd')`
````

```{r dashboard-text, echo=FALSE, fig.cap='Text annotations on a dashboard.', out.width='100%'}
knitr::include_graphics('images/dashboard-text.png', dpi = NA)
```

Each component within a dashboard includes optional title and notes sections. The title is simply the text after the third-level (`###`) section heading. The notes are any text prefaced with `>` after the code chunk that yields the component's output (see the second component of the above example).

You can exclude the title entirely by applying the `.no-title` attribute to a section heading.

### Navigation bar

By default, the dashboard navigation bar includes the document's `title`, `author`, and `date`. When a dashboard has multiple pages (Section \@ref(multiple-pages)), links to the various pages are also included on the left side of the navigation bar. You can also add social links to the dashboard.

In addition, you can add custom links to the navigation bar using the `navbar` option. For example, the following options add an "About" link to the navigation bar:

```yaml
---
title: "Navigation Bar"
output:
  flexdashboard::flex_dashboard:
    navbar:
      - { title: "About", href: "https://example.com/about" }
---
```

Navigation bar items must include either a `title` or `icon` field (or both). You should also include a `href` as the navigation target. The `align` field is optional (it can be "left" or "right" and defaults to "right").

You can include links to social sharing services via the `social` option. For example, the following dashboard includes Twitter and Facebook links as well as a drop-down menu with a more complete list of services:

```yaml
---
title: "Social Links"
output:
  flexdashboard::flex_dashboard:
    social: [ "twitter", "facebook", "menu" ]
---
```

The `social` option can include any number of the following services: `"facebook"`, `"twitter"`, `"google-plus"`, `"linkedin"`, and `"pinterest"`. You can also specify `"menu"` to provide a generic sharing drop-down menu that includes all of the services.

## Shiny

By adding Shiny\index{Shiny} to a dashboard, you can let viewers change underlying parameters and see the results immediately, or let dashboards update themselves incrementally as their underlying data changes (see functions `reactiveFileReader()` and `reactivePoll()` in the **shiny** package). This is done by adding `runtime: shiny` to a standard dashboard document, and then adding one or more input controls and/or reactive expressions that dynamically drive the appearance of the components within the dashboard.

Using Shiny with **flexdashboard** turns a static R Markdown report into an interactive document. It is important to note that interactive documents need to be deployed to a Shiny Server to be shared broadly (whereas static R Markdown documents are standalone web pages that can be attached to emails or served from any standard web server).

Note that the [**shinydashboard**](https://rstudio.github.io/shinydashboard/) package provides another way to create dashboards with Shiny.

### Getting started

The steps required to add Shiny components to a dashboard are:

1. Add `runtime: shiny` to the options declared at the top of the document (YAML metadata).

1. Add the `{.sidebar}` attribute to the first column of the dashboard to make it a host for Shiny input controls (note that this step is not strictly required, but this will generate a typical layout for Shiny-based dashboards).

1. Add Shiny inputs and outputs as appropriate.

1. When including plots, be sure to wrap them in a call to `renderPlot()`. This is important not only for dynamically responding to changes, but also to ensure that they are automatically re-sized when their container changes.

### A Shiny dashboard example

Here is a simple example of a dashboard that uses Shiny (see Figure \@ref(fig:dashboard-shiny) for the output):

````markdown
`r xfun::file_string('examples/dashboard/07-shiny.Rmd')`
````

```{r dashboard-shiny, echo=FALSE, fig.cap='An interactive dashboard based on Shiny.', out.width='100%'}
knitr::include_graphics('images/dashboard-shiny.png', dpi = NA)
```

The first column includes the `{.sidebar}` attribute and two Shiny input controls; the second column includes the Shiny code required to render the chart based on the inputs.

One important thing to note about this example is the chunk labeled `global` at the top of the document. The `global` chunk has special behavior within **flexdashboard**: it is executed only once within the global environment, so that its results (e.g., data frames read from disk) can be accessed by all users of a multi-user dashboard. Loading your data within a `global` chunk will result in substantially better startup performance for your users, and hence is highly recommended.

### Input sidebar

You add an input sidebar to a flexdashboard by adding the `{.sidebar}` attribute to a column, which indicates that it should be laid out flush to the left with a default width of 250 pixels and a special background color. Sidebars always appear on the left no matter where they are defined within the flow of the document.

If you are creating a dashboard with multiple pages, you may want to use a single sidebar that applies across all pages. In this case, you should define the sidebar using a _first-level_ Markdown header.

### Learning more

Below are some good resources for learning more about Shiny and creating interactive documents:

1. The official Shiny website (http://shiny.rstudio.com) includes extensive articles, tutorials, and examples to help you learn more about Shiny.

1. The article "[Introduction to Interactive Documents](http://shiny.rstudio.com/articles/interactive-docs.html)" on the Shiny website is a great guide for getting started with Shiny and R Markdown.

1. For deploying interactive documents, you may consider Shiny Server or RStudio Connect: https://www.rstudio.com/products/shiny/shiny-server/.

<!--chapter:end:05-dashboards.Rmd-->

# Tufte Handouts

The Tufte handout\index{Tufte handout} style is a style that [Edward Tufte](https://en.wikipedia.org/wiki/Edward_Tufte) uses in his books and handouts. Tufte's style is known for its extensive use of sidenotes, tight integration of graphics with text, and well-set typography. This style has been implemented in LaTeX and HTML/CSS,^[See Github repositories https://github.com/tufte-latex/tufte-latex and https://github.com/edwardtufte/tufte-css.] respectively. Both implementations have been ported into the **tufte** package [@R-tufte]. If you want LaTeX/PDF output, you may use the `tufte_handout` format for handouts, and `tufte_book` for books. For HTML output, use `tufte_html`, e.g.,

```yaml
---
title: "An Example Using the Tufte Style"
author: "John Smith"
output:
  tufte::tufte_handout: default
  tufte::tufte_html: default
---
```

Figure \@ref(fig:tufte-overview) shows the basic layout of the Tufte style, in which you can see a main column on the left that contains the body of the document, and a side column on the right to display sidenotes.

```{r tufte-overview, echo=FALSE, fig.cap='The basic layout of the Tufte style.', out.width='100%'}
knitr::include_graphics('images/tufte-overview.png', dpi = NA)
```

There are two goals for the **tufte** package:

1. To produce both PDF and HTML output with similar styles from the same R Markdown document.

1. To provide simple syntax to write elements of the Tufte style such as side notes and margin figures. For example, when you want a margin figure, all you need to do is the chunk option `fig.margin = TRUE`, and **tufte** will take care of the details for you, so you never need to think about LaTeX environments like `\begin{marginfigure} \end{marginfigure}` or HTML tags like `<span class="marginfigure"> </span>`; the LaTeX and HTML code under the hood may be complicated, but you never need to learn or write such code.

You can use the wizard in RStudio IDE from the menu `File -> New File -> R Markdown -> From Template` to create a new R Markdown document with a default example provided by the **tufte** package. Note that you need a LaTeX distribution if you want PDF output (see Chapter \@ref(installation)).

## Headings {#tufte-headings}

The Tufte style provides the first and second-level headings (that is, `#` and `##`), demonstrated in the next section. You may get unexpected output (and even errors) if you try to use `###` and smaller headings.

In his later books,^[Such as "Beautiful Evidence": http://www.edwardtufte.com/tufte/books_be.], Tufte starts each section with a bit of vertical space, a non-indented paragraph, and sets the first few words of the sentence in small caps. To accomplish this using this style, call the `newthought()` function in **tufte** in an _inline R expression_ `` `r ` ``. Note that you should not assume **tufte** has been attached to your R session. You should either use `library(tufte)` in your R Markdown document before you call `newthought()`, or use `tufte::newthought()`.

## Figures {#tufte-figures}

### Margin figures

Images and graphics play an integral role in Tufte's work. To place figures in the margin, you can use the **knitr** chunk option `fig.margin = TRUE`. For example:

````markdown
`r ''````{r fig-margin, fig.margin=TRUE}
plot(cars)
```
````

As in other Rmd documents, you can use the `fig.cap` chunk option to provide a figure caption, and adjust figure sizes using the `fig.width` and `fig.height` chunk options, which are specified in inches, and will be automatically scaled down to fit within the handout margin.

Figure \@ref(fig:tufte-margin) shows what a margin figure looks like.

```{r tufte-margin, echo=FALSE, fig.cap='A margin figure in the Tufte style.', out.width='100%'}
knitr::include_graphics('images/tufte-margin.png', dpi = NA)
```

### Arbitrary margin content

You can include anything in the margin using the **knitr** engine named `marginfigure`. Unlike R code chunks ```` ```{r} ````, you write a chunk starting with ```` ```{marginfigure} ```` instead, then put the content in the chunk, e.g.,

````markdown
`r ''````{marginfigure}
We know from _the first fundamental theorem of calculus_ that
for $x$ in $[a, b]$:
$$\frac{d}{dx}\left( \int_{a}^{x} f(u)\,du\right)=f(x).$$
```
````

For the sake of portability between LaTeX and HTML, you should keep the margin content as simple as possible (syntax-wise) in the `marginfigure` blocks. You may use simple Markdown syntax like `**bold**` and `_italic_` text, but please refrain from using footnotes, citations, or block-level elements (e.g., blockquotes and lists) there.

Note that if you set `echo = FALSE` in your global chunk options, you will have to add `echo = TRUE` to the chunk to display a margin figure, for example ```` ```{marginfigure, echo = TRUE} ````.

### Full-width figures

You can arrange for figures to span across the entire page by using the chunk option `fig.fullwidth = TRUE`, e.g.,

````markdown
`r ''````{r, fig.width=10, fig.height=2, fig.fullwidth=TRUE}
par(mar = c(4, 4, .1, .2)); plot(sunspots)
```
````

Other chunk options related to figures can still be used, such as `fig.width`, `fig.cap`, and `out.width`, etc. For full-width figures, usually `fig.width` is large and `fig.height` is small. In the above example, the plot size is 10x2.

Figure \@ref(fig:tufte-full) shows what a full-width figure looks like.

```{r tufte-full, echo=FALSE, fig.cap='A full-width figure in the Tufte style.', out.width='100%'}
knitr::include_graphics('images/tufte-full.png', dpi = NA)
```

### Main column figures

Besides margin and full-width figures, you can certainly also include figures constrained to the main column. This is the default type of figures in the LaTeX/HTML output, and requires no special chunk options.

Figure \@ref(fig:tufte-main) shows what a figure looks like in the main column.

```{r tufte-main, echo=FALSE, fig.cap='A figure in the main column in the Tufte style.', out.width='100%'}
knitr::include_graphics('images/tufte-main.png', dpi = NA)
```

## Sidenotes {#tufte-sidenotes}

One of the most prominent and distinctive features of this style is the extensive use of sidenotes. There is a wide margin to provide ample room for sidenotes and small figures. Any use of a footnote, of which the Markdown syntax is `^[footnote content]`, will automatically be converted to a sidenote.

If you would like to place ancillary information in the margin without the sidenote mark (the superscript number), you can use the `margin_note()` function from **tufte** in an inline R expression. This function does not process the text with Pandoc, so Markdown syntax will not work here. If you need to write anything in Markdown syntax, please use the `marginfigure` block described previously.

## References {#tufte-references}

References can be displayed as margin notes for HTML output. To enable this feature, you must set `link-citations: yes` in the YAML metadata, and the version of `pandoc-citeproc` should be at least 0.7.2. To check the version of `pandoc-citeproc` in your system, you may run this in R:

```{r eval=FALSE}
system2('pandoc-citeproc', '--version')
```

If your version of `pandoc-citeproc` is too low, or you did not set `link-citations: yes` in YAML, references in the HTML output will be placed at the end of the output document.

You can also explicitly disable this feature via the `margin_references` option, e.g.,

```yaml
---
output:
  tufte::tufte_html:
    margin_references: false
---
```

## Tables {#tufte-tables}

You can use the `kable()` function from the **knitr** package to format tables that integrate well with the rest of the Tufte handout style. The table captions are placed in the margin like figures in the HTML output. A simple example (Figure \@ref(fig:tufte-table) shows the output):

````markdown
`r ''````{r}
knitr::kable(
  mtcars[1:6, 1:6], caption = 'A subset of mtcars.'
)
```
````

```{r tufte-table, echo=FALSE, fig.cap='A table in the Tufte style.', out.width='100%'}
knitr::include_graphics('images/tufte-table.png', dpi = NA)
```

## Block quotes {#tufte-quotes}

We know from the Markdown syntax that paragraphs that start with `>` are converted to block quotes. If you want to add a right-aligned footer for the quote, you may use the function `quote_footer()` from **tufte** in an inline R expression. Here is an example:

````markdown
> "If it weren't for my lawyer, I'd still be in prison.
>  It went a lot faster with two people digging."
>
> `r "\x60r tufte::quote_footer('--- Joe Martin')\x60"`
````

## Responsiveness {#tufte-responsiveness}

The HTML page is responsive in the sense that when the page width is smaller than 760px, sidenotes and margin notes will be hidden by default. For sidenotes, you can click their numbers (the superscripts) to toggle their visibility. For margin notes, you may click the circled plus signs to toggle visibility (see Figure \@ref(fig:tufte-responsive)).

```{r tufte-responsive, echo=FALSE, fig.cap='The Tufte HTML style on narrow screens.', out.width='100%'}
knitr::include_graphics('images/tufte-responsive.png', dpi = NA)
```

## Sans-serif fonts and epigraphs {#tufte-sans}

There are a few other things in Tufte CSS that we have not mentioned so far. If you prefer sans-serif fonts, use the function `sans_serif()` in **tufte**. For epigraphs, you may use a pair of underscores to make the paragraph italic in a block quote, e.g.,

````markdown
> _I can win an argument on any topic, against any opponent.
>  People know this, and steer clear of me at parties. Often,
>  as a sign of their great respect, they don't even invite me._
>
> `r "\x60r quote_footer('--- Dave Barry')\x60"`
````

## Customize CSS styles {#tufte-css}

You can turn on/off some features of the Tufte style in HTML output. The default features enabled are:

```yaml
---
output:
  tufte::tufte_html:
    tufte_features: ["fonts", "background", "italics"]
---
```

If you do not want the page background to be lightyellow, you can remove `background` from `tufte_features`. You can also customize the style of the HTML page via a CSS file. For example, if you do not want the subtitle to be italic, you can define

```css
h3.subtitle em {
  font-style: normal;
}
```

in, say, a CSS file `my-style.css` (under the same directory of your Rmd document), and apply it to your HTML output via the `css` option, e.g.,

```yaml
---
output:
  tufte::tufte_html:
    tufte_features: ["fonts", "background"]
    css: "my-style.css"
---
```

There is also a variant of the Tufte style in HTML/CSS named "[Envisioned CSS](http://nogginfuel.com/envisioned-css/)". This style can be enabled by specifying the argument `tufte_variant = 'envisioned'` in `tufte_html()`,^[The actual Envisioned CSS was not used in the **tufte** package. Only the fonts, background color, and text color are changed based on the default Tufte style.], e.g.,

```yaml
---
output:
  tufte::tufte_html:
    tufte_variant: "envisioned"
---
```

You can see a live example at https://rstudio.github.io/tufte/. It is also available in Simplified Chinese: https://rstudio.github.io/tufte/cn/, and its `envisioned` style can be found at https://rstudio.github.io/tufte/envisioned/.

<!--chapter:end:06-tufte.Rmd-->

# xaringan Presentations {#xaringan}

We have introduced a few HTML5 presentation formats in Chapter \@ref(presentations). The **xaringan** package [@R-xaringan]\index{xaringan} is an R Markdown extension based on the JavaScript library remark.js (https://remarkjs.com) to generate HTML5 presentations\index{HTML5 slides} of a different style. See Figure \@ref(fig:xaringan-sample) for two sample slides.

```{r xaringan-sample, echo=FALSE, fig.cap='Two sample slides created from the xaringan package.', out.width='49%', fig.show='hold'}
knitr::include_graphics(c('images/xaringan-1.png', 'images/xaringan-2.png'), dpi = NA)
```

The name "xaringan" came from Sharingan (http://naruto.wikia.com/wiki/Sharingan) in the Japanese manga and anime "Naruto". The word was deliberately chosen to be difficult to pronounce for most people (unless you have watched the anime), because its author (me) loved the style very much, and was concerned that it would become too popular.^[The main reason I stopped using LaTeX Beamer slides was because of its popularity: when you attend academic conferences, you see Beamer slides everywhere.] The concern was somewhat naive, because the style is actually very customizable, and users started to contribute more themes to the package later.

The **xaringan** package is based on the JavaScript library remark.js (https://remarkjs.com); remark.js only supports Markdown, and **xaringan** added the support for R Markdown as well as other utilities to make it easier to build and preview slides.

You can learn more about the background stories and the usage of the **xaringan** package from the documentation at http://slides.yihui.name/xaringan/, which is actually a set of slides generated from **xaringan**. You may also read a potentially biased blog post of mine to know why I preferred **xaringan** / remark.js for HTML5 presentations: https://yihui.name/en/2017/08/why-xaringan-remark-js/.

## Get started {#xaringan-start}

You can install either the CRAN version or the development version on GitHub (https://github.com/yihui/xaringan):

```r
# install from CRAN
install.packages('xaringan')

# or GitHub
devtools::install_github('yihui/xaringan')
```

If you use RStudio, it is easy to get started from the menu `File -> New File -> R Markdown -> From Template -> Ninja Presentation`, and you will see an R Markdown example in the editor. Press the `Knit` button to compile it, or use the RStudio addin `Infinite Moon Reader` to live preview the slides: every time you update and save the Rmd document, the slides will be automatically reloaded.

The main R Markdown output format in this package is `moon_reader()`. See the R help page `?xaringan::moon_reader` for all possible configurations. Below is a quick example:

```yaml
---
title: "Presentation Ninja"
subtitle: "with xaringan"
author: "Yihui Xie"
date: "2016/12/12"
output:
  xaringan::moon_reader:
    lib_dir: libs
    nature:
      highlightStyle: github
      countIncrementalSlides: false
---

One slide.

---

Another slide.
```

## Keyboard shortcuts {#xaringan-key}

After opening slides generated from **xaringan** or remark.js, you may press the key `h` (Help) or `?` on your keyboard to learn all possible keyboard shortcuts, which may help you better present your slides.

- To go the previous slide, you may press `Up`/`Left` arrows, `PageUp`, or `k`.

- To go the next slide, you may press `Right`/`Down` arrows, `PageDown`, `Space`, or `j`.

- You may press `Home` to go to the first slide, or `End` to go to the last slide, if you have these keys.

- Typing a number and pressing `Return` (or `Enter`), you can jump to a specific slide with that page number.

- Press `b` to black out a slide, and `m` to "mirror" a slide (reverse everything on the slide). These techniques can be useful when you do not want the audience to read the slide, e.g., when you have solutions on a slide but do not want to show them to your students immediately. I encourage you to try `m`; it can be a lot of fun. You can press these keys again to resume the normal slide.

- Press `f` to toggle the fullscreen mode.

- Press `c` to clone the slides to a new browser window; slides in the two windows will be in sync as you navigate through them. Press `p` to toggle the presenter mode. The presenter mode shows thumbnails of the current slide and the next slide on the left, presenter notes on the right (see Section \@ref(xaringan-notes)), and also a timer on the top right. The keys `c` and `p` can be very useful when you present with your own computer connected to a second screen (such as a projector). On the second screen, you can show the normal slides, while cloning the slides to your own computer screen and using the presenter mode. Only you can see the presenter mode, which means only you can see presenter notes and the time, and preview the next slide. You may press `t` to restart the timer at any time.

- Press `h` or `?` again to exit the help page.

## Slide formatting {#xaringan-format}

The [remark.js Wiki](https://github.com/gnab/remark/wiki) contains detailed documentation about how to format slides and use the presentation (keyboard shortcuts). The **xaringan** package has simplified several things compared to the official remark.js guide, e.g., you do not need a boilerplate HTML file, you can set the autoplay mode via an option of `moon_reader()`, and LaTeX math basically just works.

Please note that remark.js has its own Markdown interpreter that is _not compatible_ with Pandoc's Markdown converter, so you will not be able to use any advanced Pandoc Markdown features (e.g., the citation syntax `[@key]`). You may use raw HTML when there is something you desire that is not supported by remark.js. For example, you can generate an HTML table via `knitr::kable(head(iris), 'html')`.

### Slides and properties

Every new slide is created under three dashes (`---`). The dashes must be directly followed by a line break, and there must not be any other characters after the dashes (not even white spaces). When you see that you new slide appear on the previous slide after a horizontal rule, [you might have white spaces after the three dashes](https://yihui.org/en/2018/07/yue-jiang/) (if so, you have to delete them).

The content of the slide can be arbitrary, e.g., it does not have to have a slide title, and if it does, the title can be of any level you prefer (`#`, `##`, or `###`).

A slide can have a few properties, including `class` and `background-image`, etc. Properties are written in the beginning of a slide, e.g.,

```markdown
---

class: center, inverse
background-image: url("images/cool.png")

# A new slide

Content.
```

The `class` property assigns class names to the HTML tag of the slide, so that you can use CSS to style specific slides. For example, for a slide with the `inverse` class, you may define the CSS rules (to render text in white on a dark background):

```css
.inverse {
  background-color: #272822;
  color: #d6d6d6;
  text-shadow: 0 0 20px #333;
}
```

Then include the CSS file (say, `my-style.css`) via the `css` option of `xaringan::moon_reader`:

```yaml
---
output:
  xaringan::moon_reader:
    css: "my-style.css"
---
```

Actually the style for the `inverse` class has been defined in the default theme of **xaringan**, so you do not really need to define it again unless you want to override it.

Other available class names are `left`, `center`, and `right` for the horizontal alignment of all elements on a slide, and `top`, `middle`, and `bottom` for the vertical alignment.

Background images can be set via the `background-image` property. The image can be either a local file or an online image. The path should be put inside `url()`, which is the CSS syntax. You can also set the background image size and position, e.g.,

```yaml
background-image: url("`r '\x60r xaringan:::karl\x60'`")
background-position: center
background-size: contain
```

All these properties require you to understand CSS.^[There are many tutorials online if you search for "CSS background", e.g., https://www.w3schools.com/cssref/css3_pr_background.asp.] In the above example, we actually used an inline expression `xaringan::karl` to return a URL of an image of Karl Broman (http://kbroman.org), which is one of the highlights of the **xaringan** package.

### The title slide

There is a special slide, the title slide, that is automatically generated from the YAML metadata of your Rmd document. It contains the title, subtitle, author, and date (all are optional). This slide has the classes `inverse`, `center`, `middle`, and `title-slide` by default, which looks like the left image in Figure \@ref(fig:xaringan-sample). If you do not like the default style, you may either customize the `.title-slide` class, or provide a custom vector of classes via the `titleSlideClass` option under the `nature` option, e.g.,

```yaml
---
output:
  xaringan::moon_reader:
    nature:
      titleSlideClass: ["right", "top", "my-title"]
---
```

You can also disable the automatic title slide via the `seal` option and create one manually by yourself:

```yaml
---
output:
  xaringan::moon_reader:
    seal: false
---

# My Own Title

### Author

Whatever you want to put on the title slide.
```

### Content classes

You can assign classes to any elements on a slide, too. The syntax is `.className[content]`. This is a very powerful feature of remark.js, and one of very few features not available in Pandoc. Basically it makes it possible to style any elements on a slide via CSS. There are a few built-in content classes, `.left[ ]`, `.center[ ]`, and `.right[ ]`, to align elements horizontally on a slide, e.g., you may center an image:

```markdown
.center[![description of the image](images/foo.png)]
```

The content inside `[ ]` can be anything, such as several paragraphs, or lists. The default theme of **xaringan** has provided four more content classes:

- `.left-column[ ]` and `.right-column[ ]` provide a sidebar layout. The left sidebar is narrow (20% of the slide width), and the right column is the main column (75% of the slide width). If you have multiple level-2 (`##`) or level-3 (`###`) headings in the left column, the last heading will be highlighted, with previous headings being grayed out.

- `.pull-left[ ]` and `.pull-right[ ]` provide a two-column layout, and the two columns are of the same width. Below is an example:

    ```markdown
    .pull-left[
    - One bullet.

    - Another bullet.
    ]

    .pull-right[
    ![an image](foo.png)
    ]
    ```

You can design your own content classes if you know CSS, e.g., if you want to make text red via `.red[ ]`, you may define this in CSS:

```css
.red { color: red; }
```

### Incremental slides

When you want to show content incrementally on a slide (e.g., holding a funny picture until the last moment), you can use two dashes to separate the content. The two dashes can appear anywhere except inside content classes, so you can basically split your content in any way you like, e.g.,

```markdown
---

# Two dashes

The easiest way to build incremental slides is...
--
 to use two dashes `--` to separate content on a slide.

--

You can divide a slide in _any way you want_.

--

- One bullet

- Another bullet

--

- And one more

--

.center[
![Saw](https://slides.yihui.name/gif/saw-branch.gif)

Don't saw your slides too hard.
]
```

There are a few other advanced ways to build incremental slides documented in the presentation at https://slides.yihui.name/xaringan/incremental.html.

### Presenter notes {#xaringan-notes}

You can write notes for yourself to read in the presenter mode (press the keyboard shortcut `p`). These notes are written under three question marks `???` after a slide, and the syntax is also Markdown, which means you can write any elements supported by Markdown, such as paragraphs, lists, images, and so on. For example:

```markdown
---

The holy passion of Friendship is of so sweet and steady
and loyal and enduring a nature that it will last through
a whole lifetime...

???

_if not asked to lend money_.

--- Mark Twain
```

A common mistake in presentations, especially for presenters without much experience, is to stuff a slide with too much content. The consequence is either a speaker, out of breath, reading the so many words out loud, or the audience starting to read the slides quietly by themselves without listening. Slides are not papers or books, so you should try to be brief in the visual content of slides but verbose in verbal narratives. If you have a lot to say about a slide, but cannot remember everything, you may consider using presenter notes.

I want to mention a technical note about the presenter mode: when connecting to a projector, you should make sure not to mirror the two screens. Instead, separate the two displays, so you can drag the window with the normal view of slides to the second screen. Figure \@ref(fig:mirror-display) shows how to do it from the "System Preferences" on macOS (do not check the box "Mirror Displays").

```{r mirror-display, echo=FALSE, fig.cap='Separate the current display from the external display.', out.width='100%'}
knitr::include_graphics('images/mirror-display.png', dpi = NA)
```

### yolo: true

Inspired by a random feature request from [a tweet by Karthik Ram](https://twitter.com/_inundata/status/798970002992873472), the output format `xaringan::moon_reader` provided an option named `yolo` (an acronym of "you only live once"). If you set it to true, a photo of Karl Broman\index{Karl Broman} (with a mustache) will be inserted into a random slide in your presentation.^[For the full story behind the mustache, see Karl's post at http://kbroman.org/blog/2014/08/28/the-mustache-photo/.]

```yaml
---
output:
  xaringan::moon_reader:
    yolo: true
---
```

The **xaringan** package is probably best known for this feature. I want to thank Karl for letting me use this photo. It always makes me happy for mysterious reasons.

A less well-known feature is that you can actually replace Karl's picture with other pictures,^[In case you are also interested in Karl's great grandfather's mustache, you can find a picture at https://twitter.com/kwbroman/status/1199142650185691137.] and/or specify how many times you want a picture to randomly show up in your presentation. For example:

```yaml
---
output:
  xaringan::moon_reader:
    yolo:
      img: kangaroo.jpg
      times: 5
---
```

Developing software is fun, isn't it?

## Build and preview slides {#xaringan-preview}

You can knit the source document like other Rmd documents to view the output, but it may be tedious to have to knit it over and over again whenever you make changes. The other way to preview the slides is the RStudio addin "Infinite Moon Reader" or the function `xaringan::inf_mr()`, as mentioned in Section \@ref(compile). With this way, you can continuously preview your slides just by saving the source document. The continuous preview is achieved via a local web server launched by the **servr** package [@R-servr].

One distinction of `xaringan::moon_reader` when compared to other R Markdown output formats is that it does not generate self-contained HTML documents by default (see Section \@ref(document-dependencies)). This means none of the external dependencies such as images or JavaScript libraries will be embedded in the HTML output file by default. You can turn the self-contained mode on via:

```yaml
output:
  xaringan::moon_reader:
    self_contained: true
```

Due to technical difficulties (remark.js does not use Pandoc but renders Markdown in real time in the browser), it is challenging to implement the self-contained mode really well. Currently, most JavaScript libraries (including remark.js) and CSS files should be correctly embedded in the self-contained mode. Images in slides should also be embedded. The paths of images in slides are identified from `![](PATH)` (Markdown syntax), `<img src="PATH" />` (HTML syntax), and `background-image: url(PATH)` (remark.js syntax for background images). Other types of images will not be discovered or embedded.

If you have to publish the slides to a web server, but **xaringan**'s self-contained mode fails to identify certain resources and embed them, please feel free to file an issue to the GitHub repository at https://github.com/yihui/xaringan. If you publish slides to GitHub Pages or Netlify, this may not be a problem, because you can commit or upload all resources files generated or required by the slides.

## CSS and themes

The format `xaringan::moon_reader` has a `css` option, to which you can pass a vector of CSS\index{CSS} file paths, e.g.,

```yaml
---
output:
  xaringan::moon_reader:
    css: ["default", "extra.css"]
---
```

In theory, the file path should contain the extension `.css`. If a path does not contain a filename extension, it is assumed to be a built-in CSS file in the **xaringan** package. For example, `default` in the above example means `default.css` in the package under the path `xaringan:::pkg_resource()`. To see all built-in CSS files, call `xaringan:::list_css()` in R.

When you only want to override a few CSS rules in the default theme, you do not have to copy the whole file `default.css`; instead, create a new (and hopefully smaller) CSS file that only provides new CSS rules.

Users have contributed a few themes to **xaringan**. For example, you can use the `metropolis` theme (https://github.com/pat-s/xaringan-metropolis):

```yaml
---
output:
  xaringan::moon_reader:
    css: [default, metropolis, metropolis-fonts]
---
```

To see all possible themes:

```{r}
names(xaringan:::list_css())
```

If you also want to contribute themes, please read the guide at https://yihui.name/en/2017/10/xaringan-themes.

## Some tips

Lastly, we present a few tips that may help you make better presentations.

### Autoplay slides

Slides can be automatically played if you set the `autoplay` option under `nature` (in milliseconds). For example, the next slide can be displayed automatically every 30 seconds in a lightning talk:

```yaml
---
output:
  xaringan::moon_reader:
    nature:
      autoplay: 30000
---
```

### Countdown timer

A countdown timer can be added to every page of the slides using the `countdown` option under `nature`. For example, if you want to spend one minute on every page when you give the talk, you can set:

```yaml
---
output:
  xaringan::moon_reader:
    nature:
      countdown: 60000
---
```

Then you will see a timer counting down from `01:00`, to `00:59`, `00:58`, ... When the time is out, the timer will continue but the time turns red.

### Highlight code lines

The option `highlightLines: true` of `nature` will highlight code lines that start with `*`, or are wrapped in `{{ }}`, or have trailing comments `#<<`:

```yaml
---
output:
  xaringan::moon_reader:
    nature:
      highlightLines: true
---
```

Below are a few examples:

````markdown
```r
if (TRUE) {
* message("Very important!")
}
```

`r ''````{r tidy=FALSE}
if (TRUE) {
{{ message("Very important!") }}
}
```

`r ''````{r tidy=FALSE}
library(ggplot2)
ggplot(mtcars) +
  aes(mpg, disp) +
  geom_point() +   #<<
  geom_smooth()    #<<
```
````

Note that the first way does not give you valid R code in the source document, but the latter two ways provide syntactically valid R code, and in the output slides, you will not see the tokens `{{ }}` or `#<<`. The lines will be highlighted with a yellow background by default.

### Working offline

To make slides work offline, you need to download a copy of remark.js in advance, because **xaringan** uses the online version by default. You can use `xaringan::summon_remark()` to download the latest or a specified version of remark.js. By default, it is downloaded to `libs/remark-latest.min.js`.

Then change the `chakra` option in the YAML metadata to point to this file, e.g.,

```yaml
output:
  xaringan::moon_reader:
    chakra: libs/remark-latest.min.js
```

Making the slides work offline can be tricky, since you may have other dependencies. The remark.js dependency is easy to deal with because it is a single JavaScript file; other dependencies such as MathJax can be extremely tricky. If you used Google web fonts in slides (the default theme uses _Yanone Kaffeesatz_, _Droid Serif_, and _Source Code Pro_), they will not work offline unless you download or install them locally. The Heroku app [google-webfonts-helper](https://google-webfonts-helper.herokuapp.com/fonts) can help you download fonts and generate the necessary CSS.

### Macros

The Markdown syntax of remark.js can be amazingly extensible, because it allows users to define custom macros (JavaScript functions) that can be applied to Markdown text using the syntax `![:macroName arg1, arg2, ...]` or `![:macroName arg1, arg2](this)`. For example, you can define a macro named `scale` to set the width of an image:

```js
remark.macros.scale = function(w) {
  var url = this;
  return '<img src="' + url + '" style="width: ' + w + '" />';
};
```

Then the Markdown text

```markdown
![:scale 50%](image.jpg)
```

will be translated to:

```html
<img src="image.jpg" style="width: 50%" />
```

Now you should see that you can use cleaner pseudo-Markdown syntax to generate HTML.

To insert macros in **xaringan** slides, you can save your macros in a file (e.g., `macros.js`), and use the option `beforeInit` under the option `nature`, e.g.,

```yaml
output:
  xaringan::moon_reader:
    nature:
      beforeInit: "macros.js"
```

The `beforeInit` option can be used to insert arbitrary JavaScript code before remark.js initializes the slides. Inserting macros is just one of its possible applications. For example, when you embed tweets from Twitter in slides, usually you need to load `https://platform.twitter.com/widgets.js`, which can be loaded via the `beforeInit` option.

### Disadvantages

The **xaringan** package was originally designed for "ninja", meaning that if you know CSS, you will be able to freely customize the style, otherwise you can only accept the default themes. Playing with CSS can be fun and rewarding, but it can also easily waste your time. Your aesthetic standards and taste may change from time to time, and you could end up tweaking the styles all the time.

The HTML output file generated from **xaringan** is not self-contained by default, as we mentioned in Section \@ref(xaringan-preview). The self-contained mode of **xaringan** may not work perfectly.

HTML widgets may not work well in **xaringan**. This might be improved in the future, but it is a little tricky technically.

When printing the slides to PDF from Google Chrome (see Section \@ref(printing-and-pdf-output)), I recommend that you open the slides and go through all pages at least once, to make sure all content has been rendered in the browser. Without navigating through all slides manually once, some content may not be printed correctly (such as MathJax expressions and HTML widgets).

<!--chapter:end:07-xaringan.Rmd-->

# reveal.js Presentations {#revealjs}

The **revealjs** package [@R-revealjs] provides an output format `revealjs::revealjs_presentation` that can be used to create yet another style of HTML5 slides\index{HTML5 slides} based on the JavaScript library [reveal.js](https://revealjs.com). You may install the R package from CRAN:

```r
install.packages("revealjs")
```

To create a reveal.js presentation from R Markdown, you specify the `revealjs_presentation` output format in the YAML metadata of your document. You can create a slide show broken up into sections by using the `#` and `##` heading tags; you can also create a new slide without a header using a horizontal rule (`---`). For example, here is a simple slide show:

```markdown
---
title: "Habits"
author: John Doe
date: March 22, 2005
output: revealjs::revealjs_presentation
---

# In the morning

## Getting up

- Turn off alarm
- Get out of bed

## Breakfast

- Eat eggs
- Drink coffee

# In the evening

## Dinner

- Eat spaghetti
- Drink wine

## Going to sleep

- Get in bed
- Count sheep
```

See Figure \@ref(fig:revealjs-sample) for two sample slides.

```{r revealjs-sample, echo=FALSE, fig.cap='Two sample slides created from the revealjs package.', out.width='49%', fig.show='hold'}
knitr::include_graphics(c('images/revealjs-1.png', 'images/revealjs-2.png'), dpi = NA)
```

## Display modes

The following single character keyboard shortcuts enable alternate display modes:

- `'f'`: enable fullscreen mode.

- `'o'`: enable overview mode.

Pressing `Esc` exits all of these modes.

## Appearance and style

There are several options that control the appearance of reveal.js presentations:

- `theme` specifies the theme to use for the presentation (available themes are `"default"`, `"simple"`, `"sky"`, `"beige"`, `"serif"`, `"solarized"`, `"blood"`, `"moon"`, `"night"`, `"black"`, `"league"`, and `"white"`).

- `highlight` specifies the syntax highlighting style. Supported styles include `"default"`, `"tango"`, `"pygments"`, `"kate"`, `"monochrome"`, `"espresso"`, `"zenburn"`, and `"haddock"`. Pass null to prevent syntax highlighting.

- `center` specifies whether you want to vertically center content on slides (this defaults to `false`).

- `smart` indicates whether to produce typographically correct output, converting straight quotes to curly quotes, `---` to em-dashes, `--` to en-dashes, and `...` to ellipses. Note that `smart` is enabled by default.

For example:

```yaml
---
output:
  revealjs::revealjs_presentation:
    theme: sky
    highlight: pygments
    center: true
---
```

### Smaller text

If you need smaller text for certain paragraphs, you can enclose text in the `<small>` tag. For example:

```html
<small>This sentence will appear smaller.</small>
```

## Slide transitions

You can use the `transition` and `background_transition` options to specify the global default slide transition style:

- `transition` specifies the visual effect when moving between slides. Available transitions are `"default"`, `"fade"`, `"slide"`, `"convex"`, `"concave"`, `"zoom"` or `"none"`.

- `background_transition` specifies the background transition effect when moving between full page slides. Available transitions are `"default"`, `"fade"`, `"slide"`, `"convex"`, `"concave"`, `"zoom"` or `"none"`.

For example:

```yaml
---
output:
  revealjs::revealjs_presentation:
    transition: fade
---
```

You can override the global transition for a specific slide by using the `data-transition` attribute. For example:

```markdown
## Use a zoom transition {data-transition="zoom"}

## Use a faster speed {data-transition-speed="fast"}
```

You can also use different in and out transitions for the same slide. For example:

```markdown
## Fade in, Slide out {data-transition="slide-in fade-out"}

## Slide in, Fade out {data-transition="fade-in slide-out"}
```

## Slide backgrounds

Slides are contained within a limited portion of the screen by default to allow them to fit any display and scale uniformly. You can apply full page backgrounds outside of the slide area by adding a `data-background` attribute to your slide header element. Four different types of backgrounds are supported: `color`, `image`, `video`, and `iframe`. Below are a few examples.

```markdown
## CSS color background {data-background=#ff0000}

## Full size image background {data-background="background.jpeg"}

## Video background {data-background-video="background.mp4"}

## A background page {data-background-iframe="https://example.com"}
```

Backgrounds transition using a `fade` animation by default. This can be changed to a linear sliding transition by specifying the `background-transition: slide`. Alternatively, you can set `data-background-transition` on any slide with a background to override that specific transition.

## 2-D presentations

You can use the `slide_level` option to specify which level of heading will be used to denote individual slides. If `slide_level` is 2 (the default), a two-dimensional layout will be produced, with level-1 headers building horizontally and level-2 headers building vertically. For example:

```markdown
# Horizontal Slide 1

## Vertical Slide 1

## Vertical Slide 2

# Horizontal Slide 2
```

With this layout, horizontal navigation will proceed directly from "Horizontal Slide 1" to "Horizontal Slide 2", with vertical navigation to "Vertical Slide 1" (and then "Vertical Slide 2", etc.) presented as an option on "Horizontal Slide 1". See Figure \@ref(fig:revealjs-sample) for an example (note the arrows at the bottom right on the slides).

## Custom CSS

You can add your own CSS\index{CSS} to a reveal.js presentation using the `css` option:

```yaml
---
output:
  revealjs::revealjs_presentation:
    css: styles.css
---
```

If you want to override the appearance of particular HTML element document-wide, you need to qualify it with the `.reveal section` preface in your CSS. For example, to change the default text color in paragraphs to blue, you would use:

```css
.reveal section p {
  color: blue;
}
```

### Slide IDs and classes

You can also target specific slides or classes of slice with custom CSS by adding IDs or classes to the slides headers within your document. For example, the following slide header

```markdown
## Next Steps {#nextsteps .emphasized}
```

would enable you to apply CSS to all of its content using either of the following CSS selectors:

```css
#nextsteps {
   color: blue;
}

.emphasized {
   font-size: 1.2em;
}
```

### Styling text spans

You can apply classes defined in your CSS file to spans of text by using a `span` tag. For example:

```html
<span class="emphasized">Pay attention to this!</span>
```

## reveal.js options

Reveal.js has many additional options to configure its behavior. You can specify any of these options using `reveal_options`. For example:

```yaml
---
title: "Habits"
output:
  revealjs::revealjs_presentation:
    self_contained: false
    reveal_options:
      slideNumber: true
      previewLinks: true
---
```

You can find documentation on the various available reveal.js options here: <https://github.com/hakimel/reveal.js#configuration>.

## reveal.js plugins

You can enable various reveal.js plugins using the `reveal_plugins` option. Plugins currently supported plugins are listed in Table \@ref(tab:revealjs-plugins).

Table: (\#tab:revealjs-plugins) The currently supported reveal.js plugins.

| Plugin | Description  |
|----------------------------|---------------------------------------------|
| notes | Present per-slide notes in a separate browser window. |
| zoom | Zoom in and out of selected content with Alt+Click. |
| search | Find a text string anywhere in the slides and show the next occurrence to the user. |
| chalkboard | Include handwritten notes within a presentation. |

Note that the use of plugins requires that the `self_contained` option be set to `false`. For example, this presentation includes both the "notes" and "search" plugins:

```yaml
---
title: "Habits"
output:
  revealjs::revealjs_presentation:
    self_contained: false
    reveal_plugins: ["notes", "search"]
---
```

You can specify additional options for the `chalkboard` plugin using `reveal_options`. For example:

```yaml
---
title: "Habits"
output:
  revealjs::revealjs_presentation:
    self_contained: false
    reveal_plugins: ["chalkboard"]
    reveal_options:
      chalkboard:
        theme: whiteboard
        toggleNotesButton: false
---
```

## Other features

Refer to Section \@ref(html-document) for the documentation of other features of reveal.js presentations, including figure options (Section \@ref(figure-options)), MathJax equations (Section \@ref(mathjax-equations)), keeping Markdown (Section \@ref(keeping-markdown)), document dependencies (Section \@ref(document-dependencies)), header and before/after body inclusions (Section \@ref(includes)), custom templates (Section \@ref(custom-templates)), Pandoc arguments (Section \@ref(pandoc-arguments)), and shared options (Section \@ref(shared-options)). Also see Section \@ref(incremental-bullets) for incremental bullets.

<!--chapter:end:08-revealjs.Rmd-->

# Community Formats {#community}

Most output formats introduced in this book are created and maintained by the RStudio team. In fact, other members in the R community have also created a number of R Markdown output formats.\index{output formats} We mention those formats that we are aware of in this chapter. If you have developed or know other formats, please feel free to suggest that we add them to the page https://rmarkdown.rstudio.com/formats.html.

## Lightweight Pretty HTML Documents {#prettydoc}

When designing the **rmarkdown** package, we wished it could produce output documents that look pleasant by default, especially for HTML documents. Pandoc does not really style the HTML documents when converting Markdown to HTML, but **rmarkdown** does. As we mentioned in Section \@ref(appearance-and-style), the themes of HTML documents are based on Bootswatch, which actually relies on the Bootstrap library (https://getbootstrap.com). Although these themes look pretty, the major disadvantage is that their file sizes are relatively large. The size of an HTML document created from an empty R Markdown document with the `html_document` format is about 600Kb, which is roughly the total size of all CSS, JavaScript, and font files in the default theme.

If you are concerned about the file size but still want a fancy theme, you may consider the **prettydoc** package [@R-prettydoc], which has bundled a few pretty themes (yet small in size). This package provides an output format `prettydoc::html_pretty`. An empty R Markdown document with this format generates an HTML file of about 70Kb.

### Usage {#prettydoc-usage}

The usage of `prettydoc::html_pretty` is very similar to `html_document`, with two major differences:

- The `theme` option takes different values. The currently supported themes are `"cayman"`, `"tactile"`, `"architect"`, `"leonids"`, and `"hpstr"`. Figure \@ref(fig:prettydoc) shows the appearance of the `leonids` theme. See https://github.com/yixuan/prettydoc for screenshots of more themes.

- The `highlight` option takes `null`, `"github"`, or `"vignette"`.

Below is an example of the YAML metadata of an R Markdown document that uses the `prettydoc::html_pretty` output format:

```yaml
---
title: "Your Document Title"
author: "Document Author"
date: "2018-04-16"
output:
  prettydoc::html_pretty:
    theme: leonids
    highlight: github
---
```

```{r prettydoc, echo=FALSE, fig.cap='The leonids theme of the prettydoc package.', out.width='100%'}
knitr::include_graphics('images/prettydoc.png', dpi = NA)
```

### Package vignettes {#prettydoc-vignettes}

The `prettydoc::html_pretty` can be particularly useful for R package vignettes.\index{R package vignette} We have mentioned the `html_vignette` format in Section \@ref(r-package-vignette) that also aims at smaller file sizes, but that format is not as stylish. To apply the `prettydoc::html_pretty` format to a package vignette, you may use the YAML metadata below:

```yaml
---
title: "Vignette Title"
author: "Vignette Author"
output: prettydoc::html_pretty
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
```

Do not forget to change the vignette title, author, and the index entry. You should also add `prettydoc` to the `Suggests` field of your package `DESCRIPTION` file, and the two package names `knitr, rmarkdown` to the `VignetteBuilder` field.

## The rmdformats package {#rmdformats}

The **rmdformats** package [@R-rmdformats] provides several HTML output formats of unique and attractive styles, including:

- `material`: A format based on the [Material design theme for Bootstrap 3](https://github.com/FezVrasta/bootstrap-material-design). With this format, every first-level section will become a separate page. See Figure \@ref(fig:rmdformats-material) for what this format looks like ("Introduction" and "Including Plots" are two first-level sections).

- `readthedown`: It features a sidebar layout. The table of contents is displayed in the sidebar on the left. As you scroll on the page, the current section header will be automatically highlighted (and expanded if necessary) in the sidebar.

- `html_clean`: A simple and clean HTML template, with a dynamic table of contents at the top-right of the page.

- `html_docco`: A simple template inspired by [the Docco project](https://github.com/jashkenas/docco).

Do not forget the `rmdformats::` prefix when you use these formats, e.g.,

```yaml
---
output: rmdformats::material
---
```

```{r rmdformats-material, echo=FALSE, fig.cap='The Material Design theme in the rmdformats package.', out.width='100%'}
knitr::include_graphics('images/rmdformats-material.png', dpi = NA)
```

These output formats have some additional features such as responsiveness and code folding. Please refer to the GitHub repository of the **rmdformats** package for more information: https://github.com/juba/rmdformats.

## Shower presentations

Shower (https://github.com/shower/shower) is a popular and customizable HTML5 presentation\index{HTML5 slides} framework. See Figure \@ref(fig:shower) for what it looks like.

```{r shower, echo=FALSE, fig.cap='A few sample slides created via the Shower presentation framework.', out.width='100%'}
knitr::include_graphics('images/shower.png', dpi = NA)
```

The R package **rmdshower** (https://github.com/mangothecat/rmdshower) is built on top of Shower. You may install it from GitHub:

```{r eval=FALSE}
devtools::install_github("mangothecat/rmdshower")
```

You can create a Shower presentation with the output format `rmdshower::shower_presentation`, e.g.,

```yaml
---
title: "Hello Shower"
author: "John Doe"
output: rmdshower::shower_presentation
---
```

See the help page `?rmdshower::shower_presentation` for all possible options of this format.

<!--chapter:end:09-community.Rmd-->

# Websites

Most R Markdown applications are single documents. That is, you have a single R Markdown source document, and it generates a single output file. However, it is also possible to work with multiple Rmd documents in a project, and organize them in a meaningful way (e.g., pages can reference each other).

Currently there are two major ways to build multiple Rmd documents: **blogdown** [@xie2017; @R-blogdown] for building websites, and **bookdown** [@xie2016; @R-bookdown] for authoring books. In this chapter, we briefly introduce the **blogdown** package.\index{blogdown} For the full reference, please read the official **blogdown** book by @xie2017. In fact, the **rmarkdown** package also has a built-in site generator, which was not covered in detail by the **blogdown** book, so we will introduce it in Section \@ref(rmarkdown-site).

With **blogdown**, you can write a blog post or a general page in an Rmd document, or a plain Markdown document. These source documents will be built into a static website\index{static website}, which is essentially a folder containing static HTML files and associated assets (such as images and CSS files). You can publish this folder to any web server as a website. Because it is only a single folder, it can be easy to maintain. For example, you do not need to worry about databases as you do if you use dynamic systems like WordPress.

Because the website is generated from R Markdown, the content is more likely to be reproducible, and also easier to maintain (no cut-and-paste of results). Using Markdown means your content could be more portable in the sense that you may convert your pages to PDF or other formats in the future, and you are not tied to the default HTML format. For example, you may be able to convert a blog post to a journal paper, or several posts to a book. One more benefit of using **blogdown** is that the Markdown syntax is based on **bookdown**'s extended syntax, which means it is highly suitable for technical writing. For example, you may write math equations, insert figures or tables with captions, cross-reference them with figure or table numbers, add citations, and present theorems or proofs.

## Get started {#blogdown-start}

You can install **blogdown** from CRAN. If you want to test the development version, you may also install it from GitHub:

```r
# from CRAN
install.packages("blogdown")

# or the development version from GitHub
devtools::install_github("rstudio/blogdown")
```

The easiest way to get started with a **blogdown**-based website is to create a website project from RStudio: `File -> New Project`. If you do not use RStudio, you may call the function `blogdown::new_site()`.

The first time when you create a new website, **blogdown** will do a series of things behind the scenes: it downloads Hugo\index{Hugo} (the default static site generator), creates a website skeleton, installs a theme, adds some example posts, builds the site, and serves it so that you can see the website in your browser (or RStudio Viewer if you are in RStudio). It will not go through all these steps again the next time when you work on this website. All you need in the future is `blogdown::serve_site()`, or equivalently, the RStudio addin "Serve Site".

Every time you open a website project, you only need to serve the site once, and **blogdown** will keep running in the background, listening to changes in your source files, and rebuilding the website automatically. All you have to do is create new posts, or edit existing posts, and save them. You will see the automatic live preview as you save the changes (unless you have errors in a source document).

There are a few RStudio addins to help you author your posts: you can use the "New Post" addin to create a new post, the "Update Metadata" addin to update the YAML metadata of a post, and the "Insert Image" addin to insert an image in a post.

## The directory structure {#blogdown-directory}

The default site generator in **blogdown** is Hugo (https://gohugo.io). A basic Hugo website usually contains the following files and directories:

- `config.toml`
- `content/`
- `static/`
- `themes/`
- `public/`

The configuration file `config.toml` can be used to specify options for the Hugo website, e.g.,

```ini
baseURL = "/"
languageCode = "en-us"
title = "A Hugo website"
theme = "hugo-lithium-theme"
```

Some options are provided by Hugo itself, such as `title` and `baseURL`; you may refer to https://gohugo.io/getting-started/configuration/ for all built-in options. Some options are provided by the Hugo theme, and you need to read the documentation of the specific theme to know the additional options.

All source Markdown or R Markdown files should be placed under the `content/` directory. The directory structure under `content/` can be arbitrary.

The `static/` directory contains static assets such as images and CSS files. Everything under `static/` will be copied to the `public/` directory when Hugo generates the website. For example, `static/images/foo.png` will be copied to `public/images/foo.png`, and if you want to include this image in your post, you may use `![title](/images/foo.png)` in Markdown (the leading `/` typically indicates the root of `public/`).

You can download multiple themes to the `themes` directory. To activate a theme, specify its folder name in the `theme` option in `config.toml`. You can find a lot of Hugo themes from https://themes.gohugo.io. Remember, the best theme is always the next one, i.e., one that you have not used before. I recommend that you start with a simple theme (such as the default [hugo-lithium theme](https://github.com/yihui/hugo-lithium) in **blogdown**, [hugo-xmin](https://github.com/yihui/hugo-xmin), or [hugo-tanka](https://github.com/road2stat/hugo-tanka)), and write a substantial number of posts before seriously investing time in choosing or tweaking a theme.

After you serve a site using **blogdown**, your site will be continuously built to the `public/` directory by default. You can upload this folder to any web server to deploy the website. However, if you know GIT, there is an even easier way to publish your website, to be introduced in the next section.

Hugo is very powerful and customizable. If you want to learn more technical details about it, you may read Chapter 2 of the **blogdown** book.

## Deployment {#blogdown-deploy}

There are multiple ways to deploy a website, such as using your own web server, GitHub Pages, or Amazon S3. We only mention one in this chapter: Netlify (https://www.netlify.com). It provides both free and paid plans. For personal users, the free plan may be enough, because many useful features have been included in the free plan, e.g., the Hugo support, CDN (content delivery network) for high availability and performance of your website, HTTPS, binding your custom domain, and 301/302 redirects.

Netlify currently supports GitHub, GitLab, and Bitbucket. You may log in using one of these accounts at https://app.netlify.com, and create a new website from your GIT repository that contains the source of your website. Note that you do not need to commit or push the `public/` directory in GIT (in fact, I recommend that you ignore this directory in `.gitignore`).

When creating a new site on Netlify, you can specify the build command to be `hugo`, the publish directory to be `public` (unless you changed the setting `publishDir` in `config.toml`), and also add an environment variable `HUGO_VERSION` with a value of a suitable Hugo version (e.g., `0.39`). To find the Hugo version on your local computer, call the function `blogdown::hugo_version()`. You may want to use the same Hugo version on Netlify.

Netlify will assign a random subdomain of the form `xxx-xxx-1234.netlify.com` to you. You may change it to a meaningful domain name, or request a free `*.rbind.io` domain name from https://github.com/rbind/support/issues if you like it.

If possible, I strongly recommend that you enable HTTPS for your websites ([why?](https://https.cio.gov/everything/)). HTTPS is free on Netlify, so you really do not have a reason not to enable it.

Once your GIT repository is connected with Netlify, you only need to push source files to the repository in the future, and Netlify will automatically rebuild your website. This is called "continuous deployment".

## Other site generators {#blogdown-other}

Currently **blogdown** has limited support for two other popular site generators: [Jekyll](https://jekyllrb.com) and [Hexo](https://hexo.io). You can find detailed instructions on how to configure **blogdown** for these site generators in Chapter 5 of the **blogdown** book. Note that neither Pandoc's Markdown nor HTML widgets are supported if you use Jekyll or Hexo with **blogdown**.

## rmarkdown's site generator {#rmarkdown-site}

Before **blogdown** was invented, the **rmarkdown** package had provided a simple site generator that did not rely on a third-party site generator like Hugo. If you feel Hugo is too complex for you, and you only want to build a few Rmd documents into a website, this built-in site generator may be a good choice. A main restriction of this site generator is that it assumes all Rmd documents are under a flat directory (i.e., no pages under subdirectories). It also has fewer features compared to Hugo (e.g., no RSS feeds).

You can render collections of R Markdown documents as a website using the `rmarkdown::render_site()` function. We will call such websites "R Markdown websites" in this section. The RStudio IDE (version 1.0 or higher) also includes integrated support for developing R Markdown websites.

### A simple example

To start with, let's walk through a very simple example, a website that includes two pages (`Home` and `About`) and a navigation bar to switch between them.

First, we need a configuration file `_site.yml`:

```yaml
name: "my-website"
navbar:
  title: "My Website"
  left:
    - text: "Home"
      href: index.html
    - text: "About"
      href: about.html
```

Then two Rmd files, `index.Rmd`:

```markdown
---
title: "My Website"
---

Hello, Website!
```

and `about.Rmd`:

```markdown
---
title: "About This Website"
---

More about this website.
```

Note that the minimum requirement for any R Markdown website is that it have an `index.Rmd` file as well as a `_site.yml` file. If you execute the `rmarkdown::render_site()` function from within the directory containing the website, the following will occur:

1. All of the `*.Rmd` and `*.md` files in the root website directory will be rendered into HTML. Note, however, that Markdown files beginning with `_` are not rendered (this is a convention to designate files that are to be included by top level Rmd documents as child documents).

1. The generated HTML files and any supporting files (e.g., CSS and JavaScript) are copied into an output directory (`_site` by default).

The HTML files within the `_site` directory are now ready to deploy as a standalone static website.

The full source code for the simple example above can be found in the `hello-website` folder in the repository <https://github.com/rstudio/rmarkdown-website-examples>.

### Site authoring

#### RStudio

RStudio includes a variety of features intended to make developing R Markdown websites more productive.

All of the RStudio features for website authoring described below require the use of an RStudio Project tied to your website's directory. See the documentation on [RStudio Projects](https://support.rstudio.com/hc/en-us/articles/200526207-Using-Projects) for additional information on how to create and use projects.

As you work on the individual pages of your website, you can render them using the `Knit` button just as you do with conventional standalone R Markdown documents (see Figure \@ref(fig:site-page)).

```{r site-page, echo=FALSE, fig.cap='Knit a single page of a website.', out.width='100%'}
knitr::include_graphics('images/site-page.png', dpi = NA)
```

Knitting an individual page will only render and preview that page, not the other pages in the website.

To render all of the pages in the website, you use the `Build` pane, which calls `rmarkdown::render_site()` to build and then preview the entire site (see Figure \@ref(fig:site-build)).

```{r site-build, echo=FALSE, fig.cap='Build an entire website in RStudio.', out.width='100%'}
knitr::include_graphics('images/site-build.png', dpi = NA)
```

RStudio supports "live preview" of changes that you make to supporting files within your website (e.g., CSS, JavaScript, Rmd partials, R scripts, and YAML config files).

Changes to CSS and JavaScript files always result in a refresh of the currently active page preview. Changes to other files (e.g., shared scripts and configuration files) trigger a rebuild of the active page (this behavior can be disabled via the options dialog available from the `Build` pane).

Note that only the active page is rebuilt, so once you are happy with the results of rendering you should make sure to rebuild the entire site from the `Build` pane to ensure that all pages inherit your changes.

When working iteratively on a page, you might find it more convenient to preview it side-by-side with the editor rather than in an external window. You can configure RStudio to do this using the options menu on the editor toolbar (see Figure \@ref(fig:site-preview)).

```{r site-preview, echo=FALSE, fig.cap='Preview a page side-by-side with the editor in RStudio.', out.width='100%'}
knitr::include_graphics('images/site-preview.png', dpi = NA)
```

#### Command line

If you are not working within RStudio and/or want to build sites from the command line, you can call the `render_site()` function directly from within the website directory. Pass no arguments to render the entire site or a single file in order to render just that file:

```r
# render the entire site
rmarkdown::render_site()

# render a single file only
rmarkdown::render_site("about.Rmd")
```

To clean up all of the files generated via `render_site()`, you can call the `clean_site()` function, which will remove all files generated by rendering your site's Markdown documents, including **knitr**'s `*_cache` directories. You can specify the `preview = FALSE` option to just list the files to be removed rather than actually removing them:

```r
# list which files will be removed
rmarkdown::clean_site(preview = TRUE)

# actually remove the files
rmarkdown::clean_site()
```

#### knitr caching

If your website is time consuming to render, you may want to enable **knitr**'s caching during the development of the site, so that you can more rapidly preview. To enable caching for an individual chunk, just add the `cache = TRUE` chunk option:

````markdown
`r ''````{r, cache = TRUE}
data <- longComputation()
```
````

To enable caching for an entire document, add `cache = TRUE` to the global chunk option defaults:

````markdown
`r ''````{r setup, include=FALSE}
knitr::opts_chunk$set(cache = TRUE)
```
````

Note that when caching is enabled for an Rmd document, its `*_files` directory will be copied rather than moved to the `_site` directory (since the cache requires references to generated figures in the `*_files` directory).

### Common elements

#### Content

Typically when creating a website, there are various common elements you want to include on all pages (e.g., output options, CSS styles, header and footer elements, etc.). Here are additions in three files to the example above to make use of common elements:

- `_site.yml`:

    ```yaml
    name: "my-website"
    navbar:
      title: "My Website"
      left:
        - text: "Home"
          href: index.html
        - text: "About"
          href: about.html
    output:
      html_document:
        theme: cosmo
        highlight: textmate
        include:
          after_body: footer.html
        css: styles.css
    ```

- `footer.html`:

    ```html
    <p>Copyright &copy; 2016 Skynet, Inc. All rights reserved.</p>
    ```

- `styles.css`

    ```css
    blockquote {
      font-style: italic
    }
    ```

Note that we have included an `output` element within our `_site.yml` file. This defines shared output options for all R Markdown documents within a site. Note that individual documents can also include their own `output` options, which will be merged with the common options at render time.

As part of our common output options, we have specified an HTML footer (via the `include: after-body:` option) and a CSS stylesheet. You can also include HTML before the body or in the document's `<head>` tag (see Section \@ref(includes)).

In addition to whatever common options you define, there are two output options that are automatically set when rendering a site:

1. The `self_contained` option is set `FALSE`; and

1. The `lib_dir` option is set to `site_libs`.

These options are set so that dependent files (e.g., jQuery, Bootstrap, and HTML widget libraries) are shared across all documents within the site rather than redundantly embedded within each document.

#### R scripts

If you have R code that you would like to share across multiple R Markdown documents within your site, you can create an R script (e.g., `utils.R`) and source it within your Rmd files. For example:

````markdown
`r ''````{r}
source("utils.R")
```
````

#### Rmd partials

You may have common fragments of R Markdown that you want to share across pages within your site. To share Rmd fragments, you should name them with a leading underscore (`_`), and then include them within their parent Rmd document using the `child` chunk option. For example:

- `about.Rmd`:

    ````markdown
    ---
    title: "About This Website"
    ---

    More about this website.

    `r ''````{r, child="_session-info.Rmd"}
    ```
    ````

- `_session-info.Rmd`:

    ````markdown
    Session information:

    `r ''````{r}
    sessionInfo()
    ```
    ````

The leading underscore is an indicator to the site generation engine that the Rmd is a partial document to be included in other documents, so it is not compiled as a standalone document during site rendering.

The full source code for the above example can be found in the `common-element` folder in the repository <https://github.com/rstudio/rmarkdown-website-examples>.

### Site navigation

The `navbar` element of `_site.yml` can be used to define a common navigation bar for your website. You can include internal and external links on the navigation bar as well as drop-down menus for sites with a large number of pages.

Here is a navigation bar definition in `_site.yml` that makes use of a variety of features:

```yaml
name: "my-website"
navbar:
  title: "My Website"
  type: inverse
  left:
    - text: "Home"
      icon: fa-home
      href: index.html
    - text: "About"
      icon: fa-info
      href: about.html
    - text: "More"
      icon: fa-gear
      menu:
        - text: "Heading 1"
        - text: "Page A"
          href: page-a.html
        - text: "Page B"
          href: page-b.html
        - text: "---------"
        - text: "Heading 2"
        - text: "Page C"
          href: page-c.html
        - text: "Page D"
          href: page-d.html
  right:
    - icon: fa-question fa-lg
      href: https://example.com
```

This example demonstrates a number of capabilities of navigation bars:

1. You can use the `type` field to choose between the `default` and `inverse` navigation bar styles (each theme includes distinct colors for "default" and "inverse" navigation bars).

1. You can align navigational items either to the `left` or to the `right`.

1. You can include menus on the navigation bar, and those menus can have separators (`text: "--------------"`) and internal headings (`text` without a corresponding `href`).

1. You can include both internal and external links on the navigation bar.

1. You can use icons on the navigation bar. Icons from three different icon sets are available.

    - [Font Awesome](https://fontawesome.com/icons)
    - [Ionicons](http://ionicons.com/)
    - [Bootstrap Glyphicons](https://getbootstrap.com/docs/3.3/components/#glyphicons)

    When referring to an icon, you should use its full name including the icon set prefix (e.g., `fa-github`, `ion-social-twitter`, and `glyphicon-time`).

#### HTML navigation bar

If you want to have even more control over the appearance and behavior of the navigation bar, you can define it in HTML rather than YAML. If you include a file named `_navbar.html` in your website directory, it will be used as the navigation bar. Here is an example of navigation bar defined in HTML: <https://github.com/rstudio/rmarkdown-website/blob/master/_navbar.html>.

Full documentation on syntax of Bootstrap navigation bars can be found here: <http://getbootstrap.com/components/>.

### HTML generation

R Markdown includes many facilities for generation of HTML content from R objects, including:

- The conversion of standard R output types (e.g., textual output and plots) within code chunks done automatically by **knitr**.

- A variety of ways to generate HTML tables, including the `knitr::kable()` function and other packages such as **kableExtra** and **pander**.

- A large number of available HTML widgets that provide rich JavaScript data visualizations.

As a result, for many R Markdown websites you will not need to worry about generating HTML output at all (since it is created automatically).

#### The htmltools package

If the facilities described above do not meet your requirements, you can also generate custom HTML from your R code using the **htmltools** package [@R-htmltools]. The **htmltools** package enables you to write HTML using a convenient R based syntax (this is the same core HTML generation facility used by the **shiny** package).

Here is an example of an R function that creates a Bootstrap thumbnail div:

```{r eval=FALSE, tidy=FALSE}
library(htmltools)
thumbnail <- function(title, img, href, caption = TRUE) {
  div(class = "col-sm-4",
      a(class = "thumbnail", title = title, href = href,
        img(src = img),
        div(class = if (caption) "caption",
            if (caption) title)
      )
  )
}
```

You can write functions that build HTML like the one above, then call them from other R code that combines them with your data to produce dynamic HTML. An R code chunk that makes use of this function might look like this:

````markdown
`r ''````{r, echo=FALSE}
thumbnail("Apple", "images/apple.png",
          "https://en.wikipedia.org/wiki/Apple")
thumbnail("Grape", "images/grape.png",
          "https://en.wikipedia.org/wiki/Grape")
thumbnail("Peach", "images/peach.png",
          "https://en.wikipedia.org/wiki/Peach")
```
````

### Site configuration

The `_site.yml` file has a number of options that affect site output, including where it is written and what files are included and excluded from the site. Here is an example that makes use of a few of these options:

```yaml
name: "my-website"
output_dir: "_site"
include: ["import.R"]
exclude: ["docs.txt", "*.csv"]
```

The `name` field provides a suggested URL path for your website when it is published (by default this is just the name of the directory containing the site).

The `output_dir` field indicates which directory to copy site content into (`"_site"` is the default if none is specified). It can be `"."` to keep all content within the root website directory alongside the source code.

#### Included files

The `include` and `exclude` fields enable you to override the default behavior vis-a-vis what files are copied into the output directory. By default, all files within the website directory are copied into the output directory save for the following:

1. Files beginning with `.` (hidden files).

2. Files beginning with `_`.

3. Files known to contain R source code (e.g., `*.R`, `*.s`, `*.Rmd`), R data (e.g., `*.RData`, `*..rds`), or configuration data (e.g., `*..Rproj`, `rsconnect`).

The `include` and `exclude` fields of `_site.yml` can be used to override this default behavior (wildcards can be used to specify groups of files to be included or excluded).

Note that `include` and `exclude` are *not* used to determine which Rmd files are rendered: all of them in the root directory save for those named with the `_` prefix will be rendered.

### Publishing websites

R Markdown websites are static HTML sites that can be deployed to any standard web server. All site content (generated documents and supporting files) are copied into the `_site` directory, so deployment is simply a matter of moving that directory to the appropriate directory of a web server.

### Additional examples

Here are some additional examples of websites created with R Markdown:

- The **rmarkdown** documentation: https://rmarkdown.rstudio.com. This website was created using R Markdown. There are a large number of pages (over 40) that are organized using sub-menus on the navigation bar. Disqus comments are included on each page via an `after_body` option. The source code is at https://github.com/rstudio/rmarkdown/tree/gh-pages.

- The **flexdashboard** documentation: https://rmarkdown.rstudio.com/flexdashboard/. It illustrates using an R script to dynamically generate HTML thumbnails of **flexdashboard** examples from YAML. The source code is at https://github.com/rstudio/rmarkdown/tree/gh-pages/flexdashboard.

### Custom site generators

So far we have described the behavior of the default site generation function, `rmarkdown::default_site()`. It is also possible to define a custom site generator that has alternate behaviors.

#### Site generator function

A site generator is an R function that is bound to by including it in the `site:` field of the `index.Rmd` or `index.md` file. For example:

```yaml
---
title: "My Book"
output: bookdown::gitbook
site: bookdown::bookdown_site
---
```

A site generation function should return a list with the following elements:

- `name`: The name for the website (e.g., the parent directory name).

- `output_dir`: The directory where the website output is written to. This path should be relative to the site directory (e.g., `"."` or `"_site"`).

- `render`: An R function that can be called to generate the site. The function should accept the `input_file`, `output_format`, `envir`, `quiet`, and `encoding` arguments.

- `clean`: An R function that returns relative paths to the files generated by `render_site()`. These files are the ones to be removed by the `clean_site()` function.

Note that the `input_file` argument will be `NULL` when the entire site is being generated. It will be set to a specific filename if a front-end tool is attempting to preview it (e.g., RStudio IDE via the `Knit` button).

When `quiet = FALSE`, the `render` function should also print a line of output using the `message()` function indicating which output file should be previewed. For example:

```r
if (!quiet)
  message("\nOutput created: ", output)
```

Emitting this line enables front-ends like RStudio to determine which file they should open to preview the website.

#### Examples

See the source code of the `rmarkdown::default_site` function for an example of a site generation function. The **bookdown** package also implements a custom site generator via its `bookdown::bookdown_site` function.

<!--chapter:end:10-website.Rmd-->

# HTML Documentation for R Packages {#pkgdown}

R has a built-in HTML help system that can be accessed via `help.start()`. From this system, you can see the HTML help pages of functions and objects in all packages, as well as other information about packages such as the `DESCRIPTION` file and package vignettes. However, this system is usually dynamically launched (via a local web server), and it is not straightforward to turn it into a static website that can be viewed without starting R.

The **pkgdown** package\index{pkgdown} [@R-pkgdown] makes it easy to build a documentation website for an R package, which can help you organize different pieces of the package documentation (e.g., README, help pages, vignettes, and news) with a more visually pleasant style. The navigation can also be easier for users than R's built-in help system. This website can be published to any web server (e.g., GitHub Pages or Netlify). An example is **pkgdown**'s own website: http://pkgdown.r-lib.org (see Figure \@ref(fig:pkgdown)).

```{r pkgdown, echo=FALSE, out.width='100%', fig.cap='A screenshot of the pkgdown website.'}
knitr::include_graphics('images/pkgdown.png', dpi = NA)
```

## Get started {#pkgdown-start}

You can install **pkgdown** from CRAN, or its development version from GitHub, and find more information from its GitHub repository (https://github.com/r-lib/pkgdown).

```r
install.packages("pkgdown")

# Or the development version
devtools::install_github("r-lib/pkgdown")
```

After it is installed, you can call the function `pkgdown::build_site()` in the root directory of your source package. It will build a website to the `docs/` directory, which can be turned into an online website via [GitHub Pages](https://help.github.com/articles/configuring-a-publishing-source-for-github-pages/) or Netlify.

## Components {#pkgdown-components}

A **pkgdown** website consists of these components: the home page, function reference, articles, news, and the navigation bar. You may configure these components via a file `_pkgdown.yml`.

### Home page

The home page is generated from the first existing file of the following files in your source package:

- `index.Rmd`
- `README.Rmd`
- `index.md`
- `README.md`

Other meta information about the package, such as the package license and author names, will be displayed automatically as a sidebar on the home page.

### Function reference

The reference pages look like R's own help pages. In fact, these pages are generated from the `*.Rd` files under `man/`. Compared to R's own help pages, **pkgdown** offers a few more benefits: the examples on a help page (if they exist) will be evaluated so that you can see the output, and function names are automatically linked so you can click on a name to navigate to the help page of another function. What is more, **pkgdown** allows you to organize the list of all functions into groups (e.g., by topic), which can make it easier for users to find the right function in a list. By default, all functions are listed alphabetically just like R's help system. To group functions on the list page, you need to provide a `reference` key in `_pkgdown.yml`, e.g.,

```yaml
reference:
  - title: "One Topic"
    desc: "These functions are awesome..."
    contents:
      - awesome_a
      - awesome_b
      - cool_c
  - title: "Another Topic"
    desc: "These functions are boring..."
    contents:
      - starts_with("boring_")
      - ugh_oh
```

As you can see from the above example, you may list the names of functions in the `contents` field, or provide a pattern to let **pkgdown** match the names. There are three ways to match function names: `starts_with()` to match names that start with a string, `ends_width()` for an ending pattern, and `matches()` for an arbitrary regular expression.

### Articles

Package vignettes in the R Markdown format under the `vignettes/` directories will be built as "articles" for a **pkgdown**-based website. Note that Rmd files under subdirectories will also be built. The list of articles will be displayed as a drop-down menu in the navigation bar.

If you have a vignette that has the same base name as the package name (e.g., a vignette `foo.Rmd` in a package **foo**), it will be displayed as the "Get started" menu item in the navigation bar.

### News

If the source package has a news file `NEWS.md`, it will be parsed and rendered to HTML pages that can be accessed via the "Changelog" menu in the navigation bar.

### Navigation bar

The navigation bar in **pkgdown** is based on the **rmarkdown** site generator. You can learn how to customize it from Section \@ref(site-navigation), if you are not satisfied by the default navigation bar. Please note that you need to specify the `navbar` field in `_pkgdown.yml` instead of `_site.yml`.

<!--chapter:end:11-pkgdown.Rmd-->

# Books

We have introduced the basics of R Markdown in Chapter \@ref(documents), which highlighted how HTML, PDF, and Word documents can be produced from an R workflow. However, larger projects can become difficult to manage in a single R Markdown file. The **bookdown** package\index{bookdown} [@xie2016; @R-bookdown] addresses this limitation, and offers several key improvements:

- Books and reports can be built from multiple R Markdown files.

- Additional formatting features are added, such as cross-referencing, and numbering of figures, equations, and tables.

- Documents can easily be exported in a range of formats suitable for publishing, including PDF, e-books and HTML websites.

This book itself was created using **bookdown**, and acts as an example of what can be achieved. Despite the name containing the word "book", **bookdown** is not only for books, and it can be used for long reports, dissertations, or even single R Markdown documents (see Section \@ref(a-single-document)). It also works with other computing languages such as Python and C++ (see Section \@ref(language-engines)). If you want, you can even write documents irrelevant to computing, such as a novel.

In this chapter, we cover the basics of **bookdown**, and explain how to start a **bookdown** project. Much of the the content is based on the work "*bookdown: Authoring Books and Technical Documents with R Markdown*" (https://bookdown.org/yihui/bookdown/) of @xie2016, which provides more detailed explanations of the concepts highlighted.

## Get started {#bookdown-start}

You can install either the CRAN version or the development version on GitHub (https://github.com/rstudio/bookdown):

```{r eval=FALSE}
# install from CRAN
install.packages('bookdown')

# or GitHub
devtools::install_github('rstudio/bookdown')
```

If you use RStudio, you can start a new bookdown project from the menu `File -> New Project -> New Directory -> Book Project using bookdown`.^[Alternatively, the command `bookdown:::bookdown_skeleton(getwd())` will create a skeleton project in your current working directory.] Open the R Markdown file `index.Rmd`, and click the button `Build Book` on the `Build` tab of RStudio. This will compile the book and display the HTML version within the RStudio Viewer, which looks like Figure \@ref(fig:bookdown-template).  

```{r bookdown-template, echo=FALSE, fig.cap= "The HTML output of the bookdown template.", out.width='100%'}
knitr::include_graphics("images/bookdown-template.png", dpi = NA)
```

You may add or change the R Markdown files, and hit the `Knit` button again to preview the book. If you prefer not to use RStudio, you may also compile the book through the command line using `bookdown::render_book()`.

## Project structure {#bookdown-project}

Below shows the basic structure of a default **bookdown** project:

```markdown
directory/
├──  index.Rmd
├── 01-intro.Rmd
├── 02-literature.Rmd
├── 03-method.Rmd
├── 04-application.Rmd
├── 05-summary.Rmd
├── 06-references.Rmd
├── _bookdown.yml
├── _output.yml
├──  book.bib
├──  preamble.tex
├──  README.md
└──  style.css
```

As a summary of these files:

- `index.Rmd`: This is the only Rmd document to contain a YAML frontmatter as described within Chapter \@ref(basics), and is the first book chapter.

- Rmd files: A typical **bookdown** book contains multiple chapters, and each chapter lives in one separate Rmd file.

- `_bookdown.yml`: A configuration file for **bookdown**.

- `_output.yml`: It specifies the formatting of the HTML, LaTeX/PDF, and e-books.

- `preamble.tex` and `style.css`: They can be used to adjust the appearance and styles of the book output document(s). Knowledge of LaTeX and/or CSS is required.

These files are explained in greater detail in the following subsections.

### Index file

The `index.Rmd` file contains the first chapter and the YAML metadata, e.g.,

```yaml
---
title: "A Minimal Book Example"
author: "Yihui Xie"
date: "`r "\x60r Sys.Date()\x60"`"
site: bookdown::bookdown_site
documentclass: book
bibliography: [book.bib, packages.bib]
biblio-style: apalike
link-citations: yes
description: "This is a minimal example of using
  the bookdown package to write a book."
---
```

### Rmd files

By default, all Rmd files are merged with the `index.Rmd` to render the book. The Rmd files must start immediately with the chapter title using the first-level heading, e.g., `# Chapter Title`. Note that YAML metadata should not be included in these Rmd files, as it is inherited from the `index.Rmd` file. 

- 01-intro.Rmd

    ```markdown
    # Introduction

    This chapter is an overview of the methods that
    we propose to solve an **important problem**.
    ```

- 02-literature.Rmd

    ```markdown
    # Literature

    Here is a review of existing methods.
    ```

By default, **bookdown** merges all Rmd files by the order of filenames, e.g., `01-intro.Rmd` will appear before `02-literature.Rmd`. Filenames that start with an underscore `_` are skipped.

### `_bookdown.yml`

The `_bookdown.yml` file allows you to specify optional settings to build the book. For example, you may want to override the order in which files are merged by including  the field `rmd_files`:

```yaml
rmd_files: ["index.Rmd", "02-literature.Rmd", "01-intro.Rmd"]
```

### `_output.yml`

The `_output.yml` file is used to specify the book output formats (see Section \@ref(bookdown-output)). Here is a brief example:

```yaml
bookdown::gitbook:
  lib_dir: assets
  split_by: section
  config:
    toolbar:
      position: static
bookdown::pdf_book:
  keep_tex: yes
bookdown::html_book:
  css: toc.css
```

## Markdown extensions {#bookdown-markdown}

The **bookdown** package expands upon the Markdown syntax\index{Markdown syntax} outlined in Section \@ref(markdown-syntax), and provides additional powerful features that assist longer documents and academic writing.

### Number and reference equations {#equations}

Section \@ref(math-expressions) highlighted how equations can be created using LaTeX syntax within Markdown. To number equations, put them in the `equation` environments, and assign labels to them using the syntax `(\#eq:label)`. Equation labels must start with the prefix `eq:` in **bookdown**. For example:

```latex
\begin{equation}
  E=mc^2
  (\#eq:emc)
\end{equation}
```

It renders the equation below \@ref(eq:emc):

\begin{equation}
  E=mc^2
  (\#eq:emc)
\end{equation}

### Theorems and proofs {#theorems}

Theorems and proofs provide environments that are commonly used within articles and books in mathematics. To write a theorem, you can use the syntax below:

````markdown
`r ''````{theorem}
Here is my theorem.
```
````

For example:

```{theorem, pyth, name="Pythagorean theorem"}
For a right triangle, if $c$ denotes the length of the hypotenuse
and $a$ and $b$ denote the lengths of the other two sides, we have

$$a^2 + b^2 = c^2$$
```

Theorems can be numbered and cross-referenced, as you can see from Theorem \@ref(thm:pyth). The `proof` environment behaves similarly to theorem environments but is unnumbered.

Variants of the `theorem` environments include: `r knitr::combine_words(names(bookdown:::theorem_abbr[-1]), before = '\x60')`. Variants of the `proof` environments include `r knitr::combine_words(names(bookdown:::label_names_math2[-1]), before = '\x60')`. The syntax for these environments is similar to the `theorem` environment, e.g., ```` ```{lemma}````.

### Special headers

There are two special types of first-level headers than can be used in **bookdown**:

- A part can be created using `# (PART) Part Title {-}` before the chapters that belong to this part.

- Appendices `# (APPENDIX) Appendix {-}`: All chapters after this header will be treated as the appendix. The numbering style of these chapters will be `A`, `B`, `C`, etc., and sections will be numbered as `A.1`, `A.2`, and so on.

### Text references

A text reference is a paragraph with a label. The syntax is `(ref:label) text`, where `label` is a unique identifier, and `text` is a Markdown paragraph. For example:

```markdown
(ref:foo) Define a text reference **here**.
```

Then you can use `(ref:foo)` to refer to the full text. Text references can be used anywhere in the document, and are particularly useful when assigning a long caption to a figure or including Markdown formatting in a caption. For example:

````markdown
Some text.

(ref:cool-plot) A boxplot of the data `iris` in **base** R.

`r ''````{r cool-plot, fig.cap='(ref:cool-plot)'}
boxplot(Sepal.Length ~ Species, data = iris)
```
````

### Cross referencing

The **bookdown** package extends cross-referencing in R Markdown documents and allows section headers, tables, figures, equations, and theorems to be cross-referenced automatically. This only works for numbered environments, and therefore requires figures and tables to be assigned a label. Cross-references are made in the format `\@ref(type:label)`, where `label` is the chunk label and `type` is the environment being referenced. As examples:

- Headers:

    ```markdown
    # Introduction {#intro}

    This is Chapter \@ref(intro)
    ```

- Figures:

    ````markdown
    See Figure \@ref(fig:cars-plot)

    `r ''````{r cars-plot, fig.cap="A plot caption"}
    plot(cars)  # a scatterplot
    ```
    ````

- Tables:

    ````markdown
    See Table \@ref(tab:mtcars)

    `r ''````{r mtcars}
    knitr::kable(mtcars[1:5, 1:5], caption = "A caption")
    ```
    ````

- Theorems:

    ````markdown
    See Theorem \@ref(thm:boring)

    `r ''````{theorem, boring}
    Here is my theorem.
    ```
    ````

- Equations:

    ````markdown
    See equation \@ref(eq:linear)

    \begin{equation}
    a + bx = c  (\#eq:linear)
    \end{equation}
    ````

Note that only alphanumeric characters (`a-z`, `A-Z`, `0-9`), `-`, `/`, and `:` are allowed in these labels.

## Output Formats {#bookdown-output}

The **bookdown** package includes the following output formats\index{output formats}:

- HTML:
    - `gitbook`
    - `html_book`
    - `tufte_html_book`
- PDF:
    - `pdf_book`
- e-book:
    - `epub_book`
- Single documents:
    - `html_document2`
    - `tufte_html2`
    - `pdf_document2`
    - `tufte_handout2`
    - `tufte_book2`
    - `word_document2`

### HTML

Although multiple formats are available for HTML books in **bookdown**, we will focus on the Gitbook style, which appears to be the most popular format. It provides a clean style, with a table of contents on the left. The design is fully responsive to make the content suitable for both mobile and desktop devices.

The output format `bookdown::gitbook` is built upon `rmarkdown::html_document`, which was explained in Section \@ref(html-document). The main difference between rendering in R Markdown and **bookdown** is that a book will generate multiple HTML pages by default. To change the way the HTML pages are split, the `split_by` argument can be specified. This defaults to `split_by: chapter`, but readers may prefer to use `split_by: section` if there are many sections within chapters, in which case a chapter page may be too long.

### LaTeX/PDF

There are limited differences between the output of `pdf_book()` in **bookdown** compared to `pdf_document()` in **rmarkdown**. The primary purpose of the new format is to resolve the labels and cross-references written in the syntax described in Section \@ref(cross-referencing).

Pandoc supports LaTeX commands in Markdown. Therefore if the only output format that you want for a book is LaTeX/PDF, you may use the syntax specific to LaTeX, such as `\newpage` to force a page break. A major disadvantage of this approach is that LaTeX syntax is not portable to other output formats, meaning that these changes will not be transferred to the HTML or e-book outputs.

### E-books

The e-book formats can be read on devices like smartphones, tablets, or special e-readers such as Kindle. You can create an e-book of the EPUB format with `bookdown::epub_book`.

### A single document

We highlighted in Section \@ref(bookdown-markdown) that **bookdown** extends the syntax provided by R Markdown, allowing automatic numbering of figures / tables / equations, and cross-referencing them. You may use **bookdown** within single-file R Markdown documents to benefit from these features. The functions `html_document2()`, `tufte_html2()`, `pdf_document2()`, `word_document2()`, `tufte_handout2()`, and `tufte_book2()` are designed for this purpose. To use this in a traditional R Markdown document, you can replace the output YAML option as follows:

````yaml
---
title: "Document Title"
output: bookdown::pdf_document2
---
````

## Editing {#bookdown-edit}

In this section, we explain how to edit, build, preview, and serve the book locally.

### Build the book

To build all Rmd files into a book, you can call the function `bookdown::render_book()`. It uses the settings specified in the `_output.yml` (if it exists). If multiple output formats are specified in it, all formats will be built. If you are using RStudio, this can be done through the `Build` tab. Open the drop down menu `Build Book` if you only want to build one format.

(ref:bookdown-build) The `Build` tab within RStudio highlighting **bookdown** output formats.

```{r bookdown-build, echo=FALSE, fig.cap="(ref:bookdown-build)", out.width='90%', fig.align='center'}
knitr::include_graphics("images/bookdown-build.png", dpi = NA)
```

### Preview a chapter

Building the whole book can be slow when the size of the book is big or your book contains large amounts of computation. We can use the `preview_chapter()` function in **bookdown** to only build a single chapter at a time. Equivalently, you can click the `Knit` button in RStudio.

### Serve the book

Instead of running `render_book()` or `preview_chapter()` each time you want to view the changes, you can use the function `bookdown::serve_book()` to start a live preview of the book. Any time a Rmd file is saved, the book will be recompiled automatically, and the preview will be updated to reflect the changes.

### RStudio addins

The **bookdown** package comes with two addins for RStudio which assist the editing of books:

- "Preview Book": this calls `bookdown::serve_book()` to compile and serve the book.

- "Input LaTeX Math": provides a text box which allows you to write LaTeX equations, to avoid common errors when typing the raw LaTeX math expressions.

## Publishing {#bookdown-publish}

You can generate books for both physical and electronic distribution. This section outlines some of the main options.

### RStudio Connect

The easiest way to publish books online is through https://bookdown.org, which is a website provided by RStudio to host your books for free. Books can be pushed to this website by using `bookdown::publish_book()`. You will need to sign up for an account at https://bookdown.org/connect/, and your login details will be used to authorize **bookdown** the first time you call the `publish_book()` function.

### Other services

You can host your book online with many other web services, such as Netlify or GitHub (via [GitHub Pages](https://pages.github.com)). Because the output from `bookdown::render_book()` is a collection of static files, you can host them using the same methods of hosting normal web pages.

### Publishers

You can consider publishing physical copies of your book with a publisher or using self-publishing. Many publishers provide LaTeX style classes that can be used to set the overall appearance of the book, and these can be used easily by setting the `documentclass` option in the YAML metadata of `index.Rmd`. Further customization of the appearance of the PDF book can be achieved by altering the LaTeX preamble via the `includes: in_header` option of `bookdown::pdf_book`.

<!--chapter:end:12-bookdown.Rmd-->

# Journals

Academic journals often have strict guidelines on the formatting for submitted articles. As of today, few journals directly support R Markdown submissions, but many support the LaTeX\index{LaTeX} format. While you can convert R Markdown to LaTeX (see Section \@ref(pdf-document)), different journals have different typesetting requirements and LaTeX styles, and it may be slow and frustrating for all authors who want to use R Markdown to figure out the technical details about how to properly convert a paper based on R Markdown to a LaTeX document that meets the journal requirements.

The **rticles** package [@R-rticles]\index{rticles} is designed to simplify the creation of documents that conform to submission standards. A suite of custom R Markdown templates for popular journals is provided by the package such as those shown in Figure \@ref(rticles-templates).

(ref:rticles-templates) Two journal templates in the **rticles** package (PLOS and Springer).

```{r rticles-templates, echo=FALSE, out.width="100%", fig.cap="(ref:rticles-templates)", fig.show='hold'}
knitr::include_graphics(c("images/rticles-plos.png", "images/rticles-springer.png"), dpi = NA)
```

Understanding of LaTeX is recommended, but not essential, to use this package. R Markdown templates may sometimes inevitably contain LaTeX code, but usually we can use the simpler Markdown and **knitr** syntax to produce elements like figures, tables, and math equations as explained in Chapter \@ref(basics).

## Get started {#rticles-start}

You can install and use **rticles** from CRAN as follows:

```{r, eval = FALSE}
# Install from CRAN
install.packages("rticles")

# Or install development version from GitHub
devtools::install_github("rstudio/rticles")
```

We would recommend the development version of the package from GitHub, as it contains the most up-to-date versions along with several new templates.

If you are using RStudio, you can easily access the templates through `File -> New File -> R Markdown`. This will open the dialog box where you can select from one of the available templates as shown in Figure \@ref(fig:rticles-setup).

(ref:rticles-setup) The R Markdown template window in RStudio showing available **rticles** templates.

```{r rticles-setup, echo=FALSE, fig.cap="(ref:rticles-setup)", out.width='100%'}
knitr::include_graphics("images/rticles-templates.png", dpi = NA)
```

If you are using the command line, you can use the `rmarkdown::draft()` function, which requires you to specify a template using the journal short name, e.g.,

```r
rmarkdown::draft(
  "MyJSSArticle.Rmd", template = "jss", package = "rticles"
)
```

## rticles templates

The **rticles** package provides templates for various journals and publishers, including:

- JSS articles (Journal of Statistical Software)
- R Journal articles
- CTeX documents
- ACM articles (Association of Computing Machinery)
- ACS articles (American Chemical Society)
- AMS articles (American Meteorological Society)
- PeerJ articles
- Elsevier journal submissions
- AEA journal submissions (American Meteorological Society)
- IEEE Transaction journal submissions
- Statistics in Medicine journal submissions
- Royal Society Open Science journal submissions
- Bulletin de l'AMQ journal submissions
- MDPI journal submissions
- Springer journal submissions

The full list is available within the R Markdown templates window in RStudio, or through the function `rticles::journals()`:

```{r}
rticles::journals()
```

## Using a template {#rticles-usage}

Templates have an extended YAML section compared to the basic R Markdown template, which allows you to specify additional details relevant to the custom template. Below is an example of the YAML section for the *Springer* template:

```yaml
title: Title here
subtitle: Do you have a subtitle? If so, write it here
titlerunning: Short form of title (if too long for head)
authorrunning:
  Short form of author list if too long for running head
thanks: |
  Grants or other notes about the article that should go
  on the front page should be placed here. General
  acknowledgments should be placed at the end of the article.
authors:
  - name: Author 1
    address: Department of YYY, University of XXX
    email: abc@def
  - name: Author 2
    address: Department of ZZZ, University of WWW
    email: djf@wef
keywords:
  - key
  - dictionary
  - word
MSC:
  - MSC code 1
  - MSC code 2    
abstract: |
  The text of your abstract.  150 -- 250 words.
bibliography: bibliography.bib
output: rticles::springer_article
```

As the Rmd documents are built using customized templates, you may not be able to use the YAML metadata to control the layout of the document as described in Section \@ref(pdf-document), unless the template supports such metadata. For example, adding `toc: true` may not add a table of contents. Commands that control the building process may still be used though, including `keep_tex: true`, or those that configure **knitr** chunk options (e.g., `fig_width`).

## LaTeX content {#rticles-latex}

As the only output format of the **rticles** formats is PDF, the content of the documents may include raw LaTeX formatting. This means you may use LaTeX to produce figures and tables (if you have to), e.g.,

```latex
\begin{figure}[ht]
\centering
\includegraphics[width=\linewidth]{foo}
\caption{An example image.}
\label{fig:foo}
\end{figure}
```

Unless you have specific requirements for using LaTeX, we recommend that you use the R Markdown syntax. This keeps you work generally more readable (in terms of the source document), and less prone to formatting errors. For example, the above code block would be better represented as:

````markdown
`r ''````{r foo, out.width="100%", fig.cap="An example image."}
knitr::include_graphics("foo.png")
```
````

## Linking with bookdown {#rticles-bookdown}

As explained in Section \@ref(bookdown-markdown), **bookdown**\index{bookdown} offers several extensions to the Markdown syntax, which can be particularly useful for academic writing, including cross-referencing of figures and tables. All **rticles** output formats are based on `rmarkdown::pdf_document`, and we can use them as the "base formats" for `bookdown::pdf_book`, e.g.,

```yaml
output:
  bookdown::pdf_book:
    base_format: rticles::peerj_article
```

You can substitute `rticles::peerj_article` with the template you actually intend to use.

## Contributing templates {#rticles-contrib}

If you take a look at the GitHub repository of **rticles** (https://github.com/rstudio/rticles), you will see that a lot of the templates have been contributed by the R community. If you are interested in improving them or adding more journal templates, you may want to read Chapter \@ref(document-templates), which outlines how a template can be made for R Markdown. Basically these templates are defined to translate the Pandoc variables from the YAML frontmatter and the body of the R Markdown document into LaTeX.

<!--chapter:end:13-rticles.Rmd-->

# Interactive Tutorials {#learnr}

The **learnr** package [@R-learnr]\index{learnr} makes it easy to turn any R Markdown document into an interactive tutorial. Tutorials consist of content along with interactive components for checking and reinforcing understanding. Tutorials can include any or all of the following:

1. Narrative, figures, illustrations, and equations.

1. Code exercises (R code chunks that users can edit and execute directly).

1. Quiz questions.

1. Videos (currently supported services include YouTube and Vimeo).

1. Interactive Shiny components.

Tutorials automatically preserve work done within them, so if a user works on a few exercises or questions and returns to the tutorial later, they can pick up right where they left off.

This chapter is only a brief summary of **learnr**'s full documentation at https://rstudio.github.io/learnr/. If you are interested in building more sophisticated tutorials, we recommend that you read the full documentation.

## Get started {#learnr-start}

To create a **learnr** tutorial, first install the **learnr** package with:

```r
install.packages("learnr")
```

Then you can select the "Interactive Tutorial" template from the "New R Markdown" dialog in the RStudio IDE (see Figure \@ref(fig:learnr-template)).

```{r learnr-template, echo=FALSE, out.width='100%', fig.cap='Create an interactive tutorial in RStudio.'}
knitr::include_graphics('images/learnr-template.png', dpi = NA)
```

If you do not use RStudio, it is also easy to create a tutorial: add `runtime: shiny_prerendered` and the output format `learnr::tutorial` to the YAML metadata, use `library(learnr)` within your Rmd file to activate the tutorial mode, and then add the chunk option `exercise = TRUE` to turn code chunks into exercises. Your tutorial users can edit and execute the R code and see the results right within their web browser.

Below is a minimal tutorial example:

````markdown
`r xfun::file_string('examples/hello-tutorial.Rmd')`
````

To run this tutorial, you may hit the button "Run Document" in RStudio, or call the function `rmarkdown::run()` on this Rmd file. Figure \@ref(fig:learnr-hello) shows what the tutorial looks like in the browser. Users can do the exercise by editing the code and running it live in the browser.

```{r learnr-hello, echo=FALSE, out.width='100%', fig.cap='A simple example tutorial.'}
knitr::include_graphics('images/learnr-hello.png', dpi = NA)
```

We strongly recommend that you assign unique chunk labels to exercises (e.g., the above example used the label `addition`), because chunk labels will be used as identifiers for **learnr** to save and restore user work. Without these identifiers, users could possibly lose their work in progress the next time when they pick up the tutorial.

## Tutorial types {#learnr-types}

There are two main types of tutorial documents:

1. Tutorials that are mostly narrative and/or video content, and also include some runnable code chunks. These documents are very similar to package vignettes in that their principal goal is communicating concepts. The interactive tutorial features are then used to allow further experimentation by the reader.

1. Tutorials that provide a structured learning experience with multiple exercises, quiz questions, and tailored feedback.

The first type of tutorial is much easier to author while still being very useful. These documents will typically add `exercise = TRUE` to selected code chunks, and also set `exercise.eval = TRUE` so the chunk output is visible by default. The reader can simply look at the R code and move on, or play with it to reinforce their understanding.

The second type of tutorial provides much richer feedback and assessment, but also requires considerably more effort to author. If you are primarily interested in this sort of tutorial, there are many features in **learnr** to support it, including exercise hints and solutions, automated exercise checkers, and multiple choice quizzes with custom feedback.

The most straightforward path is to start with the first type of tutorial (executable chunks with pre-evaluated output), and then move into more sophisticated assessment and feedback over time.

## Exercises {#learnr-exercises}

Exercises are interactive R code chunks that allow readers to directly execute R code and see its results. We have shown a simple exercise in Figure \@ref(fig:learnr-hello).

Exercises can include hints or solutions as well as custom checking code to provide feedback on user answers.

### Solutions

To create a solution to an exercise in a code chunk with the chunk label `foo`, you add a new code chunk with the chunk label `foo-solution`, e.g.,

````markdown
`r ''````{r filter, exercise=TRUE}
# Change the filter to select February rather than January
nycflights <- filter(nycflights, month == 1)
```

`r ''````{r filter-solution}
nycflights <- filter(nycflights, month == 2)
```
````

When a solution code chunk is provided, there will be a `Solution` button on the exercise (see Figure \@ref(fig:learnr-solution)). Users can click this button to see the solution.

```{r learnr-solution, echo=FALSE, out.width='100%', fig.cap='A solution to an exercise.'}
knitr::include_graphics('images/learnr-solution.png', dpi = NA)
```

### Hints

Sometimes you may not want to give the solutions directly to students, but provide hints instead to guide them. Hints can be either Markdown-based text content or code snippets.

To create a hint based on custom Markdown content, add a `<div>` tag with an `id` attribute that marks it as hint for your exercise (e.g., `filter-hint`). For example:

````markdown
`r ''````{r filter, exercise=TRUE}
# filter the flights table to include only United and
# American flights
flights
```

<div id="filter-hint">
**Hint:** You may want to use the dplyr `filter` function.
</div>
````

The content within the `<div>` will be displayed underneath the R code editor for the exercise whenever the user presses the `Hint` button.

If your Pandoc version is higher than 2.0 (check `rmarkdown::pandoc_version()`), you can also use the alternative syntax to write the `<div>`:

```markdown
:::{#filter-hint}
**Hint:** You may want to use the dplyr `filter` function.
:::
```

To create a hint with a code snippet, you add a new code chunk with the label suffix `-hint`, e.g.,

````markdown
`r ''````{r filter, exercise=TRUE}
# filter the flights table to include only United and
# American flights
flights
```

`r ''````{r filter-hint}
filter(flights, ...)
```
````

You can also provide a sequence of hints that reveal progressively more of the solution as desired by the user. To do this, create a sequence of indexed hint chunks (e.g., `-hint-1`, `-hint-2`, `-hint-3`, etc.) for your exercise chunk. For example:

````markdown
`r ''````{r filter, exercise=TRUE}
# filter the flights table to include only United and
# American flights
flights
```

`r ''````{r filter-hint-1}
filter(flights, ...)
```

`r ''````{r filter-hint-2}
filter(flights, UniqueCarrier == "AA")
```

`r ''````{r filter-hint-3}
filter(flights, UniqueCarrier == "AA" | UniqueCarrier == "UA")
```
````

## Quiz questions {#learnr-quiz}

You can include one or more multiple-choice quiz questions within a tutorial to help verify that readers understand the concepts presented. Questions can either have a single or multiple correct answers.

Include a question by calling the `question()` function within an R code chunk, e.g.,

````markdown
`r ''````{r letter-a, echo=FALSE}
question("What number is the letter A in the English alphabet?",
  answer("8"),
  answer("14"),
  answer("1", correct = TRUE),
  answer("23")
)
```
````

Figure \@ref(fig:learnr-question) shows what the above question would look like within a tutorial.

```{r learnr-question, echo=FALSE, out.width='100%', fig.cap='A question in a tutorial.'}
knitr::include_graphics('images/learnr-question.png', dpi = NA)
```

The functions `question()` and `answer()` have several other arguments for more features that allow you to customize the questions and answers, such as custom error messages when the user's answer is wrong, allowing users to retry a question, multiple-choice questions, and multiple questions in a group. See their help pages in R for more information.

## Videos {#learnr-videos}

You can include videos published on either YouTube or Vimeo within a tutorial using the standard Markdown image syntax. Note that any valid YouTube or Vimeo URL will work. For example, the following are all valid examples of video embedding:

```markdown
![](https://youtu.be/zNzZ1PfUDNk)
![](https://www.youtube.com/watch?v=zNzZ1PfUDNk)

![](https://vimeo.com/142172484)
![](https://player.vimeo.com/video/142172484)
```

Videos are responsively displayed at 100% of their container's width (with height automatically determined based on a 16x9 aspect ratio). You can change this behavior by adding attributes to the Markdown code where you reference the video.

You can specify an alternate percentage for the video's width or an alternate fixed width and height. For example:

```markdown
![](https://youtu.be/zNzZ1PfUDNk){width="90%"}

![](https://youtu.be/zNzZ1PfUDNk){width="560" height="315"}
```

## Shiny components {#learnr-shiny}

Tutorials are essentially Shiny documents, which we will introduce in Chapter \@ref(shiny-documents). For that reason, you are free to use any interactive Shiny components in tutorials, not limited to exercises and quiz questions.

The Shiny UI components can be written in normal R code chunks. For the Shiny server logic code (rendering output), you need to add a chunk option `context="server"` to code chunks. For example:

````markdown
`r ''````{r, echo=FALSE}
sliderInput("bins", "Number of bins:", 30, min = 1, max = 50)
plotOutput("distPlot")
```

`r ''````{r, context="server"}
output$distPlot = renderPlot({
  x = faithful[, 2]  # Old Faithful Geyser data
  bins = seq(min(x), max(x), length.out = input$bins + 1)
  hist(x, breaks = bins, col = 'darkgray', border = 'white')
})
```
````

Again, since tutorials are Shiny applications, they can be deployed using the same methods mentioned in Section \@ref(shiny-deploy).

## Navigation and progress tracking {#learnr-nav}

Each **learnr** tutorial includes a table of contents on the left that tracks student progress (see Figure \@ref(fig:learnr-progress)). Your browser will remember which sections of a tutorial a student has completed, and return a student to where he/she left off when the tutorial is reopened.

```{r learnr-progress, echo=FALSE, out.width='100%', fig.cap="Keeping track of the student's progress in a tutorial."}
knitr::include_graphics('images/learnr-progress.png', dpi = NA)
```

You can optionally reveal content by one sub-section at a time. You can use this feature to let students set their own pace, or to hide information that would spoil an exercise or question that appears just before it.

To use progressive reveal, set the `progressive` option to `true` in the `learnr::tutorial` output format in the YAML metadata, e.g.,

```yaml
---
title: "Programming basics"
output:
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
---
```

The `allow_skip` option above indicates that students can skip any sections, and move directly to the next section without completing exercises in the previous section.

<!--chapter:end:14-learnr.Rmd-->

# (PART) Other Topics {-}

# Parameterized reports

One of the many benefits of working with R Markdown is that you can reproduce analysis at the click of a button. This makes it very easy to update any work and alter any input parameters within the report.  Parameterized reports\index{parameterized reports} extend this one step further, and allow users to specify one or more parameters to customize the analysis. This is useful if you want to create a report template that can be reused across multiple similar scenarios. Examples may include:

- Showing results for a specific geographic location.

- Running a report that covers a specific time period.

- Running a single analysis multiple times for different assumptions.

- Controlling the behavior of **knitr** (e.g., specify if you want the code to be displayed or not).

In this chapter, we discuss the use of parameterized reports, and explain how we can interactively define the parameters to compile the results.

## Declaring parameters {#params-declare}

Parameters are specified using the `params` field within the YAML section. We can specify one or more parameters with each item on a new line. As an example:

```yaml
---
title: My Document
output: html_document
params:
  year: 2018
  region: Europe
  printcode: TRUE
  data: file.csv
---
```

All standard R types that can be parsed by `yaml::yaml.load()` can be included as parameters, including `character`, `numeric`, `integer`, and `logical` types. We can also use R objects by including `!r` before R expressions. For example, we could include the current date with the following R code:

```yaml
---
title: My Document
output: html_document
params:
  date: !r Sys.Date()
---
```

Any R expressions included within the parameters are executed before any code in the document, therefore any package dependencies must be explicitly stated using the `package::function` notation (e.g., `!r lubridate::today()`), even if the package is loaded later in the Rmd document.

## Using parameters {#params-use}

You can access the parameters within the knitting environment and the R console in RStudio.^[Parameters will not be available immediately after loading the file, but require any line of the report to be executed first.] The values are contained within a read-only list called `params`. In the previous example, the parameters can be accessed as follows:

```r
params$year
params$region
```

Parameters can also be used to control the behavior of **knitr**. For example, the **knitr** chunk option `echo` controls whether to display the program code, and we can set this option globally in a document via a parameter:

````markdown
---
params:
  printcode: false  # or set it to true
---

`r ''````{r, setup, include=FALSE}
# set this option in the first code chunk in the document
knitr::opts_chunk$set(echo = params$printcode)
```
````

## Knitting with parameters {#params-knit}

There are three ways in which a parameterized report can be knitted:

- Using the `Knit` button within RStudio.

- `rmarkdown::render()` with the `params` argument.

- Using an interactive user interface to input parameter values.

### The `Knit` button

By using the `Knit` button in RStudio or calling `rmarkdown::render()` function, the default values listed in the YAML metadata (if specified) will be used.

### Knit with custom parameters

Even if your document has the `params` field in the YAML metadata, you can actually override it by providing a custom list of parameter values to the function `rmarkdown::render()`. For example:

```{r, eval=FALSE, tidy=FALSE}
rmarkdown::render("MyDocument.Rmd", params = list(
  year = 2017,
  region = "Asia",
  printcode = FALSE,
  file = "file2.csv"
))
```

We do not have to explicitly state all parameters in the `params` argument. Any parameters not specified will default to the values specified in the YAML metadata. For example, this will only override the `region` parameter:

```{r, eval=FALSE, tidy=FALSE}
rmarkdown::render("MyDocument.Rmd", params = list(
  region = "Asia"
))
```

You may want to integrate these changes into a function. Such a function could also be used to create an output file with a different filename for each of the different combination of parameters. In the following example, a new file `Report-region-year.pdf` is created for each set of parameters:

```{r, eval=FALSE, tidy=FALSE}
render_report = function(region, year) {
  rmarkdown::render(
    "MyDocument.Rmd", params = list(
      region = region,
      year = year
    ),
    output_file = paste0("Report-", region, "-", year, ".pdf")
  )
}
```

### The interactive user interface

We can use a graphical user interface (GUI) based on Shiny to interactively input the parameters of a report. The user interface can be called by either `rmarkdown::render("MyDocument.Rmd", params = "ask")` or clicking the drop-down menu behind the `Knit` button and choosing `Knit with Parameters` in RStudio. Figure \@ref(fig:params-input) shows the GUI of **rmarkdown** asking for inputting parameters.

```{r params-input, echo=FALSE, fig.cap="Input parameter values interactively for parameterized reports.", out.width="100%"}
knitr::include_graphics("images/params-input.png", dpi = NA)
```

The input controls for different types of parameters can be customized by specifying additional sub-items within the parameter specification in YAML. For example, sliders, check boxes, and text input boxes can all be used for input controls.

In addition, we can also specify constraints of the values allowed in each parameter. For example, we may only want our model to be run for years between 2010 and 2018. This is particularly beneficial if you would like other users to interact with the report, as it prevents users from attempting to run reports outside of the designed limits.

Adapting our above example to include some settings:

```yaml
---
title: My Document
output: html_document
params:
  year:
    label: "Year"
    value: 2017
    input: slider
    min: 2010
    max: 2018
    step: 1
    sep: ""
  region:
    label: "Region:"
    value: Europe
    input: select
    choices: [North America, Europe, Asia, Africa]
  printcode:
    label: "Display Code:"
    value: TRUE
  data:
    label: "Input dataset:"
    value: results.csv
    input: file
---
```

This results in the user interface for the parameters as shown in Figure \@ref(fig:params-controls).

```{r params-controls, echo=FALSE, fig.cap="Custom controls for parameters.", out.width="100%"}
knitr::include_graphics("images/params-controls.png", dpi = NA)
```

The type of Shiny control used is controlled by the `input` field. Table \@ref(tab:params-types) shows the input types currently supported (see the help page for the associated Shiny function for additional attributes that can be specified to customize the input, e.g., `?shiny::checkboxInput`).

```{r, params-types, echo=FALSE}
knitr::kable(
  read.table(
    text = "checkbox	checkboxInput
            numeric	numericInput
            slider	sliderInput
            date	dateInput
            text	textInput
            file	fileInput
            radio	radioButtons
            select	selectInput
            password	passwordInput",
    col.names = c("Input Type", "Shiny Function"),
    check.names = FALSE
  ),
  caption = "Possible input types and the associated Shiny functions for parameterized reports.",
  booktabs = TRUE
)
```

## Publishing {#params-publish}

Parameterized reports are supported by the publishing platform RStudio Connect (https://www.rstudio.com/products/connect/). If you publish a parameterized report to an RStudio Connect server, you will be able to compile reports by interactively choosing different parameter values on the server, and easily store/navigate through different reports built previously. You may watch a video demonstration at https://bit.ly/rsc-params.

<!--chapter:end:15-parameterized.Rmd-->

# HTML Widgets

We briefly mentioned HTML widgets\index{HTML widgets} in the beginning of this book in Section \@ref(intro-widgets). The **htmlwidgets** package [@R-htmlwidgets] provides a framework for creating R bindings to JavaScript libraries. HTML Widgets can be:

- Used at the R console for data analysis just like conventional R plots.

- Embedded within R Markdown documents.^[Note that interactivity only works when the output format is HTML, including HTML documents and presentations. If the output format is not HTML, it is possible to automatically create and embed a static screenshot of the widget instead. See Section \@ref(intro-widgets) for more information.]

- Incorporated into Shiny web applications.

- Saved as standalone web pages for ad-hoc sharing via Email and Dropbox, etc.

There have been many R packages developed based on the HTML widgets framework, to make it easy for R users to create JavaScript applications using pure R syntax and data. It is not possible to introduce all these R packages in this chapter. Readers should read the documentation of specific widget packages for the usage. This chapter is mainly for developers who want to bring more JavaScript libraries into R, and it requires reasonable familiarity with the JavaScript language.

## Overview {#htmlwidgets-overview}

By following a small set of conventions, it is possible to create HTML widgets with very little code. All widgets include the following components:

1. **Dependencies**. These are the JavaScript and CSS assets used by the widget (e.g., the library for which you are creating a wrapper).

3. **R binding**. This is the function that end-users will call to provide input data to the widget and specify various options for how the widget should render. This also includes some short boilerplate functions required to use the widget within Shiny applications.

3. **JavaScript binding**. This is the JavaScript\index{JavaScript} code that glues everything together, passing the data and options gathered in the R binding to the underlying JavaScript library.

HTML widgets are always hosted within an R package, and should include all of the source code for their dependencies. This is to ensure that R code that renders widgets is fully reproducible (i.e., it does not require an Internet connection or the ongoing availability of an Internet service to run).

## A widget example (sigma.js) {#htmlwidgets-sigma}

To start with, we will walk through the creation of a simple widget that wraps the [sigma.js](http://sigmajs.org) graph visualization library. When we are done, we will be able to use it to display interactive visualizations of [GEXF](http://gexf.net) (Graph Exchange XML Format) data files. For example (see Figure \@ref(fig:sigma) for the output, which is interactive if you are reading the HTML version of this book):

```{r, sigma, fig.cap='A graph generated using the sigma.js library and the sigma package.', out.width='100%', message=FALSE, cache=TRUE}
library(sigma)
d = system.file("examples/ediaspora.gexf.xml", package = "sigma")
sigma(d)
```

There is remarkably little code required to create this binding. Next we will go through all of the components step by step. Then we will describe how you can create your own widgets, including automatically generating basic scaffolding for all of the core components.

### File layout

Let's assume that our widget is named **sigma** and is located within an R package of the same name. Our JavaScript binding source code file is named sigma.js. Since our widget will read GEXF data files, we will also need to include both the base `sigma.min.js` library and its GEXF plugin. Here are the files that we will add to the package:

```markdown
R/
| sigma.R

inst/
|-- htmlwidgets/
|   |-- sigma.js
|   |-- sigma.yaml
|   |-- lib/
|   |   |-- sigma-1.0.3/
|   |   |   |-- sigma.min.js
|   |   |   |-- plugins/
|   |   |   |   |-- sigma.parsers.gexf.min.js
```

Note the convention that the JavaScript, YAML, and other dependencies are all contained within the `inst/htmlwidgets` directory, which will subsequently be installed into a package sub-directory named `htmlwidgets`.

### Dependencies

Dependencies are the JavaScript and CSS assets used by a widget, included within the `inst/htmlwidgets/lib` directory. They are specified using a YAML configuration file that uses the name of the widget as its base filename. Here is what our **sigma.yaml** file looks like:

```yaml
dependencies:
  - name: sigma
    version: 1.0.3
    src: htmlwidgets/lib/sigma-1.0.3
    script:
      - sigma.min.js
      - plugins/sigma.parsers.gexf.min.js
```

The dependency `src` specification refers to the directory that contains the library, and `script` refers to specific JavaScript files. If your library contains multiple JavaScript files specify each one on a line beginning with `-` as shown above. You can also add `stylesheet` entries, and even `meta` or `head` entries. Multiple dependencies may be specified in one YAML file. See the documentation on the `htmlDependency()` function in the **htmltools** package for additional details.

### R binding

We need to provide users with an R function that invokes our widget. Typically this function will accept input data as well as various options that control the widget's display. Here is the R function for the `sigma` widget:

```{r eval=FALSE, tidy=FALSE}
#' @import htmlwidgets
#' @export
sigma = function(
  gexf, drawEdges = TRUE, drawNodes = TRUE, width = NULL,
  height = NULL
) {

  # read the gexf file
  data = paste(readLines(gexf), collapse = "\n")

  # create a list that contains the settings
  settings = list(drawEdges = drawEdges, drawNodes = drawNodes)

  # pass the data and settings using 'x'
  x = list(data = data, settings = settings)

  # create the widget
  htmlwidgets::createWidget(
    "sigma", x, width = width, height = height
  )
}
```

The function takes two classes of input: the GEXF data file to render, and some additional settings that control how it is rendered. This input is collected into a list named `x`, which is then passed on to the `htmlwidgets::createWidget()` function. This `x` variable will subsequently be made available to the JavaScript binding for `sigma` (to be described in the next section). Any width or height parameter specified is also forwarded to the widget (widgets size themselves automatically by default, so typically do not require an explicit width or height).

We want our sigma widget to also work in Shiny applications, so we add the following boilerplate Shiny output and render functions (these are always the same for all widgets):

```{r, eval=FALSE, tidy=FALSE}
#' @export
sigmaOutput = function(outputId, width = "100%", height = "400px") {
  htmlwidgets::shinyWidgetOutput(
    outputId, "sigma", width, height, package = "sigma"
  )
}
#' @export
renderSigma = function(expr, env = parent.frame(), quoted = FALSE) {
  if (!quoted) { expr = substitute(expr) } # force quoted
  htmlwidgets::shinyRenderWidget(
    expr, sigmaOutput, env, quoted = TRUE
  )
}
```

### JavaScript binding

The third piece in the puzzle is the JavaScript required to activate the widget. By convention, we will define our JavaScript binding in the file `inst/htmlwidgets/sigma.js`. Here is the full source code of the binding:

```js
HTMLWidgets.widget({

  name: "sigma",

  type: "output",

  factory: function(el, width, height) {

    // create our sigma object and bind it to the element
    var sig = new sigma(el.id);

    return {
      renderValue: function(x) {

        // parse gexf data
        var parser = new DOMParser();
        var data = parser.parseFromString(x.data, "application/xml");

        // apply settings
        for (var name in x.settings)
          sig.settings(name, x.settings[name]);

        // update the sigma object
        sigma.parsers.gexf(
          data,          // parsed gexf data
          sig,           // sigma object
          function() {
            // need to call refresh to reflect new settings
            // and data
            sig.refresh();
          }
        );
      },

      resize: function(width, height) {

        // forward resize on to sigma renderers
        for (var name in sig.renderers)
          sig.renderers[name].resize(width, height);  
      },

      // make the sigma object available as a property on the
      // widget instance we are returning from factory(). This
      // is generally a good idea for extensibility -- it helps
      // users of this widget interact directly with sigma,
      // if needed.
      s: sig
    };
  }
});
```

We provide a name and type for the widget, plus a `factory` function that takes `el` (the HTML element that will host this widget), `width`, and `height` (width and height of the HTML element, in pixels --- you can always use `offsetWidth` and `offsetHeight` for this).

The `factory` function should prepare the HTML element to start receiving values. In this case, we create a new `sigma` element and pass it to the `id` of the DOM element that hosts the widget on the page.

We are going to need access to the `sigma` object later (to update its data and settings), so we save it as a variable `sig`. Note that variables declared directly inside of the `factory` function are tied to a particular widget instance (`el`).

The return value of the `factory` function is called a _widget instance object_. It is a bridge between the htmlwidgets runtime, and the JavaScript visualization that you are wrapping. As the name implies, each widget instance object is responsible for managing a single widget instance on a page.

The widget instance object you create must have one required method, and may have one optional method:

1. The required `renderValue` method actually pours our dynamic data and settings into the widget's DOM element. The `x` parameter contains the widget data and settings. We parse and update the GEXF data, apply the settings to our previously-created `sig` object, and finally call `refresh` to reflect the new values on-screen. This method may be called repeatedly with different data (i.e., in Shiny), so be sure to account for that possibility. If it makes sense for your widget, consider making your visualization transition smoothly from one value of `x` to another.

2. The optional `resize` method is called whenever the element containing the widget is resized. The only reason not to implement this method is if your widget naturally scales (without additional JavaScript code needing to be invoked) when its element size changes. In the case of sigma.js, we forward the sizing information on to each of the underlying sigma renderers.

All JavaScript libraries handle initialization, binding to DOM elements, dynamically updating data, and resizing slightly differently. Most of the work on the JavaScript side of creating widgets is mapping these three functions, `factory`, `renderValue`, and `resize`, correctly onto the behavior of the underlying library.

The sigma.js example uses a simple object literal to create its widget instance object, but you can also use [class based objects](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes) or any other style of object, as long as `obj.renderValue(x)` and `obj.resize(width, height)` can be invoked on it.

You can add additional methods and properties on the widget instance object. Although they will not be called by htmlwidgets itself, they might be useful to users of your widget that know some JavaScript and want to further customize your widget by adding custom JS code (e.g., using the R function `htmlwidgets::onRender()`). In this case, we add a property `s` to make the sigma object itself available.

```{r eval=FALSE, tidy=FALSE}
library(sigma)
library(htmlwidgets)
library(magrittr)
d = system.file("examples/ediaspora.gexf.xml", package = "sigma")
sigma(d) %>% onRender("function(el, x) {
  // this.s is the sigma object
  console.log(this.s);
}")
```

### Demo

Our widget is now complete! If you want to test drive it without reproducing all of the code locally you can install it from GitHub as follows:

```r
devtools::install_github('jjallaire/sigma')
```

Here is the code to try it out with some sample data included with the package:

```r
library(sigma)
sigma(system.file("examples/ediaspora.gexf.xml", package = "sigma"))
```

If you execute this code in the R console, you will see the widget displayed in the RStudio Viewer (or in an external browser if you are not running RStudio). If you include it within an R Markdown document, the widget will be embedded into the document.

We can also use the widget in a Shiny application:

```{r eval=FALSE, tidy=FALSE}
library(shiny)
library(sigma)

gexf = system.file("examples/ediaspora.gexf.xml", package = "sigma")

ui = shinyUI(fluidPage(
  checkboxInput("drawEdges", "Draw Edges", value = TRUE),
  checkboxInput("drawNodes", "Draw Nodes", value = TRUE),
  sigmaOutput('sigma')
))

server = function(input, output) {
  output$sigma = renderSigma(
    sigma(gexf,
          drawEdges = input$drawEdges,
          drawNodes = input$drawNodes)
  )
}

shinyApp(ui = ui, server = server)
```

## Creating your own widgets {#htmlwidgets-create}

### Requirements

To implement a widget, you can create a new R package that in turn depends on the **htmlwidgets** package. You can install the package from CRAN as follows:

```r
install.packages("htmlwidgets")
```

While it is not strictly required, the step-by-step instructions below for getting started also make use of the **devtools** package, which you can also install from CRAN:

```r
install.packages("devtools")
```

It is also possible to implement a widget without creating an R package, but it requires you to understand more about HTML dependencies (`htmltools::htmlDependency()`). We have given an example in Section \@ref(htmlwidgets-advanced).

### Scaffolding

To create a new widget, you can call the `scaffoldWidget()` function to generate the basic structure for your widget. This function will:

* Create the `.R`, `.js`, and `.yaml` files required for your widget;

* If provided, take a [Bower](https://bower.io) package name and automatically download the JavaScript library (and its dependencies) and add the required entries to the `.yaml` file.

This method is highly recommended, as it ensures that you get started with the right file structure. Here is an example that assumes you want to create a widget named 'mywidget' in a new package of the same name:

```{r eval=FALSE}
# create package using devtools
devtools::create("mywidget")

# navigate to package dir
setwd("mywidget")

# create widget scaffolding
htmlwidgets::scaffoldWidget("mywidget")

# install the package so we can try it
devtools::install()
```

This creates a simple widget that takes a single `text` argument and displays that text within the widgets HTML element. You can try it like this:

```{r eval=FALSE}
library(mywidget)
mywidget("hello, world")
```

This is the most minimal widget possible, and does not yet include a JavaScript library to interface to (note that `scaffoldWidget()` can optionally include JavaScript library dependencies via the `bowerPkg` argument). Before getting started with development, you should review the introductory example above to make sure you understand the various components, and also review the additional articles and examples linked to in the next section.

### Other packages

Studying the source code of other packages is a great way to learn more about creating widgets:

1. The [**networkD3**](https://github.com/christophergandrud/networkD3) package illustrates creating a widget on top of [D3](http://d3js.org), using a custom sizing policy for a larger widget, and providing multiple widgets from a single package.

2. The [**dygraphs**](https://github.com/rstudio/dygraphs/) package illustrates using widget instance data, handling dynamic re-sizing, and using **magrittr** to decompose a large and flat JavaScript API into a more modular and pipeable R API.

3. The [**sparkline**](https://github.com/htmlwidgets/sparkline) package illustrates providing a custom HTML generation function (since sparklines must be housed in `<span>` rather than `<div>` elements).

If you have questions about developing widgets or run into problems during development, please do not hesitate to post an issue on the project's GitHub repository: https://github.com/ramnathv/htmlwidgets/issues.

## Widget sizing {#htmlwidgets-size}

In the spirit of HTML widgets working just like plots in R, it is important that HTML widgets intelligently size themselves to their container, be it the RStudio Viewer, a figure in a **knitr** document, or a UI panel within a Shiny application. The **htmlwidgets** framework provides a rich mechanism for specifying the sizing behavior of widgets.

This sizing mechanism is designed to address the following constraints that affect the natural size of a widget:

- **The kind of widget it is.** Some widgets may only be designed to look good at small, fixed sizes (like sparklines) while other widgets may want every pixel that can be spared (like network graphs).

- **The context into which the widget is rendered.** While a given widget might look great at 960px by 480px in an R Markdown document, the same widget would look silly at that size in the RStudio Viewer pane, which is typically much smaller.

Widget sizing is handled in two steps:

1. First, a sizing policy is specified for the widget. This is done via the `sizingPolicy` argument to the `createWidget` function. Most widgets can accept the default sizing policy (or override only one or two aspects of it) and get satisfactory sizing behavior (see details below).

2. The sizing policy is used by the framework to compute the correct width and height for a widget given where it is being rendered. This size information is then passed to the `factory` and `resize` methods of the widget's JavaScript binding. It is up to the widget to forward this size information to the underlying JavaScript library.

### Specifying a sizing policy

The default HTML widget sizing policy treats the widget with the same sizing semantics as an R plot. When printed at the R console, the widget is displayed within the RStudio Viewer and sized to fill the Viewer pane (modulo any padding). When rendered inside an R Markdown document, the widget is sized based on the default size of figures in the document.

Note that for most widgets the default sizing behavior is fine, and you will not need to create a custom sizing policy. If you need a slightly different behavior than the default, you can also selectively override the default behavior by calling the `sizingPolicy()` function and passing the result to `createWidget()`. For example:

```{r eval=FALSE, tidy=FALSE}
htmlwidgets::createWidget(
  "sigma",
  x,
  width = width,
  height = height,
  sizingPolicy = htmlwidgets::sizingPolicy(
    viewer.padding = 0,
    viewer.paneHeight = 500,
    browser.fill = TRUE
  )
)
```

Below are two examples:

- The **networkD3** package uses custom sizing policies for all of its widgets. The `simpleNetwork` widget eliminates padding (as D3.js is already providing padding), and specifies that it wants to fill up as much space as possible when displayed in a standalone web browser:

    ```{r eval=FALSE}
    sizingPolicy(padding = 0, browser.fill = TRUE)
    ```

- The `sankeyNetwork` widget requires much more space than is afforded by the RStudio Viewer or a typical **knitr** figure, so it disables those automatic sizing behaviors. It also provides a more reasonable default width and height for **knitr** documents:

    ```{r eval=FALSE, tidy=FALSE}
    sizingPolicy(viewer.suppress = TRUE,
                 knitr.figure = FALSE,
                 browser.fill = TRUE,
                 browser.padding = 75,
                 knitr.defaultWidth = 800,
                 knitr.defaultHeight = 500)
    ```

Table \@ref(tab:sizing-policy) shows the various options that can be specified within a sizing policy. Note that the default width, height, and padding will be overridden if their values for a specific viewing context are provided (e.g., `browser.defaultWidth` will override `defaultWidth` when the widget is viewed in a web browser). Also note that when you want a widget to fill a viewer, the padding is still applied.

Table: (\#tab:sizing-policy) Options that can be specified within a sizing policy.

| Option | Description |
|---|---|
| **defaultWidth** | Default widget width in all contexts (browser, viewer, and knitr). |
| **defaultHeight** | Similar to `defaultWidth`, but for heights instead. |
| **padding** | The padding (in pixels) in all contexts. |
| **viewer.defaultWidth** | Default widget width within the RStudio Viewer. |
| **viewer.defaultHeight** | Similar to `viewer.defaultWidth`. |
| **viewer.padding** | Padding around the widget in the RStudio Viewer (defaults to 15 pixels). |
| **viewer.fill** | When displayed in the RStudio Viewer, automatically size the widget to the viewer dimensions. Default to `TRUE`. |
| **viewer.suppress** | Never display the widget within the RStudio Viewer (useful for widgets that require a large amount of space for rendering). Defaults to `FALSE`. |
| **viewer.paneHeight** | Request that the RStudio Viewer be forced to a specific height when displaying this widget. |
| **browser.defaultWidth** | Default widget width within a standalone web browser. |
| **browser.defaultHeight** | Similar to `browser.defaultWidth`. |
| **browser.padding** | Padding in a standalone browser (defaults to 40 pixels). |
| **browser.fill** | When displayed in a standalone web browser, automatically size the widget to the browser dimensions. Defaults to `FALSE`. |
| **browser.external** |  Always use an external browser (via `browseURL()`). Defaults to `FALSE`, which will result in the use of an internal browser within RStudio v1.1 and higher. |
| **knitr.defaultWidth** | Default widget width within documents generated by **knitr** (e.g., R Markdown). |
| **knitr.defaultHeight** | Similar to `knitr.defaultWidth`. |
| **knitr.figure** | Apply the default **knitr** `fig.width` and `fig.height` to the widget rendered in R Markdown. Defaults to `TRUE`. |

### JavaScript resize method

Specifying a sizing policy allows **htmlwidgets** to calculate the width and height of your widget based on where it is being displayed. However, you still need to forward this sizing information on to the underlying JavaScript library for your widget.

Every JavaScript library handles dynamic sizing a bit differently. Some do it automatically, some have a `resize()` call to force a layout, and some require that size be set only along with data and other options. Whatever the case it is, the **htmlwidgets** framework will pass the computed sizes to both your `factory` function and `resize` function. Here is a sketch of a JavaScript binding:

```js
HTMLWidgets.widget({

  name: "demo",

  type: "output",

  factory: function(el, width, height) {

    return {
      renderValue: function(x) {

      },

      resize: function(width, height) {

      }
    };
  }
});
```

What you do with the passed width and height is up to you, and depends on the re-sizing semantics of the underlying JavaScript library. A couple of illustrative examples are included below:

- In the `dygraphs` widget (https://rstudio.github.io/dygraphs), the implementation of re-sizing is relatively simple, since the **dygraphs** library includes a `resize()` method to automatically size the graph to its enclosing HTML element:

    ```js
    resize: function(width, height) {
      if (dygraph)
        dygraph.resize();
    }
    ```

- In the `forceNetwork` widget (https://christophergandrud.github.io/networkD3/#force), the passed width and height are applied to the `<svg>` element that hosts the D3 network visualization, as well as forwarded on to the underlying D3 force simulation object:

    ```js
    factory: function(el, width, height) {

      var force = d3.layout.force();

      d3.select(el).append("svg")
        .attr("width", width)
        .attr("height", height);

      return {
        renderValue: function(x) {
          // implementation excluded
        },

        resize: function(width, height) {

          d3.select(el).select("svg")
            .attr("width", width)
            .attr("height", height);

          force.size([width, height]).resume();
        }
      };
    }
    ```

As you can see, re-sizing is handled in a wide variety of fashions in different JavaScript libraries. The `resize` method is intended to provide a flexible way to map the automatic sizing logic of **htmlwidgets** directly into the underlying library.

## Advanced topics {#htmlwidgets-advanced}

This section covers several aspects of creating widgets that are not required by all widgets, but are an essential part of getting bindings to certain types of JavaScript libraries to work properly. Topics covered include:

- Transforming JSON representations of R objects into representations required by JavaScript libraries (e.g., an R data frame to a D3 dataset).

- Passing JavaScript functions from R to JavaScript (e.g., a user-provided formatting or drawing function)

- Generating custom HTML to enclose a widget (the default is a `<div>`, but some libraries require a different element, e.g., a `<span>`).

- Creating a widget without creating an R package in the first place.

### Data transformation

R objects passed as part of the `x` parameter to the `createWidget()` function are transformed to JSON using the internal function `htmlwidgets:::toJSON()`^[Note that it is not exported from **htmlwidgets**, so you are not supposed to call this function directly.], which is basically a wrapper function of `jsonlite::toJSON()` by default. However, sometimes this representation is not what is required by the JavaScript library you are interfacing with. There are two JavaScript functions that you can use to transform the JSON data.

#### HTMLWidgets.dataframeToD3()

R data frames are represented in "long" form (an array of named vectors) whereas D3 typically requires "wide" form (an array of objects each of which includes all names and values). Since the R representation is smaller in size and much faster to transmit over the network, we create the long-form representation of R data, and then transform the data in JavaScript using the `dataframeToD3()` helper function.

Here is an example of the long-form representation of an R data frame:

```{r echo=FALSE, comment='', class.output='json'}
htmlwidgets:::toJSON2(head(iris, 3), pretty = TRUE)
```

After we apply `HTMLWidgets.dataframeToD3()`, it will become:

```{r echo=FALSE, comment='', class.output='json'}
htmlwidgets:::toJSON2(head(iris, 3), dataframe = 'row', pretty = TRUE)
```

As a real example, the `simpleNetwork` (https://christophergandrud.github.io/networkD3/#simple) widget accepts a data frame containing network links on the R side, and transforms it to a D3 representation within the JavaScript `renderValue` function:

```js
renderValue: function(x) {

  // convert links data frame to d3 friendly format
  var links = HTMLWidgets.dataframeToD3(x.links);

  // ... use the links, etc ...

}
```

#### HTMLWidgets.transposeArray2D()

Sometimes a 2-dimensional array requires a similar transposition. For this the `transposeArray2D()` function is provided. Here is an example array:

```{r echo=FALSE, comment='', class.output='json'}
htmlwidgets:::toJSON2(unname(head(iris, 6)), dataframe = 'column', pretty = TRUE)
```

`HTMLWidgets.transposeArray2D()` can transpose it to:

```{r echo=FALSE, comment='', class.output='json'}
htmlwidgets:::toJSON2(head(iris, 6), dataframe = 'values', pretty = TRUE)
```

As a real example, the [dygraphs](https://rstudio.github.io/dygraphs) widget uses this function to transpose the "file" (data) argument it gets from the R side before passing it on to the dygraphs library:

```javascript
renderValue: function(x) {

    // ... code excluded ...

    // transpose array
    x.attrs.file = HTMLWidgets.transposeArray2D(x.attrs.file);

    // ... more code excluded ...
}
```

#### Custom JSON serializer

You may find it necessary to customize the JSON serialization of widget data when the default serializer in **htmlwidgets** does not work in the way you have expected. For widget package authors, there are two levels of customization for the JSON serialization: you can either customize the default values of arguments for `jsonlite::toJSON()`, or just customize the whole function.

1. `jsonlite::toJSON()` has a lot of arguments, and we have already changed some of its default values. Below is the JSON serializer we use in **htmlwidgets** at the moment:

    ```{r eval=FALSE, code=head(capture.output(htmlwidgets:::toJSON2),-2), tidy.opts=list(width=39)}
    ```

    For example, we convert data frames to JSON by columns instead of rows (the latter is `jsonlite::toJSON`'s default). If you want to change the default values of any arguments, you can attach an attribute `TOJSON_ARGS` to the widget data to be passed to `createWidget()`, e.g.,

    ```{r eval=FALSE, tidy=FALSE}
    fooWidget = function(data, name, ...) {
      # ... process the data ...
      params = list(foo = data, bar = TRUE)
      # customize toJSON() argument values
      attr(params, 'TOJSON_ARGS') = list(
        digits = 7, na = 'string'
      )
      htmlwidgets::createWidget(name, x = params, ...)
    }
    ```

    We changed the default value of `digits` from 16 to 7, and `na` from `null` to `string` in the above example. It is up to you, the package author, whether you want to expose such customization to users. For example, you can leave an extra argument in your widget function so that users can customize the behavior of the JSON serializer:

    ```{r eval=FALSE, tidy=FALSE}
    fooWidget = function(
      data, name, ..., JSONArgs = list(digits = 7)
    ) {
      # ... process the data ...
      params = list(foo = data, bar = TRUE)
      # customize toJSON() argument values
      attr(params, 'TOJSON_ARGS') = JSONArgs
      htmlwidgets::createWidget(name, x = params, ...)
    }
    ```

    You can also use a global option `htmlwidgets.TOJSON_ARGS` to customize the JSON serializer arguments for all widgets in the current R session, e.g.

    ```{r eval=FALSE, tidy=FALSE}
    options(htmlwidgets.TOJSON_ARGS = list(
      digits = 7, pretty = TRUE
    ))
    ```

1. If you do not want to use **jsonlite**, you can completely override the serializer function by attaching an attribute `TOJSON_FUNC` to the widget data, e.g.,

    ```{r eval=FALSE, tidy=FALSE}
    fooWidget = function(data, name, ...) {
      # ... process the data ...
      params = list(foo = data, bar = TRUE)
      # customize the JSON serializer
      attr(params, 'TOJSON_FUNC') = MY_OWN_JSON_FUNCTION
      htmlwidgets::createWidget(name, x = params, ...)
    }
    ```

    Here `MY_OWN_JSON_FUNCTION` can be an arbitrary R function that converts R objects to JSON. If you have also specified the `TOJSON_ARGS` attribute, it will be passed to your custom JSON function, too.

### Passing JavaScript functions

As you would expect, character vectors passed from R to JavaScript are converted to JavaScript strings. However, what if you want to allow users to provide custom JavaScript functions for formatting, drawing, or event handling? For this case, the **htmlwidgets** package includes a `JS()` function that allows you to request that a character value is evaluated as JavaScript when it is received on the client.

For example, the `dygraphs` widget (https://rstudio.github.io/dygraphs) includes a `dyCallbacks` function that allows the user to provide callback functions for a variety of contexts. These callbacks are "marked" as containing JavaScript so that they can be converted to actual JavaScript functions on the client:

```{r eval=FALSE, tidy=FALSE}
library(dygraphs)
dyCallbacks(
  clickCallback = JS(...)
  drawCallback = JS(...)
  highlightCallback = JS(...)
  pointClickCallback = JS(...)
  underlayCallback = JS(...)
)
```

Another example is in the `DT` (DataTables) widget (https://rstudio.github.io/DT), where users can specify an `initComplete` with JavaScript to execute after the table is loaded and initialized:

```{r eval=FALSE, tidy=FALSE}
datatable(head(iris, 20), options = list(
  initComplete = JS(
    "function(settings, json) {",
    "$(this.api().table().header()).css({
      'background-color': '#000',
      'color': '#fff'
     });",
    "}")
))
```

If multiple arguments are passed to `JS()` (as in the above example), they will be concatenated into a single string separated by `\n`.

### Custom widget HTML

Typically the HTML "housing" for a widget is just a `<div>` element, and this is correspondingly the default behavior for new widgets that do not specify otherwise. However, sometimes you need a different element type. For example, the `sparkline` widget (https://github.com/htmlwidgets/sparkline) requires a `<span>` element, so it implements the following custom HTML generation function:

```r
sparkline_html = function(id, style, class, ...){
  htmltools::tags$span(id = id, class = class)
}
```

Note that this function is looked up within the package implementing the widget by the convention `widgetname_html`, so it need not be formally exported from your package or otherwise registered with **htmlwidgets**.

Most widgets will not need a custom HTML function, but if you need to generate custom HTML for your widget (e.g., you need an `<input>` or a `<span>` rather than a `<div>`), you should use the **htmltools** package (as demonstrated by the code above).

### Create a widget without an R package

As we mentioned in Section \@ref(htmlwidgets-create), it is possible to create a widget without creating an R package in the first place. Below is an example:

```{r eval=FALSE, tidy=FALSE}
#' @param text A character string.
#' @param interval A time interval (in seconds).
blink = function(text, interval = 1) {
  htmlwidgets::createWidget(
    'blink', list(text = text, interval = interval),
    dependencies = htmltools::htmlDependency(
      'blink', '0.1', src = c(href = ''), head = '
<script>
HTMLWidgets.widget({
  name: "blink",
  type: "output",
  factory: function(el, width, height) {
    return {
      renderValue: function(x) {
        setInterval(function() {
          el.innerText = el.innerText == "" ? x.text : "";
        }, x.interval * 1000);
      },
      resize: function(width, height) {}
    };
  }
});
</script>'
    )
  )
}

blink('Hello htmlwidgets!', .5)
```

The widget simply shows a blinking character string, and you can specify the time interval. The key of the implementation is the HTML dependency, in which we used the `head` argument to embed the JavaScript binding. The value of the `src` argument is a little hackish due to the current restrictions in **htmltools** (which might be removed in the future). In the `renderValue` method, we show or hide the text periodically using the JavaScript function `setInterval()`.

<!--chapter:end:16-widgets.Rmd-->

# Document Templates {#document-templates}

When you create a new R Markdown document from the RStudio menu `File -> New File -> R Markdown`, you will see a default example document (a template) in the RStudio editor. In fact, you can create custom document templates by yourself, which can be useful if you need to create a particular type of document frequently or want to customize the appearance of the final report. The **rticles** package in Chapter \@ref(journals) is a good example of custom templates for a range of journals. Some additional examples of where a template could be used include:

- Creating a company branded R Markdown template that includes a logo and branding colors.

- Updating the default YAML settings to include standard fields for `title`, `author`, `date`, or default `output` options.

- Customizing the layout of the output document by adding additional fields to the YAML metadata. For example, you can add a `department` field to be included within your title page.

Once created, templates are easily accessed within RStudio, and will appear within the "New R Markdown" window as shown in Figure \@ref(fig:templates-select).

```{r templates-select, echo=FALSE, fig.cap="Selecting R Markdown templates within RStudio.", out.width='100%'}
knitr::include_graphics("images/templates-select.png", dpi = NA)
```

This chapter explains how to create templates and share them within an R package. If you would like to see some real-world examples, you may check out the source package of **rticles** (https://github.com/rstudio/rticles). The `rmarkdown::html_vignette` format is also a relatively simple example (see both its R source code and [the template structure](https://github.com/rstudio/rmarkdown/tree/master/inst/rmarkdown/templates/html_vignette)). In addition, Michael Harper has kindly prepared more examples in the repository https://github.com/dr-harper/example-rmd-templates.

## Template structure {#template-structure}

R Markdown templates should be contained within an R package, which can be easily created from the menu `File -> New Project` in RStudio (choose the project type to be "R Package"). If you are already familiar with creating R packages, you are certainly free to use your own favorite way to create a new package.

Templates are located within the `inst/rmarkdown/templates` directory of a package. This structure can be generated automatically with the [`use_rmarkdown_template()`](https://usethis.r-lib.org/reference/use_rmarkdown_template.html) function from the **usethis** package. It is possible to contain multiple templates in a single package, with each template stored in a separate sub-directory. As a minimal example, `inst/rmarkdown/templates/my_template` requires the following files:

```markdown
template.yaml
skeleton/skeleton.Rmd
```

The `template.yaml` specifies how the template is displayed within the RStudio "From Template" dialog box. This YAML file must have a `name` and a `description` field. You can optionally specify  `create_dir: true` if you want a new directory to be created when the template is selected. As an example of the `template.yaml` file:

```yaml
name: My Template
description: This is my template
```

You can provide a brief example R Markdown document in `skeleton.Rmd`, which will be opened in RStudio when the template is selected. We can add section titles, load commonly used packages, or specify default YAML parameters in this skeleton document. In the following example, we specify the default output format to `bookdown::html_document2`, and select a default template `flatly`:

```yaml
---
title: "Untitled"
author: "Your Name"
output:
  bookdown::html_document2:
    toc: true
    fig_caption: true
    template: flatly
---

## Introduction

## Analysis

## Conclusions
```

## Supporting files {#template-support}

Sometimes a template may require supporting files (e.g., images, CSS files, or LaTeX style files). Such files should be placed in the `skeleton` directory. They will be automatically copied to the directory where the new document is created. For example, if your template requires a logo and CSS style sheet, they can be put under the directory `inst/rmarkdown/templates/my_template`:

```markdown
template.yaml
skeleton/skeleton.Rmd
skeleton/logo.png
skeleton/styles.css
```

We can refer to these files within the `skeleton.Rmd` file, e.g.,

````markdown
---
title: "Untitled"
author: "Your Name"
output:
  html_document:
    css: styles.css
---

![logo](logo.png)

# Introduction

# Analysis

`r ''````{r}
knitr::kable(mtcars[1:5, 1:5])
```

# Conclusion
````

## Custom Pandoc templates {#template-pandoc}

An R Markdown is first compiled to Markdown through **knitr**, and then converted to an output document (e.g., PDF, HTML, or Word) by Pandoc through a Pandoc template. While the default Pandoc templates used by R Markdown are designed to be flexible by allowing parameters to be specified in the YAML, users may wish to provide their own template for more control over the output format.

You can make use of additional YAML fields from the source document when designing a Pandoc template\index{Pandoc template}. For example, you may wish to have a `department` field to be added to your title page, or include an `editor` field to be displayed below the author. We can add additional variables to the Pandoc template by surrounding the variable in dollar signs (`$`) within the template. Most variables take values from the YAML metadata of the R Markdown document (or command-line arguments passed to Pandoc). We may also use conditional statements and for-loops. Readers are recommended to check the Pandoc manual for more details: https://pandoc.org/MANUAL.html#using-variables-in-templates. Below is an example of a very minimal Pandoc template for HTML documents that only contains two variables (`$title$` and `$body$`):

```html
<html>
  <head>
    <title>$title$</title>
  </head>

  <body>
  $body$
  </body>
</html>
```

For R Markdown to use the customized template, you can specify the `template` option in the output format (provided that the output format supports this option), e.g.,

```yaml
output:
  html_document:
    template: template.html
```

If you wish to design your own template, we recommend starting from the default Pandoc templates included within the **rmarkdown** package (https://github.com/rstudio/rmarkdown/tree/master/inst/rmd) or Pandoc's built-in templates (https://github.com/jgm/pandoc-templates).

## Sharing your templates {#template-share}

As templates are stored within packages, it is easy to distribute them to other users. The most common and recommended way is to publish such packages to CRAN. If you decide not to take this way, you may also consider using GitHub to host your package instead, in which case users can also easily install your package and templates:

```{r, eval=FALSE}
if (!requireNamespace("devtools")) install.packages("devtools")
devtools::install_github("username/packagename")
```

To find out more about packages and the use of GitHub, you may refer to the book "*R Packages*" [@wickham2015] (http://r-pkgs.had.co.nz/git.html).

If you need some inspiration, there are many examples on CRAN and GitHub providing document templates, such as **tufte** (Chapter \@ref(tufte-handouts)), **prettydoc** (Section \@ref(prettydoc)), **rticles** (Chapter \@ref(journals)), [**memor**,](https://github.com/hebrewseniorlife/memor) and [**rtemps**,](https://github.com/bblodfon/rtemps) etc.

<!--chapter:end:17-templates.Rmd-->

# Creating New Formats {#new-formats}

The **rmarkdown** package has included many built-in document and presentation formats. At their core, these formats are just R functions. When you include an output format in the YAML metadata of a document, you are essentially specifying the format function to call and the parameters to pass to it.

We can create new formats for R Markdown, which makes it easy to customize output formats to use specific options or refer to external files. Defining a new function can be particularly beneficial if you have generated a new template as described in Chapter \@ref(document-templates), as it allows you to use your custom templates without having to copy any files to your local directory.

## Deriving from built-in formats {#format-derive}

The easiest way to create a new format is to write a function that calls one of the built-in formats. These built-in formats are designed to be extensible enough to serve as the foundation of custom formats. The following example, `quarterly_report`, is based on `html_document` but alters the default options:

```{r, eval=FALSE, tidy=FALSE}
quarterly_report = function(toc = TRUE) {
  # locations of resource files in the package
  pkg_resource = function(...) {
    system.file(..., package = "mypackage")
  }

  css    = pkg_resource("reports/styles.css")
  header = pkg_resource("reports/quarterly/header.html")

  # call the base html_document function
  rmarkdown::html_document(
    toc = toc, fig_width = 6.5, fig_height = 4,
    theme = NULL, css = css,
    includes = rmarkdown::includes(before_body = header)
  )
}
```

The new format defined has the following behavior:

1. Provides an option to determine whether a table of contents should be generated (implemented by passing `toc` through to the base format).

2. Sets a default height and width for figures (note that this is intentionally not user-customizable so as to encourage a standard for all reports of this type).

3. Disables the default Bootstrap theme and provides custom CSS in its place.

4. Adds a standard header to every document.

Note that (3) and (4) are implemented using external files that are stored within the package that defines the custom format, so their locations need to be looked up using the  `system.file()` function.

## Fully custom formats {#format-custom}

Another lower-level approach is to define a format directly by explicitly specifying **knitr** options and Pandoc command-line arguments. At its core, an R Markdown format consists of:

1. A set of **knitr** options that govern how Rmd is converted to Markdown.

2. A set of Pandoc options that govern how Markdown is converted to the final output format (e.g., HTML).

3. Some optional flags and filters (typically used to control handling of supporting files).

You can create a new format using the `output_format()` function in **rmarkdown**. Here is an example of a simple format definition:

```{r, eval=FALSE, tidy=FALSE}
#' @importFrom rmarkdown output_format knitr_options pandoc_options
simple_html_format = function() {
  # if you don't use roxygen2 (see above), you need to either
  # library(rmarkdown) or use rmarkdown::
  output_format(
    knitr = knitr_options(opts_chunk = list(dev = 'png')),
    pandoc = pandoc_options(to = "html"),
    clean_supporting = FALSE
  )
}
```

The **knitr** and Pandoc options can get considerably complicated (see help pages `?rmarkdown::knitr_options` and `?rmarkdown::pandoc_options` for details). The `clean_supporting` option indicates that you are not creating self-contained output (like a PDF or HTML document with base64 encoded resources), and therefore want to preserve supporting files like R plots generated during knitting.

You can also pass a `base_format` to the `output_format()` function if you want to inherit all of the behavior of an existing format but tweak a subset of its options.

If there are supporting files required for your format that cannot be easily handled by the `includes` option (see Section \@ref(includes)), you will also need to use the other arguments to `output_format` to ensure they are handled correctly (e.g., use the `intermediates_generator` to copy them into the place alongside the generated document).

The best way to learn more about creating fully custom formats is to study the source code of the existing built-in formats (e.g., `html_document` and `pdf_document`): https://github.com/rstudio/rmarkdown/tree/master/R. In some cases, a custom format will define its own Pandoc template, which was discussed in Section \@ref(template-pandoc).

## Using a new format {#format-use}

New formats should be stored within a package and installed onto your local system. This allows the format to be provided to the document YAML. Assuming our example format `quarterly_report` is in a package named **mypackage**, we can use it as follows:

```markdown
---
title: "Habits"
output:
  mypackage::quarterly_report:
    toc: true
---
```

This means to use the `quarterly_report()` function defined in **mypackage** as the output format, and to pass `toc = TRUE` as a parameter to the function.

<!--chapter:end:18-new-formats.Rmd-->

# Shiny Documents

We have briefly introduced Shiny\index{Shiny} documents in Section \@ref(intro-shiny). Shiny is a very powerful framework for building web applications based on R. It is out of the scope of this book to make a comprehensive introduction to Shiny (which is too big a topic). We recommend that readers who are not familiar with Shiny learn more about it from the website https://shiny.rstudio.com before reading this chapter.

Unlike the more traditional workflow of creating static reports, you can create documents that allow your readers to change the parameters underlying your analysis and see the results immediately in Shiny R Markdown documents. In the example shown in Figure \@ref(fig:shiny), the histogram will be automatically updated to reflect the number of bins selected by the reader.

A picture is worth a thousand words, and a Shiny document can potentially show you a thousand pictures as you interact with it. The readers are no longer tied to the fixed analysis and conclusions in the report. They may explore other possibilities by themselves, and possibly make new discoveries or draw different conclusions.

## Getting started {#shiny-start}

You can turn any _HTML-oriented_ R Markdown documents to Shiny documents by adding `runtime: shiny` to the YAML metadata as a _top-level_ field, e.g.,

```yaml
---
title: "Shiny Document"
output: html_document
runtime: shiny
---
```

Note that the output format of the R Markdown document must be an HTML format. That is, the document should generate a web page (a `*.html` file). Non-HTML formats such as `pdf_document` and `word_document` will not work with the Shiny runtime. Please also note that some presentation formats are also HTML formats, such as `ioslides_presentation` and `slidy_presentation`.

You can also create a new Shiny document from the RStudio menu `File -> New File -> R Markdown`, and choose the document type "Shiny" (see Figure \@ref(fig:shiny-new-document)).

```{r shiny-new-document, echo=FALSE, fig.cap='Create a new Shiny document in RStudio.', out.width='100%'}
knitr::include_graphics('images/shiny-new-document.png', dpi = NA)
```

To run a Shiny document in RStudio, you need to click the button "Run Document" on the editor toolbar (RStudio will automatically replace the "Knit" button with "Run Document" when it detects a Shiny document). If you do not use RStudio, or want to run the document in the R console for troubleshooting, you can call the function `rmarkdown::run()` and pass the filename to it.

You can embed Shiny inputs and outputs in your document. Outputs are automatically updated whenever inputs change. In the following example, we create a numeric input (`numericInput`) with the name `rows`, and then refer to its value via `input$rows` when generating output:

````markdown
`r ''````{r, echo=FALSE}
numericInput("rows", "How many cars?", 5)

renderTable({
  head(cars, input$rows)
})
```
````

```{r shiny-table, echo=FALSE, fig.cap='Increase the number of rows in the table in a Shiny document.', out.width='100%'}
knitr::include_graphics('images/shiny-table.png', dpi = NA)
```

In the above example, the output code was wrapped in a call to `renderTable()`. There are many other render functions in Shiny that can be used for plots, printed R output, and more. This example uses `renderPlot()` to create dynamic plot output:

````markdown
`r ''````{r, echo=FALSE}
sliderInput("bins", "Number of bins:", 30, min = 1, max = 50)

renderPlot({
  x    = faithful[, 2]  # Old Faithful Geyser data
  bins = seq(min(x), max(x), length.out = input$bins + 1)

  # draw the histogram with the specified number of bins
  hist(x, breaks = bins, col = 'darkgray', border = 'white')
})
```
````

```{r shiny-plot, echo=FALSE, fig.cap='Change the number of bins of a histogram in a Shiny document.', out.width='100%'}
knitr::include_graphics('images/shiny-plot.png', dpi = NA)
```

## Deployment {#shiny-deploy}

Shiny documents must be supported by a live R session running behind the scenes. When you run a Shiny document locally, it uses your local R session. Usually only you can see and interact with the document. If you want to share the document with people who do not have R installed, or do not want to run the document locally, you will have to deploy the document on a server, and share the URL of the document. Then other people only need a web browser to visit your document.

There are two ways to deploy a Shiny document. You can either use a hosted service provided by RStudio, or set up your own server. The first way is technically easier, but sometimes you may not be allowed to use an external hosted service, so you have to install the required software (Shiny Server or RStudio Connect)\index{Shiny Server}\index{RStudio Connect} on your own server to deploy the Shiny documents.

### ShinyApps.io

You can publish Shiny documents to the ShinyApps (https://shinyapps.io) hosted service. To do this you, should ensure that you have:

1. An account on ShinyApps (use the signup form to request an account).

2. A latest version of the **rsconnect** R package. You can install this as follows:

    ```r
    install.packages("rsconnect")
    ```

You can then deploy an interactive Shiny document in the same way that you currently deploy normal Shiny applications. From the working directory containing the document(s), just execute:

```r
rsconnect::deployApp()
```

If you are using RStudio, you can also use the `Publish` button available at the top-right of the window when running a Shiny document (see Figure \@ref(fig:shiny-deploy)).

```{r shiny-deploy, echo=FALSE, fig.cap='Deploy a Shiny document to ShinyApps.io.', out.width='100%'}
knitr::include_graphics('images/shiny-deploy.png', dpi = NA)
```

If there is a file named `index.Rmd` in the directory, it will be served as the default document for that directory, otherwise an explicit path to the Rmd file should be specified in the URL if you want to visit this Rmd document. For example, the URL for `index.Rmd` deployed to ShinyApps may be of the form `https://example.shinyapps.io/appName/`, and the URL for `test.Rmd` may be of the form `https://example.shinyapps.io/appName/test.Rmd`.

### Shiny Server / RStudio Connect

Both Shiny Server (https://www.rstudio.com/products/shiny/shiny-server/) and RStudio Connect (https://www.rstudio.com/products/connect/) can be used to publish Shiny documents. They require knowledge about Linux. Installing and configuring them should normally be a task for your system administrator if you are not familiar with Linux or do not have the privilege.

## Embedded Shiny apps {#shiny-embedded}

Besides embedding individual Shiny inputs and outputs in R Markdown, it is also possible to embed a standalone Shiny application within a document. There are two ways to do this:

1. Defining the application inline using the `shinyApp()` function; or

1. Referring to an external application directory using the `shinyAppDir()` function.

Both functions are available in the **shiny** package (not **rmarkdown**), which will be automatically loaded when `runtime: shiny` is specified in the YAML metadata of the document, so you do not have to call `library(shiny)` to load **shiny** (although it does not hurt if you load a package twice).

### Inline applications {#shiny-embed-inline}

This example uses an inline definition:

````markdown
`r ''````{r, echo=FALSE}
shinyApp(

  ui = fluidPage(
    selectInput("region", "Region:",
                choices = colnames(WorldPhones)),
    plotOutput("phonePlot")
  ),

  server = function(input, output) {
    output$phonePlot = renderPlot({
      barplot(WorldPhones[,input$region]*1000,
              ylab = "Number of Telephones", xlab = "Year")
    })
  },

  options = list(height = 500)
)
```
````

Note the use of the `height` parameter to determine how much vertical space the embedded application should occupy.

### External applications

This example embeds a Shiny application defined in another directory:

````markdown
`r ''````{r, echo = FALSE}
shinyAppDir(
  system.file("examples/06_tabsets", package="shiny"),
  options = list(width = "100%", height = 700)
)
```
````

Note that in all of R code chunks above, the chunk option `echo = FALSE` is used. This is to prevent the R code within the chunk from rendering to the output document alongside the Shiny components.

## Shiny widgets {#shiny-widgets}

Shiny widgets\index{Shiny widget} enable you to create re-usable Shiny components that are included within an R Markdown document using a single function call. Shiny widgets can also be invoked directly from the console (useful during authoring) and show their output within the RStudio Viewer pane or an external web browser.

### The `shinyApp()` function

At their core, Shiny widgets are mini-applications created using the `shinyApp()` function. Rather than creating a `ui.R` and `server.R` (or `app.R`) as you would for a typical Shiny application, you pass the UI and server definitions to the `shinyApp()` function as arguments. We have given an example in Section \@ref(shiny-embed-inline).

The simplest type of Shiny widget is just an R function that returns a `shinyApp()`.

### Example: k-Means clustering

The **rmdexamples** package (https://github.com/rstudio/rmdexamples) includes an example of a Shiny widget implemented in this fashion. The `kmeans_cluster()` function takes a single `dataset` argument and returns a Shiny widget to show the result of k-Means clustering. You can use it within an R Markdown document like this:

````markdown
`r ''````{r, echo = FALSE}
library(rmdexamples)
kmeans_cluster(iris)
```
````

Figure \@ref(fig:shiny-widget-kmeans) shows what the widget looks like inside a running document.

```{r shiny-widget-kmeans, echo=FALSE, fig.cap='A Shiny widget to apply k-Means clustering on a dataset.', out.width='100%'}
knitr::include_graphics('images/shiny-widget-kmeans.png', dpi = NA)
```

Below is the source code of the `kmeans_cluster()` function:

```r
kmeans_cluster = function(dataset) {

  library(shiny)  
  vars = names(dataset)

  shinyApp(
    ui = fluidPage(
      fluidRow(style = "padding-bottom: 20px;",
        column(4, selectInput('xcol', 'X Variable', vars)),
        column(4, selectInput('ycol', 'Y Variable', vars,
                              selected = vars[2])),
        column(4, numericInput('clusters', 'Cluster count', 3,
                               min = 1, max = 9))
      ),
      fluidRow(
        plotOutput('kmeans', height = "400px")  
      )
    ),

    server = function(input, output, session) {

      # Combine the selected variables into a new data frame
      selectedData = reactive({
        dataset[, c(input$xcol, input$ycol)]
      })

      clusters = reactive({
        kmeans(selectedData(), input$clusters)
      })

      output$kmeans = renderPlot(height = 400, {
        res = clusters()
        par(mar = c(5.1, 4.1, 0, 1))
        plot(selectedData(),
             col = res$cluster, pch = 20, cex = 3)
        points(res$centers, pch = 4, cex = 4, lwd = 4)
      })
    },

    options = list(height = 500)
  )
}
```

### Widget size and layout

Shiny widgets may be embedded in various places including standard full width pages, smaller columns within pages, and even HTML5 presentations. For the widget size and layout to work well in all of these contexts, we recommend that the total height of the widget is no larger than 500 pixels. This is not a hard and fast rule, but HTML5 slides can typically only display content less than 500px in height, so if you want your widget to be usable within presentations, this is a good guideline to follow.

You can also add an explicit `height` argument to the function that creates the widget (default to 500 so it works well within slides).

## Multiple pages {#shiny-multiple}

You can link to other Shiny documents by using the Markdown link syntax and specifying the *relative* path to the document, e.g., `[Another Shiny Document](another.Rmd)`. If you click the link to another Rmd document on one page, that Rmd document will be launched as the current interactive Shiny document.

Currently, only one document can be active at a time, so documents cannot easily share state, although some primitive global sharing is possible via the R script `global.R` (see the help page `?rmarkdown::run`).

By default, it is only possible to link to R Markdown files in the same directory subtree as the file on which `rmarkdown::run()` was invoked (e.g., you cannot link to `../foo.Rmd`). You can use the `dir` argument of `rmarkdown::run()` to indicate the directory to be treated as the root.

## Delayed rendering {#shiny-delay}

A Shiny document is typically rendered every time it is shown, and is not shown to the user until the rendering is complete. Consequently, a document that is large or contains expensive computations may take some time to load.

If your document contains interactive Shiny components that do not need to be rendered right away, you can wrap Shiny code in the `rmarkdown::render_delayed()` function. This function saves its argument until the document's rendering is done and has been shown to the user, then evaluates it and injects it into the output document when the computation is finished.

Here is an example that demonstrates how `render_delayed()` works. The code enclosed within the `render_delayed()` call will execute only after the document has been loaded and displayed to the user:

````markdown
`r ''````{r, echo = FALSE}
numericInput("rows", "How many cars?", 5)

rmarkdown::render_delayed({
  renderTable({
    head(cars, input$rows)
  })
})
```
````

## Output arguments for render functions {#shiny-args}

In a typical Shiny application, you specify an output element in the UI using functions like `plotOutput()` and `verbatimTextOutput()`, and render its content using functions like `renderPlot()` and `renderPrint()`.

By comparison, in a Shiny document, the UI elements are often implicitly and automatically created when you call the `renderXXX()` functions. For example, you may want to use a `renderPlot()` function without having to create a `plotOutput()` slot beforehand. In this case, Shiny helpfully associates the corresponding output object to each `renderXXX()` function, letting you use Shiny code outside of a full Shiny app. However, some functionality can be lost in this process. In particular, `plotOutput()` can take in some optional arguments to set things like width and height, or allow you to click or brush over the plot (and store that information).

To pass options from `renderXXX()` to `xxxOutput()`, you can use the `outputArgs` argument, if it is available to specific `renderXXX()` functions. For example, suppose that you want to render a plot and specify its width to be 200px and height to be 100px. Then you should use:

````markdown
`r ''````{r, echo = FALSE}
renderPlot({
  plot(yourData)
}, outputArgs = list(width = "200px", height = "100px")
)
```
````

No matter how many output arguments you want to set (all the way from zero to all possible ones), `outputArgs` always takes in a list (the default is an empty list, which sets no output arguments). If you try to pass in a non-existent argument, you will get an error like the following message (in this example, you tried to set an argument named `not_an_argument`):

```markdown
**Error**: Unused argument: in `outputArgs`, `not_an_argument`
is not an valid argument for the output function
```

To see `outputArgs` in action, run the R Markdown document below or visit https://gallery.shinyapps.io/output-args/ for the live version online. The document is interactive: brush over the image and see the `xmin`, `xmax`, `ymin`, and `ymax` values change (printed right under the image).

````markdown
`r xfun::file_string('examples/shiny-output-args.Rmd')`
````

### A caveat

We want to emphasize that you can only use this functionality within a Shiny R Markdown document (i.e., you must set `runtime: shiny` in the YAML metadata). But even if that is the case, this is only applicable to pieces of Shiny code that render output without the corresponding explicit output elements in the UI. If you embed a full Shiny application in your document and try to use `outputArgs`, it will be ignored and print the following warning to the R Markdown console (in this case, your `ui` function would be something like `ui = plotOutput("plot")`):

```markdown
Warning in `output$plot`(...) :
Unused argument: outputArgs. The argument outputArgs is only
meant to be used when embedding snippets of Shiny code in an
R Markdown code chunk (using runtime: shiny). When running a
full Shiny app, please set the output arguments directly in
the corresponding output function of your UI code.
```

The same will happen if you try to use `outputArgs` in any other context, such as inside a regular (i.e., not embedded) Shiny app. The rationale is that if you are already specifying a `ui` function with all the `output` objects made explicit, you should set their arguments directly there instead of going through this round-about way.

<!--chapter:end:19-shiny.Rmd-->

\backmatter

`r if (knitr::is_html_output()) '
# References {-}
'`

```{r include=FALSE}
bib = knitr::write_bib(c(
  .packages(), 'blogdown', 'bookdown', 'knitr', 'rmarkdown', 'htmlwidgets', 'webshot', 'servr', 'xaringan', 'animation', 'pkgdown', 'tinytex', 'reticulate', 'JuliaCall', 'DT', 'leaflet', 'dygraphs', 'shiny', 'markdown', 'flexdashboard', 'tufte', 'revealjs', 'prettydoc', 'htmltools', 'rticles', 'learnr', 'rmdformats', 'pagedown'
), file = NULL)
bib = unlist(bib)
bib = gsub("'(Htmlwidgets|iframes|TeX Live|LaTeX)'", '\\1', bib)
xfun::write_utf8(bib, 'packages.bib')

# embed fonts
if (knitr::is_latex_output()) {
  pdfs = list.files(knitr::opts_chunk$get('fig.path'), '[.]pdf$', full.names = TRUE)
  invisible(lapply(pdfs, embedFonts))
}
```

<!--chapter:end:20-references.Rmd-->

